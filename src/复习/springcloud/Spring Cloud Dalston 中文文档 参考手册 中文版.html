<!DOCTYPE html>
<!-- saved from url=(0058)https://springcloud.cc/spring-cloud-dalston.html#_features -->
<html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Spring Cloud Dalston 中文文档 参考手册 中文版</title>
<link rel="stylesheet" href="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/css">
<style>article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html,body{font-size:100%}body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}a:hover{cursor:pointer}img,object,embed{max-width:100%;height:auto}object,embed{height:100%}img{-ms-interpolation-mode:bicubic}.left{float:left!important}.right{float:right!important}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}.text-justify{text-align:justify!important}.hide{display:none}body{-webkit-font-smoothing:antialiased}img,object,svg{display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px}select{width:100%}.center{margin-left:auto;margin-right:auto}.spread{width:100%}p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}a{color:#2156a5;text-decoration:underline;line-height:inherit}a:hover,a:focus{color:#1d4b8f}a img{border:none}p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}p aside{font-size:.875em;line-height:1.35;font-style:italic}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}h1{font-size:2.125em}h2{font-size:1.6875em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}h4,h5{font-size:1.125em}h6{font-size:1em}hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}em,i{font-style:italic;line-height:inherit}strong,b{font-weight:bold;line-height:inherit}small{font-size:60%;line-height:inherit}code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}ul.square{list-style-type:square}ul.circle{list-style-type:circle}ul.disc{list-style-type:disc}ul.no-bullet{list-style:none}ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}dl dt{margin-bottom:.3125em;font-weight:bold}dl dd{margin-bottom:1.25em}abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}abbr{text-transform:none}blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}blockquote cite:before{content:"\2014 \0020"}blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}h1{font-size:2.75em}h2{font-size:2.3125em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}table thead,table tfoot{background:#f7f8f7;font-weight:bold}table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}body{tab-size:4}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}.clearfix:after,.float-group:after{clear:both}*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}.keyseq{color:rgba(51,51,51,.8)}kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}.keyseq kbd:first-child{margin-left:0}.keyseq kbd:last-child{margin-right:0}.menuseq,.menu{color:rgba(0,0,0,.8)}b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}b.button:before{content:"[";padding:0 3px 0 2px}b.button:after{content:"]";padding:0 2px 0 3px}p a>code:hover{color:rgba(0,0,0,.9)}#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}#header:after,#content:after,#footnotes:after,#footer:after{clear:both}#content{margin-top:1.25em}#content:before{content:none}#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}#header .details span:first-child{margin-left:-.125em}#header .details span.email a{color:rgba(0,0,0,.85)}#header .details br{display:none}#header .details br+span:before{content:"\00a0\2013\00a0"}#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}#header .details br+span#revremark:before{content:"\00a0|\00a0"}#header #revnumber{text-transform:capitalize}#header #revnumber:after{content:"\00a0"}#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}#toc>ul{margin-left:.125em}#toc ul.sectlevel0>li>a{font-style:italic}#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}#toc li{line-height:1.3334;margin-top:.3334em}#toc a{text-decoration:none}#toc a:active{text-decoration:underline}#toctitle{color:#7a2518;font-size:1.2em}@media only screen and (min-width:768px){#toctitle{font-size:1.375em}body.toc2{padding-left:15em;padding-right:0}#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}#toc.toc2>ul{font-size:.9em;margin-bottom:0}#toc.toc2 ul ul{margin-left:0;padding-left:1em}#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}body.toc2.toc-right{padding-left:0;padding-right:15em}body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}#toc.toc2{width:20em}#toc.toc2 #toctitle{font-size:1.375em}#toc.toc2>ul{font-size:.95em}#toc.toc2 ul ul{padding-left:1.25em}body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}#content #toc>:first-child{margin-top:0}#content #toc>:last-child{margin-bottom:0}#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}#footer-text{color:rgba(255,255,255,.8);line-height:1.44}.sect1{padding-bottom:.625em}@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}.admonitionblock>table td.icon{text-align:center;width:80px}.admonitionblock>table td.icon img{max-width:none}.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}.exampleblock>.content>:first-child{margin-top:0}.exampleblock>.content>:last-child{margin-bottom:0}.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}.sidebarblock>:first-child{margin-top:0}.sidebarblock>:last-child{margin-bottom:0}.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}.listingblock pre.highlightjs{padding:0}.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}.listingblock pre.prettyprint{border-width:0}.listingblock>.content{position:relative}.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}.listingblock:hover code[data-lang]:before{display:block}.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}table.pyhltable td.code{padding-left:.75em;padding-right:0}pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}pre.pygments .lineno{display:inline-block;margin-right:.25em}table.pyhltable .linenodiv{background:none!important;padding-right:0!important}.quoteblock{margin:0 1em 1.25em 1.5em;display:table}.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}.quoteblock blockquote{margin:0;padding:0;border:0}.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}.quoteblock .quoteblock blockquote:before{display:none}.verseblock{margin:0 1em 1.25em 1em}.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}.verseblock pre strong{font-weight:400}.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}.quoteblock .attribution br,.verseblock .attribution br{display:none}.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}.quoteblock.abstract{margin:0 0 1.25em 0;display:block}.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}table.tableblock{max-width:100%;border-collapse:separate}table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}table.frame-all{border-width:1px}table.frame-sides{border-width:0 1px}table.frame-topbot{border-width:1px 0}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}table thead th,table tfoot th{font-weight:bold}tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}p.tableblock>code:only-child{background:none;padding:0}p.tableblock{font-size:1em}td>div.verse{white-space:pre}ol{margin-left:1.75em}ul li ol{margin-left:1.5em}dl dd{margin-left:1.125em}dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}ul.inline>li>*{display:block}.unstyled dl dt{font-weight:400;font-style:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.hdlist>table,.colist>table{border:0;background:none}.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}td.hdlist1{font-weight:bold;padding-bottom:1.25em}.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}.colist>table tr>td:last-of-type{padding:.25em 0}.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}.imageblock>.title{margin-bottom:0}.imageblock.thumb,.imageblock.th{border-width:6px}.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}.image.left{margin-right:.625em}.image.right{margin-left:.625em}a.image{text-decoration:none;display:inline-block}a.image object{pointer-events:none}sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}sup.footnote a,sup.footnoteref a{text-decoration:none}sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}#footnotes .footnote:last-of-type{margin-bottom:0}#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}.gist .file-data>table td.line-data{width:99%}div.unbreakable{page-break-inside:avoid}.big{font-size:larger}.small{font-size:smaller}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa}.black{color:#000}.black-background{background-color:#000}.blue{color:#0000bf}.blue-background{background-color:#0000fa}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa}.gray{color:#606060}.gray-background{background-color:#7d7d7d}.green{color:#006000}.green-background{background-color:#007d00}.lime{color:#00bf00}.lime-background{background-color:#00fa00}.maroon{color:#600000}.maroon-background{background-color:#7d0000}.navy{color:#000060}.navy-background{background-color:#00007d}.olive{color:#606000}.olive-background{background-color:#7d7d00}.purple{color:#600060}.purple-background{background-color:#7d007d}.red{color:#bf0000}.red-background{background-color:#fa0000}.silver{color:#909090}.silver-background{background-color:#bcbcbc}.teal{color:#006060}.teal-background{background-color:#007d7d}.white{color:#bfbfbf}.white-background{background-color:#fafafa}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00}span.icon>.fa{cursor:default}.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}.conum[data-value] *{color:#fff!important}.conum[data-value]+b{display:none}.conum[data-value]:after{content:attr(data-value)}pre .conum[data-value]{position:relative;top:-.125em}b.conum *{color:inherit!important}.conum:not([data-value]):empty{display:none}dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}h1,h2,p,td.content,span.alt{letter-spacing:-.01em}p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}p{margin-bottom:1.25rem}.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}.print-only{display:none!important}@media print{@page{margin:1.25cm .75cm}*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}a{color:inherit!important;text-decoration:underline!important}a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}abbr[title]:after{content:" (" attr(title) ")"}pre,blockquote,tr,img,object,svg{page-break-inside:avoid}thead{display:table-header-group}svg{max-width:100%}p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}#toc,.sidebarblock,.exampleblock>.content{background:none!important}#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}.sect1{padding-bottom:0!important}.sect1+.sect1{border:0!important}#header>h1:first-child{margin-top:1.25rem}body.book #header{text-align:center}body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}body.book #header .details{border:0!important;display:block;padding:0!important}body.book #header .details span:first-child{margin-left:0!important}body.book #header .details br{display:block}body.book #header .details br+span:before{content:none!important}body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}.listingblock code[data-lang]:before{display:block}#footer{background:none!important;padding:0 .9375em}#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}.hide-on-print{display:none!important}.print-only{display:block!important}.hide-for-print{display:none!important}.show-for-print{display:inherit!important}}</style>
<link type="text/css" rel="stylesheet" charset="UTF-8" href="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/springcloud.min.css"><script type="text/javascript" charset="UTF-8" src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/springcloud.min.js.下载"></script></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Spring Cloud</h1>
<div id="toc" class="toc2">
<div id="toctitle"><font o="2">目录</font></div>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_features"><font o="3">特性</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_cloud_native_applications"><font o="4">云原生应用程序</font></a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_context_application_context_services"><font o="5">Spring Cloud上下文：应用程序上下文服务</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_the_bootstrap_application_context"><font o="6">引导应用程序上下文</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_application_context_hierarchies"><font o="7">应用程序上下文层次结构</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-properties"><font o="8">改变引导位置Properties</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#overriding-bootstrap-properties"><font o="9">覆盖远程Properties的值</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_bootstrap_configuration"><font o="10">自定义引导配置</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-property-sources"><font o="11">自定义引导属性源</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_environment_changes"><font o="12">环境变化</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_refresh_scope"><font o="13">刷新范围</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_encryption_and_decryption"><font o="14">加密和解密</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_endpoints"><font o="15">端点</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_commons_common_abstractions"><font o="16">Spring Cloud Commons：普通抽象</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#__enablediscoveryclient"><font o="17">@EnableDiscoveryClient</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_serviceregistry"><font o="18">ServiceRegistry</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_resttemplate_as_a_load_balancer_client"><font o="19">Spring RestTemplate作为负载平衡器客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_multiple_resttemplate_objects"><font o="20">多个RestTemplate对象</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#ignore-network-interfaces"><font o="21">忽略网络接口</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_config">Spring Cloud Config</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_quick_start"><font o="23">快速开始</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_client_side_usage"><font o="24">客户端使用</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_config_server"><font o="25">Spring Cloud Config服务器</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_environment_repository"><font o="26">环境库</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_health_indicator"><font o="27">健康指标</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_security"><font o="28">安全</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_encryption_and_decryption_2"><font o="29">加密和解密</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_key_management"><font o="30">密钥管理</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_creating_a_key_store_for_testing"><font o="31">创建用于测试的密钥库</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_multiple_keys_and_key_rotation"><font o="32">使用多个键和键旋转</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_serving_encrypted_properties"><font o="33">服务加密Properties</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_serving_alternative_formats"><font o="34">服务替代格式</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_serving_plain_text"><font o="35">服务纯文本</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_embedding_the_config_server"><font o="36">嵌入配置服务器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_push_notifications_and_spring_cloud_bus"><font o="37">推送通知和Spring Cloud Bus</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_config_client"><font o="38">Spring Cloud Config客户端</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#config-first-bootstrap"><font o="39">配置第一引导</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#discovery-first-bootstrap"><font o="40">发现第一个引导</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#config-client-fail-fast"><font o="41">配置客户端快速失败</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#config-client-retry"><font o="42">配置客户端重试</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_locating_remote_configuration_resources"><font o="43">查找远程配置资源</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_security_2"><font o="44">安全</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_vault_2">Vault</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_netflix">Spring Cloud Netflix</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_service_discovery_eureka_clients"><font o="47">服务发现：Eureka客户端</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-eureka-client-starter"><font o="48">如何包含Eureka客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_with_eureka"><font o="49">注册Eureka</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_authenticating_with_the_eureka_server"><font o="50">使用Eureka服务器进行身份验证</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_status_page_and_health_indicator"><font o="51">状态页和健康指标</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_a_secure_application"><font o="52">注册安全应用程序</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_eureka_s_health_checks"><font o="53">Eureka的健康检查</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_eureka_metadata_for_instances_and_clients"><font o="54">Eureka实例和客户端的元数据</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_the_eurekaclient"><font o="55">使用EurekaClient</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_alternatives_to_the_native_netflix_eurekaclient"><font o="56">本机Netflix EurekaClient的替代方案</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_why_is_it_so_slow_to_register_a_service"><font o="57">为什么注册服务这么慢？</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_zones"><font o="58">区</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server"><font o="59">服务发现：Eureka服务器</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-eureka-server-starter"><font o="60">如何包含Eureka服务器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-running-eureka-server"><font o="61">如何运行Eureka服务器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server-zones-and-regions"><font o="62">高可用性，区域和地区</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_standalone_mode"><font o="63">独立模式</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_peer_awareness"><font o="64">同行意识</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_prefer_ip_address"><font o="65">IP地址偏好</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clients"><font o="66">断路器：Hystrix客户端</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-hystrix-starter"><font o="67">如何加入Hystrix</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_propagating_the_security_context_or_using_spring_scopes"><font o="68">传播安全上下文或使用Spring范围</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_health_indicator_3"><font o="69">健康指标</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_hystrix_metrics_stream"><font o="70">Hystrix指标流</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboard"><font o="71">断路器：Hystrix仪表板</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_hystrix_timeouts_and_ribbon_clients"><font o="72">Hystrix超时和Ribbon客户</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-hystrix-dashboard-starter"><font o="73">如何包含Hystrix仪表板</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_turbine">Turbine</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_turbine_stream">Turbine Stream</a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="76">客户端负载平衡器：Ribbon</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-ribbon-starter"><font o="77">如何加入Ribbon</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_ribbon_client"><font o="78">自定义Ribbon客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_ribbon_client_using_properties"><font o="79">使用属性自定义Ribbon客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_ribbon_with_eureka"><font o="80">在Eureka中使用Ribbon</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka"><font o="81">示例：如何使用Ribbon不使用Eureka</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_example_disable_eureka_use_in_ribbon"><font o="82">示例：在Ribbon中禁用Eureka使用</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_the_ribbon_api_directly"><font o="83">直接使用Ribbon API</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#ribbon-child-context-eager-load"><font o="84">缓存Ribbon配置</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign"><font o="85">声明性REST客户端：Feign</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-feign-starter"><font o="86">如何加入Feign</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-overriding-defaults"><font o="87">覆盖Feign默认值</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_creating_feign_clients_manually"><font o="88">手动创建Feign客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-hystrix"><font o="89">Feign Hystrix支持</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-hystrix-fallback"><font o="90">Feign Hystrix回退</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_feign_and_code_primary_code"><font o="91">Feign和<code i="63">@Primary</code></font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-inheritance"><font o="92">Feign继承支持</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_feign_request_response_compression"><font o="93">Feign请求/响应压缩</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_feign_logging"><font o="94">Feign日志记录</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_external_configuration_archaius"><font o="95">外部配置：Archaius</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_router_and_filter_zuul"><font o="96">路由器和过滤器：Zuul</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-zuul-starter"><font o="97">如何加入Zuul</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-zuul-reverse-proxy"><font o="98">嵌入式Zuul反向代理</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_zuul_http_client"><font o="99">Zuul Http客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_cookies_and_sensitive_headers"><font o="100">Cookie和敏感Header</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_ignored_headers"><font o="101">忽略的Header</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_the_routes_endpoint"><font o="102">路线端点</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_strangulation_patterns_and_local_forwards"><font o="103">扼杀模式和本地前进</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_uploading_files_through_zuul"><font o="104">通过Zuul上传文件</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_query_string_encoding"><font o="105">查询字符串编码</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_plain_embedded_zuul"><font o="106">普通嵌入Zuul</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_disable_zuul_filters"><font o="107">禁用Zuul过滤器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#hystrix-fallbacks-for-routes"><font o="108">为路线提供Hystrix回退</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#zuul-developer-guide"><font o="109">Zuul开发人员指南</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_polyglot_support_with_sidecar"><font o="110">Polyglot支持Sidecar</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-rxjava-springmvc"><font o="111">RxJava与Spring MVC</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-metrics"><font o="112">指标：Spectator，Servo和Atlas</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_dimensional_vs_hierarchical_metrics"><font o="113">维度与层次度量</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_default_metrics_collection"><font o="114">默认度量集合</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-metrics-spectator"><font o="115">指标集：Spectator</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-metrics-servo"><font o="116">指标集：Servo</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#netflix-metrics-atlas"><font o="117">指标后端：Atlas</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#retrying-failed-requests"><font o="118">重试失败的请求</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_stream"><font o="119">Spring Cloud Stream</font></a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_introducing_spring_cloud_stream"><font o="120">介绍Spring Cloud Stream</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_main_concepts"><font o="121">主要概念</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_application_model"><font o="122">应用模型</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_the_binder_abstraction"><font o="123">Binder抽象</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_persistent_publish_subscribe_support"><font o="124">持续发布 - 订阅支持</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#consumer-groups"><font o="125">消费群体</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#partitioning"><font o="126">分区支持</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_programming_model"><font o="127">编程模型</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_declaring_and_binding_channels"><font o="128">声明和绑定频道</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_binders">Binders</a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_producers_and_consumers"><font o="130">生产者和消费者</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_binder_spi">Binder SPI</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_binder_detection"><font o="132">Binder检测</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-binders"><font o="133">Classpath上有多个Binders</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-systems"><font o="134">连接到多个系统</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_binder_configuration_properties"><font o="135">Binder配置属性</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_configuration_options"><font o="136">配置选项</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_stream_properties"><font o="137">Spring Cloud Stream Properties</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#binding-properties"><font o="138">绑定Properties</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#dynamicdestination"><font o="139">使用动态绑定目的地</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#contenttypemanagement"><font o="140">内容类型和转换</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#mime-types"><font o="141">MIME类型</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#mime-types-and-java-types"><font o="142">MIME类型和Java类型</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_message_conversion"><font o="143">自定义邮件转换</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#__code_streamlistener_code_and_message_conversion"><font o="144"><code i="64">@StreamListener</code>和邮件转换</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#schema-evolution"><font o="145" class="">Schema进化支持</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_apache_avro_message_converters"><font o="146">Apache Avro讯息转换器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_converters_with_schema_support"><font o="147">具有模式支持的转换器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_schema_registry_support"><font o="148" class="">Schema注册表支持</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_schema_registry_server"><font o="149">Schema注册服务器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_schema_registry_client"><font o="150">Schema注册表客户端</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_avro_schema_registry_client_message_converters"><font o="151">Avro Schema注册表客户端消息转换器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_schema_registration_and_resolution"><font o="152">Schema注册和解决</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_inter_application_communication"><font o="153">应用间通信</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_connecting_multiple_application_instances"><font o="154">连接多个应用程序实例</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_instance_index_and_instance_count"><font o="155">实例索引和实例计数</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_partitioning"><font o="156">分区</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_testing"><font o="157">测试</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_health_indicator_4"><font o="158">健康指标</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_metrics_emitter"><font o="159" class="">指标发射器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_samples"><font o="160">样品</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_getting_started"><font o="161">入门</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_binder_implementations"><font o="162">Binder实现</font></a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_apache_kafka_binder"><font o="163">Apache Kafka Binder</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_usage"><font o="164">用法</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_apache_kafka_binder_overview"><font o="165">Apache Kafka Binder概述</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_configuration_options_2"><font o="166">配置选项</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#kafka-dlq-processing"><font o="167">Dead-Letter主题处理</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_rabbitmq_binder">RabbitMQ Binder</a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_usage_2"><font o="169">用法</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_rabbitmq_binder_overview"><font o="170">RabbitMQ Binder概述</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_configuration_options_3"><font o="171">配置选项</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_retry_with_the_rabbitmq_binder"><font o="172">重试RabbitMQ Binder</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#rabbit-dlq-processing"><font o="173">Dead-Letter队列处理</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_bus">Spring Cloud Bus</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_quick_start_2"><font o="175">快速开始</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_addressing_an_instance"><font o="176">处理实例</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_addressing_all_instances_of_a_service"><font o="177">寻址服务的所有实例</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_application_context_id_must_be_unique"><font o="178">应用程序上下文ID必须是唯一的</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_the_message_broker"><font o="179">自定义Message Broker</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_tracing_bus_events"><font o="180">跟踪Bus Events</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_broadcasting_your_own_events"><font o="181">广播自己的Events</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_events_in_custom_packages"><font o="182">在自定义包中注册事件</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_sleuth"><font o="183">Spring Cloud Sleuth</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_terminology"><font o="184">术语</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_purpose"><font o="185">目的</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_adding_to_the_project"><font o="186">添加到项目中</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_additional_resources"><font o="187">额外的资源</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_features_2"><font o="188">特性</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_sampling"><font o="189">采样</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_instrumentation"><font o="190">仪表</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_span_lifecycle"><font o="191">Span生命周期</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#creating-and-closing-spans"><font o="192">创建和关闭spans</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#continuing-spans"><font o="193">继续spans</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#creating-spans-with-explicit-parent"><font o="194">用明确的父代创建spans</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_naming_spans"><font o="195">命名spans</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#__spanname_annotation"><font o="196">@SpanName注释</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_tostring_method"><font o="197">toString（）方法</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_managing_spans_with_annotations"><font o="198">管理spans注释</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_rationale"><font o="199">合理</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_creating_new_spans"><font o="200">创建新的spans</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_continuing_spans"><font o="201" class="">继续spans</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_more_advanced_tag_setting"><font o="202">更高级的标签设置</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizations"><font o="203">自定义</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_integration">Spring Integration</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_http"><font o="205">HTTP</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_example"><font o="206">例</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_custom_sa_tag_in_zipkin"><font o="207">Zipkin中的自定义SA标签</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_custom_service_name"><font o="208">自定义服务名称</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_host_locator"><font o="209">主机定位器</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_span_data_as_messages"><font o="210">Span Data作为消息</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_zipkin_consumer"><font o="211">Zipkin消费者</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_custom_consumer"><font o="212">定制消费者</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_metrics"><font o="213">度量</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_integrations"><font o="214">集成</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_runnable_and_callable"><font o="215">可运行和可调用</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_hystrix">Hystrix</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_rxjava"><font o="217">RxJava</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_http_integration"><font o="218">HTTP集成</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_http_client_integration"><font o="219">HTTP客户端集成</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_feign">Feign</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_asynchronous_communication"><font o="221">异步通信</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_messaging"><font o="222">消息</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_zuul_2">Zuul</a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_running_examples"><font o="224">运行示例</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_consul">Spring Cloud Consul</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-install"><font o="226">安装Consul</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-agent">Consul Agent</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-discovery"><font o="228">服务发现与Consul</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate"><font o="229">如何激活</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_with_consul"><font o="230">注册Consul</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_http_health_check"><font o="231">HTTP健康检查</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_the_discoveryclient"><font o="232">使用DiscoveryClient</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-config"><font o="233">具有Consul的分布式配置</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_2"><font o="234">如何激活</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing"><font o="235">定制</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-config-watch"><font o="236">配置观察</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-config-format"><font o="237">YAML或Properties配置</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-config-git2consul"><font o="238">git2consul与配置</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-failfast"><font o="239">快速失败</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-retry"><font o="240">Consul重试</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-bus"><font o="241">Spring Cloud Bus与Consul</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_3"><font o="242">如何激活</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-hystrix"><font o="243">断路器与Hystrix</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-turbine"><font o="244" class="">使用Turbine和Consul Hystrix指标聚合</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_zookeeper">Spring Cloud Zookeeper</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-install"><font o="246">安装Zookeeper</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-discovery"><font o="247">服务发现与Zookeeper</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_4"><font o="248">如何激活</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_with_zookeeper"><font o="249">注册Zookeeper</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_the_discoveryclient_2"><font o="250">使用DiscoveryClient</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-netflix"><font o="251">使用Spring Cloud Zookeeper与Spring Cloud Netflix组件</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_ribbon_with_zookeeper"><font o="252">Ribbon与Zookeeper</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-service-registry"><font o="253">Spring Cloud Zookeeper和服务注册表</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_instance_status"><font o="254">实例状态</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-dependencies"><font o="255">Zookeeper依赖关系</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_the_zookeeper_dependencies"><font o="256">使用Zookeeper依赖关系</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_zookeeper_dependencies"><font o="257">如何激活Zookeeper依赖关系</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_setting_up_zookeeper_dependencies"><font o="258">设置Zookeeper依赖关系</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_configuring_spring_cloud_zookeeper_dependencies"><font o="259">配置Spring Cloud Zookeeper依赖关系</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-dependency-watcher"><font o="260">Spring Cloud Zookeeper依赖关系观察者</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_5"><font o="261">如何激活</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_a_listener"><font o="262">注册listener</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_presence_checker"><font o="263">存在检查</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-config"><font o="264">分布式配置与Zookeeper</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_how_to_activate_6"><font o="265">如何激活</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customizing_2"><font o="266">定制</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_security">Spring Cloud Security</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_quickstart"><font o="268">快速开始</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_oauth2_single_sign_on"><font o="269">OAuth2单一登录</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_oauth2_protected_resource"><font o="270">OAuth2受保护资源</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_more_detail"><font o="271">更多详情</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_single_sign_on"><font o="272">单点登录</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_token_relay"><font o="273">令牌中继</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_configuring_authentication_downstream_of_a_zuul_proxy"><font o="274">配置Zuul代理下游的认证</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_for_cloud_foundry"><font o="275">Spring Cloud为Cloud Foundry</font></a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_discovery"><font o="276">发现</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_single_sign_on_2"><font o="277">单点登录</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract">Spring Cloud Contract</a>
<ul class="sectlevel1">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_2">Spring Cloud Contract</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_wiremock"><font o="280">Spring Cloud Contract WireMock</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_registering_stubs_automatically"><font o="281">自动注册存根</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_using_files_to_specify_the_stub_bodies"><font o="282">使用文件指定存根体</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_alternative_using_junit_rules"><font o="283">替代方法：使用JUnit规则</font></a></li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_wiremock_and_spring_mvc_mocks"><font o="284">WireMock和Spring MVC模拟器</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_generating_stubs_using_restdocs"><font o="285">使用RestDocs生成存根</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_generating_contracts_using_restdocs"><font o="286">使用RestDocs生成Contracts</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_verifier"><font o="287">Spring Cloud Contract验证者</font></a>
<ul class="sectlevel2">
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_introduction"><font o="288">介绍</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_faq"><font o="289">常问问题</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_verifier_http"><font o="290">Spring Cloud Contract验证者HTTP</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_verifier_messaging"><font o="291">Spring Cloud Contract验证器消息</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_core"><font o="293">Stub Runner核心</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_junit_rule"><font o="294">Stub Runner JUnit规则</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_spring_cloud">Stub Runner Spring Cloud</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_boot_application"><font o="296">Stub Runner启动应用程序</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_for_messaging"><font o="297">Stub Runner用于消息传递</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_camel"><font o="298">Stub Runner Camel</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_integration"><font o="299">Stub Runner集成</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_stream"><font o="300">Stub Runner Stream</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_stub_runner_spring_amqp"><font o="301">Stub Runner Spring AMQP</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_contract_dsl">Contract DSL</a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_customization"><font o="303">定制</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_pluggable_architecture"><font o="304">可插拔架构</font></a></li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_links"><font o="305">链接</font></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://springcloud.cc/spring-cloud-dalston.html#_appendix_compendium_of_configuration_properties"><font o="306">附录：配置纲要Properties</font></a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><font o="307">Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。</font><font o="308">分布式系统的协调导致了样板模式, 使用Spring Cloud开发人员可以快速地支持实现这些模式的服务和应用程序。</font><font o="309">他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。</font></p>
</div>
<div class="paragraph">
<p><font o="310">版本：Dalston.RELEASE</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_features"><font o="311">特性</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="312">Spring Cloud专注于提供良好的开箱即用经验的典型用例和可扩展性机制覆盖。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="313">分布式/版本化配置</font></p>
</li>
<li>
<p><font o="314">服务注册和发现</font></p>
</li>
<li>
<p><font o="315">路由</font></p>
</li>
<li>
<p><font o="316">service - to - service调用</font></p>
</li>
<li>
<p><font o="317">负载均衡</font></p>
</li>
<li>
<p><font o="318">断路器</font></p>
</li>
<li>
<p><font o="319">分布式消息传递</font></p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_cloud_native_applications" class="sect0"><font o="320">云原生应用程序</font></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><a href="https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook"><font o="321">云原生</font></a><font o="321">是一种应用开发风格，鼓励在持续交付和价值驱动开发领域轻松采用最佳实践。</font><font o="322">相关的学科是建立</font><a href="http://12factor.net/"><font o="322">12-factor Apps</font></a><font o="322">，其中开发实践与交付和运营目标相一致，例如通过使用声明式编程和管理和监控。</font><font o="323">Spring Cloud以多种具体方式促进这些开发风格，起点是一组功能，分布式系统中的所有组件都需要或需要时轻松访问。</font></p>
</div>
<div class="paragraph">
<p><font o="324">许多这些功能都由</font><a href="http://projects.spring.io/spring-boot"><font o="324">Spring Boot</font></a><font o="324">覆盖</font><font o="324">，我们在Spring Cloud中建立。</font><font o="325">更多的由Spring Cloud提供为两个库：Spring Cloud Context和Spring Cloud Commons。</font><font o="326">Spring Cloud上下文为Spring Cloud应用程序（引导上下文，加密，刷新范围和环境端点）的<code i="65">ApplicationContext</code>提供实用程序和特殊服务。</font><font o="327">Spring Cloud Commons是一组在不同的Spring Cloud实现中使用的抽象和常用类（例如Spring Cloud Netflix vs. Spring Cloud Consul）。</font></p>
</div>
<div class="paragraph">
<p><font o="328">如果由于“非法密钥大小”而导致异常，并且您正在使用Sun的JDK，则需要安装Java加密扩展（JCE）无限强度管理策略文件。</font><font o="329">有关详细信息，请参阅以下链接：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html"><font o="330">Java 6 JCE</font></a></p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html"><font o="331">Java 7 JCE</font></a></p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html"><font o="332">Java 8 JCE</font></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="333">将文件解压缩到JDK / jre / lib / security文件夹（无论您使用的是哪个版本的JRE / JDK x64 / x86）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="334">注意</font></div>
</td>
<td class="content"><font o="335">
Spring Cloud根据非限制性Apache 2.0许可证发布。</font><font o="336">如果您想为文档的这一部分做出贡献，或者发现错误，请在</font><a href="https://github.com/spring-cloud/spring-cloud-commons/tree/master/docs/src/main/asciidoc"><font o="336">github</font></a><font o="336">中找到项目中的源代码和问题跟踪器</font><font o="336">。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_context_application_context_services"><font o="337">Spring Cloud上下文：应用程序上下文服务</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="338">Spring Boot对于如何使用Spring构建应用程序有一个看法：例如它具有常规配置文件的常规位置，以及用于常见管理和监视任务的端点。</font><font o="339">Spring Cloud建立在此之上，并添加了一些可能系统中所有组件将使用或偶尔需要的功能。</font></p>
</div>
<div class="sect2">
<h3 id="_the_bootstrap_application_context"><font o="340">引导应用程序上下文</font></h3>
<div class="paragraph">
<p><font o="341">一个Spring Cloud应用程序通过创建一个“引导”上下文来进行操作，这个上下文是主应用程序的父上下文。</font><font o="342">开箱即用，负责从外部源加载配置属性，还解密本地外部配置文件中的属性。</font><font o="343">这两个上下文共享一个<code i="66">Environment</code>，这是任何Spring应用程序的外部属性的来源。</font><font o="344">Bootstrap属性的优先级高，因此默认情况下不能被本地配置覆盖。</font></p>
</div>
<div class="paragraph">
<p><font o="345">引导上下文使用与主应用程序上下文不同的外部配置约定，因此使用<code i="69">bootstrap.yml</code> <code i="67">application.yml</code>（或<code i="68">.properties</code>）代替引导和主上下文的外部配置。</font><font o="346">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="347">bootstrap.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  application:
    name: foo
  cloud:
    config:
      uri: ${SPRING_CONFIG_URI:http://localhost:8888}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="348">如果您的应用程序需要服务器上的特定于应用程序的配置，那么设置<code i="70">spring.application.name</code>（在<code i="71">bootstrap.yml</code>或<code i="72">application.yml</code>）中是个好主意。</font></p>
</div>
<div class="paragraph">
<p><font o="349">您可以通过设置<code i="73">spring.cloud.bootstrap.enabled=false</code>（例如在系统属性中）来完全禁用引导过程。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_application_context_hierarchies"><font o="350">应用程序上下文层次结构</font></h3>
<div class="paragraph">
<p><font o="351">如果您从<code i="74">SpringApplication</code>或<code i="75">SpringApplicationBuilder</code>构建应用程序上下文，则将Bootstrap上下文添加为该上下文的父级。</font><font o="352">这是一个Spring的功能，即子上下文从其父进程继承属性源和配置文件，因此与不使用Spring Cloud Config构建相同上下文相比，“主”应用程序上下文将包含其他属性源。</font><font o="353">额外的财产来源是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="354">“bootstrap”：如果在Bootstrap上下文中找到任何<code i="77">PropertySourceLocators</code>，则可选<code i="76">CompositePropertySource</code>显示为高优先级，并且具有非空属性。</font><font o="355">一个例子是来自Spring Cloud Config服务器的属性。</font><font o="356">有关</font><font o="356">如何自定义此属性源的内容的</font><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-property-sources"><font o="356">说明</font></a><font o="356">，</font><font o="356">请参阅
 </font><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-property-sources"><font o="356">下文</font></a><font o="356">。</font></p>
</li>
<li>
<p><font o="357">“applicationConfig：[classpath：bootstrap.yml]”（如果Spring配置文件处于活动状态，则为朋友）。</font><font o="358">如果您有一个<code i="78">bootstrap.yml</code>（或属性），那么这些属性用于配置引导上下文，然后在父进程设置时将它们添加到子上下文中。</font><font o="359">它们的优先级低于<code i="79">application.yml</code>（或属性）以及作为创建Spring Boot应用程序的过程的正常部分添加到子级的任何其他属性源。</font><font o="360">有关</font><font o="360">如何自定义这些属性源的内容的</font><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-properties"><font o="360">说明</font></a><font o="360">，</font><font o="360">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#customizing-bootstrap-properties"><font o="360">下文</font></a><font o="360">。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="361">由于属性源的排序规则，“引导”条目优先，但请注意，这些条目不包含来自<code i="80">bootstrap.yml</code>的任何数据，它具有非常低的优先级，但可用于设置默认值。</font></p>
</div>
<div class="paragraph">
<p><font o="362">您可以通过简单地设置您创建的任何<code i="81">ApplicationContext</code>的父上下文来扩展上下文层次结构，例如使用自己的界面，或使用<code i="82">SpringApplicationBuilder</code>方便方法（<code i="83">parent()</code>，<code i="84">child()</code>和<code i="85">sibling()</code>）。</font><font o="363">引导环境将是您创建自己的最高级祖先的父级。</font><font o="364">层次结构中的每个上下文都将有自己的“引导”属性源（可能为空），以避免无意中将值从父级升级到其后代。</font><font o="365">层次结构中的每个上下文（原则上）也可以具有不同的<code i="86">spring.application.name</code>，因此如果存在配置服务器，则不同的远程属性源。</font><font o="366">普通的Spring应用程序上下文行为规则适用于属性解析：子环境中的属性通过名称和属性源名称覆盖父项中的属性（如果子级具有与父级名称相同的属性源，一个来自父母的孩子不包括在孩子中）。</font></p>
</div>
<div class="paragraph">
<p><font o="367">请注意，<code i="87">SpringApplicationBuilder</code>允许您在整个层次结构中共享<code i="88">Environment</code>，但这不是默认值。</font><font o="368">因此，兄弟情境尤其不需要具有相同的资料或财产来源，尽管它们与父母共享共同点。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="customizing-bootstrap-properties"><font o="369">改变引导位置Properties</font></h3>
<div class="paragraph">
<p><font o="370">可以使用<code i="91">spring.cloud.bootstrap.name</code>（默认“引导”）或<code i="92">spring.cloud.bootstrap.location</code>（默认为空）指定<code i="89">bootstrap.yml</code>（或<code i="90">.properties</code>）位置，例如在系统属性中。</font><font o="371">这些属性的行为类似于具有相同名称的<code i="93">spring.config.*</code>变体，实际上它们用于通过在其<code i="95">Environment</code>中设置这些属性来设置引导<code i="94">ApplicationContext</code>。</font><font o="372">如果在正在构建的上下文中有活动的配置文件（来自<code i="96">spring.profiles.active</code>或通过<code i="97">Environment</code> API）），则该配置文件中的属性也将被加载，就像常规的Spring Boot应用程序，例如来自<code i="98">bootstrap-development.properties</code>的“开发”简介。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="overriding-bootstrap-properties"><font o="373">覆盖远程Properties的值</font></h3>
<div class="paragraph">
<p><font o="374">通过引导上下文添加到应用程序的属性源通常是“远程”（例如从配置服务器），并且默认情况下，不能在本地覆盖，除了在命令行上。</font><font o="375">如果要允许您的应用程序使用自己的系统属性或配置文件覆盖远程属性，则远程属性源必须通过设置<code i="99">spring.cloud.config.allowOverride=true</code>（在本地设置本身不起作用）授予权限。</font><font o="376">一旦设置了该标志，就会有一些更精细的设置来控制远程属性与系统属性和应用程序本地配置的位置：<code i="100">spring.cloud.config.overrideNone=true</code>覆盖任何本地属性源，<code i="101">spring.cloud.config.overrideSystemProperties=false</code>如果只有系统属性和env var应该覆盖远程设置，而不是本地配置文件。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_bootstrap_configuration"><font o="377">自定义引导配置</font></h3>
<div class="paragraph">
<p><font o="378">可以通过在<code i="103">org.springframework.cloud.bootstrap.BootstrapConfiguration</code>键下添加条目<code i="102">/META-INF/spring.factories</code>来训练引导上下文来执行任何您喜欢的操作。</font><font o="379">这是用于创建上下文的Spring <code i="104">@Configuration</code>类的逗号分隔列表。</font><font o="380">您可以在此处创建要用于自动装配的主应用程序上下文的任何bean，并且还有<code i="106">ApplicationContextInitializer</code>类型的<code i="105">@Beans</code>的特殊合同。</font><font o="381">如果要控制启动顺序（默认顺序为“最后”），可以使用<code i="107">@Order</code>标记类。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="382">警告</font></div>
</td>
<td class="content"><font o="383">
添加自定义<code i="108">BootstrapConfiguration</code>时，请注意，您添加的类不是错误的<code i="109">@ComponentScanned</code>到您的“主”应用程序上下文中，可能不需要它们。</font><font o="384">对于您的<code i="110">@ComponentScan</code>或<code i="111">@SpringBootApplication</code>注释配置类尚未涵盖的启动配置类，请使用单独的包名称。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="385">引导过程通过将初始化器注入主<code i="112">SpringApplication</code>实例（即正常的Spring Boot启动顺序，无论是作为独立应用程序运行还是部署在应用程序服务器中）结束。</font><font o="386">首先，从<code i="113">spring.factories</code>中找到的类创建引导上下文，然后在<code i="115">ApplicationContextInitializer</code>类型的所有<code i="114">@Beans</code>添加到主<code i="116">SpringApplication</code>开始之前。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="customizing-bootstrap-property-sources"><font o="387">自定义引导属性源</font></h3>
<div class="paragraph">
<p><font o="388">引导过程添加的外部配置的默认属性源是Config Server，但您可以通过将<code i="117">PropertySourceLocator</code>类型的bean添加到引导上下文（通过<code i="118">spring.factories</code>）添加其他源。</font><font o="389">您可以使用此方法从其他服务器或数据库中插入其他属性。</font></p>
</div>
<div class="paragraph">
<p><font o="390">作为一个例子，请考虑以下微不足道的自定义定位器：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class CustomPropertySourceLocator implements PropertySourceLocator {

    @Override
    public PropertySource&lt;?&gt; locate(Environment environment) {
        return new MapPropertySource("customProperty",
                Collections.&lt;String, Object&gt;singletonMap("property.from.sample.custom.source", "worked as intended"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="391">传入的<code i="119">Environment</code>是要创建的<code i="120">ApplicationContext</code>的<code i="119">Environment</code>，即为我们提供额外的属性来源的。</font><font o="392">它将已经具有正常的Spring Boot提供的资源来源，因此您可以使用它们来定位特定于此<code i="121">Environment</code>的属性源（例如通过将其绑定在<code i="122">spring.application.name</code>上，如在默认情况下所做的那样Config Server属性源定位器）。</font></p>
</div>
<div class="paragraph">
<p><font o="393">如果你在这个类中创建一个jar，然后添加一个<code i="123">META-INF/spring.factories</code>包含：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</pre>
</div>
</div>
<div class="paragraph">
<p><font o="394">那么“customProperty”<code i="124">PropertySource</code>将显示在其类路径中包含该jar的任何应用程序中。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_environment_changes"><font o="395">环境变化</font></h3>
<div class="paragraph">
<p><font o="396">应用程序将收听<code i="125">EnvironmentChangeEvent</code>，并以几种标准方式进行更改（用户可以以常规方式添加<code i="126">ApplicationListeners</code>附加<code i="126">ApplicationListeners</code>）。</font><font o="397">当观察到<code i="128">EnvironmentChangeEvent</code>时，它将有一个已更改的键值列表，应用程序将使用以下内容：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="398">重新绑定上下文中的任何<code i="129">@ConfigurationProperties</code> bean</font></p>
</li>
<li>
<p><font o="399">为<code i="130">logging.level.*</code>中的任何属性设置记录器级别</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="400">请注意，配置客户端不会通过默认轮询查找<code i="131">Environment</code>中的更改，通常我们不建议检测更改的方法（尽管可以使用<code i="132">@Scheduled</code>注释进行设置）。</font><font o="401">如果您有一个扩展的客户端应用程序，那么最好将<code i="133">EnvironmentChangeEvent</code>广播到所有实例，而不是让它们轮询更改（例如使用</font><a href="https://github.com/spring-cloud/spring-cloud-bus"><font o="401">Spring Cloud总线</font></a><font o="401">）。</font></p>
</div>
<div class="paragraph">
<p><font o="402"><code i="134">EnvironmentChangeEvent</code>涵盖了大量的刷新用例，只要您真的可以更改<code i="135">Environment</code>并发布事件（这些API是公开的，部分内核为Spring）。</font><font o="403">您可以通过访问<code i="137">/configprops</code>端点（普通Spring Boot执行器功能）来验证更改是否绑定到<code i="136">@ConfigurationProperties</code> bean。</font><font o="404">例如，<code i="138">DataSource</code>可以在运行时更改其<code i="139">maxPoolSize</code>（由Spring Boot创建的默认<code i="140">DataSource</code>是一个<code i="141">@ConfigurationProperties</code> bean），并且动态增加容量。</font><font o="405">重新绑定<code i="142">@ConfigurationProperties</code>不会覆盖另一大类用例，您需要更多的控制刷新，并且您需要更改在整个<code i="143">ApplicationContext</code>上是原子的。</font><font o="406">为了解决这些担忧，我们有<code i="144">@RefreshScope</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_refresh_scope"><font o="407">刷新范围</font></h3>
<div class="paragraph">
<p><font o="408">当配置更改时，标有<code i="146">@RefreshScope</code>的Spring <code i="145">@Bean</code>将得到特殊处理。</font><font o="409">这解决了状态bean在初始化时只注入配置的问题。</font><font o="410">例如，如果通过<code i="148">Environment</code>更改数据库URL时<code i="147">DataSource</code>有开放连接，那么我们可能希望这些连接的持有人能够完成他们正在做的工作。</font><font o="411">然后下一次有人从游泳池借用一个连接，他得到一个新的URL。</font></p>
</div>
<div class="paragraph">
<p><font o="412">刷新范围bean是在使用时初始化的懒惰代理（即当调用一个方法时），并且作用域作为初始值的缓存。</font><font o="413">要强制bean重新初始化下一个方法调用，您只需要使其缓存条目无效。</font></p>
</div>
<div class="paragraph">
<p><font o="414"><code i="149">RefreshScope</code>是上下文中的一个bean，它有一个公共方法<code i="150">refreshAll()</code>来清除目标缓存中的范围内的所有bean。</font><font o="415">还有一个<code i="151">refresh(String)</code>方法可以按名称刷新单个bean。</font><font o="416">此功能在<code i="152">/refresh</code>端点（通过HTTP或JMX）中公开。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="417">注意</font></div>
</td>
<td class="content"><font o="418">
<code i="153">@RefreshScope</code>（技术上）在<code i="154">@Configuration</code>类上工作，但可能会导致令人惊讶的行为：例如，这</font><strong><font o="418">并不</font></strong><font o="418"> 
意味着该类中定义的所有<code i="155">@Beans</code>本身都是<code i="156">@RefreshScope</code>。</font><font o="419">具体来说，任何取决于这些bean的东西都不能依赖它们在刷新启动时被更新，除非它本身在<code i="157">@RefreshScope</code>（在其中将重新刷新并重新注入其依赖关系），那么它们将从刷新的<code i="158">@Configuration</code>）重新初始化。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_encryption_and_decryption"><font o="420">加密和解密</font></h3>
<div class="paragraph">
<p><font o="421">Spring Cloud具有一个用于在本地解密属性值的<code i="159">Environment</code>预处理器。</font><font o="422">它遵循与Config Server相同的规则，并通过<code i="160">encrypt.*</code>具有相同的外部配置。</font><font o="423">因此，您可以使用<code i="161">{cipher}*</code>格式的加密值，只要有一个有效的密钥，那么在主应用程序上下文获取<code i="162">Environment</code>之前，它们将被解密。</font><font o="424">要在应用程序中使用加密功能，您需要在您的类路径中包含Spring安全性RSA（Maven协调“org.springframework.security:spring-security-rsa”），并且还需要全面强大的JCE扩展你的JVM</font></p>
</div>
<div class="paragraph">
<p><font o="425">如果由于“非法密钥大小”而导致异常，并且您正在使用Sun的JDK，则需要安装Java加密扩展（JCE）无限强度管理策略文件。</font><font o="426">有关详细信息，请参阅以下链接：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html"><font o="427">Java 6 JCE</font></a></p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html"><font o="428">Java 7 JCE</font></a></p>
</li>
<li>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html"><font o="429">Java 8 JCE</font></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="430">将文件解压缩到JDK / jre / lib / security文件夹（无论您使用的是哪个版本的JRE / JDK x64 / x86）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_endpoints"><font o="431">端点</font></h3>
<div class="paragraph">
<p><font o="432">对于Spring Boot执行器应用程序，还有一些额外的管理端点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="433">POST到<code i="163">/env</code>以更新<code i="164">Environment</code>并重新绑定<code i="165">@ConfigurationProperties</code>和日志级别</font></p>
</li>
<li>
<p><font o="434"><code i="166">/refresh</code>重新加载引导带上下文并刷新<code i="167">@RefreshScope</code> bean</font></p>
</li>
<li>
<p><font o="435"><code i="168">/restart</code>关闭<code i="169">ApplicationContext</code>并重新启动（默认情况下禁用）</font></p>
</li>
<li>
<p><font o="436"><code i="170">/pause</code>和<code i="171">/resume</code>调用<code i="172">Lifecycle</code>方法（<code i="173">stop()</code>和<code i="174">start()</code> <code i="175">ApplicationContext</code>）</font></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_commons_common_abstractions"><font o="437">Spring Cloud Commons：普通抽象</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="438">诸如服务发现，负载平衡和断路器之类的模式适用于所有Spring Cloud客户端可以独立于实现（例如通过Eureka或Consul发现）的消耗的共同抽象层。</font></p>
</div>
<div class="sect2">
<h3 id="__enablediscoveryclient"><font o="439">@EnableDiscoveryClient</font></h3>
<div class="paragraph">
<p><font o="440">Commons提供<code i="176">@EnableDiscoveryClient</code>注释。</font><font o="441">这通过<code i="178">META-INF/spring.factories</code>查找<code i="177">DiscoveryClient</code>接口的实现。</font><font o="442">Discovery Client的实现将在<code i="180">org.springframework.cloud.client.discovery.EnableDiscoveryClient</code>键下的<code i="179">spring.factories</code>中添加一个配置类。</font><font o="443"><code i="181">DiscoveryClient</code>实现的示例是</font><a href="http://cloud.spring.io/spring-cloud-netflix/"><font o="443">Spring Cloud Netflix Eureka</font></a><font o="443">，</font><a href="http://cloud.spring.io/spring-cloud-consul/"><font o="443">Spring Cloud Consul发现</font></a><font o="443">和</font><a href="http://cloud.spring.io/spring-cloud-zookeeper/"><font o="443">Spring Cloud Zookeeper发现</font></a><font o="443">。</font></p>
</div>
<div class="paragraph">
<p><font o="444">默认情况下，<code i="182">DiscoveryClient</code>的实现将使用远程发现服务器自动注册本地Spring Boot服务器。</font><font o="445">可以通过在<code i="184">@EnableDiscoveryClient</code>中设置<code i="183">autoRegister=false</code>来禁用此功能。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_serviceregistry"><font o="446">ServiceRegistry</font></h3>
<div class="paragraph">
<p><font o="447">Commons现在提供了一个<code i="185">ServiceRegistry</code>接口，它提供了诸如<code i="186">register(Registration)</code>和<code i="187">deregister(Registration)</code>之类的方法，允许您提供定制的注册服务。</font><font o="448"><code i="188">Registration</code>是一个标记界面。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
@EnableDiscoveryClient(autoRegister=false)
public class MyConfiguration {
    private ServiceRegistry registry;

    public MyConfiguration(ServiceRegistry registry) {
        this.registry = registry;
    }

    // called via some external process, such as an event or a custom actuator endpoint
    public void register() {
        Registration registration = constructRegistration();
        this.registry.register(registration);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="449">每个<code i="189">ServiceRegistry</code>实现都有自己的<code i="190">Registry</code>实现。</font></p>
</div>
<div class="sect3">
<h4 id="_serviceregistry_auto_registration"><font o="450">服务部门自动注册</font></h4>
<div class="paragraph">
<p><font o="451">默认情况下，<code i="191">ServiceRegistry</code>实现将自动注册正在运行的服务。</font><font o="452">要禁用该行为，有两种方法。</font><font o="453">您可以设置<code i="192">@EnableDiscoveryClient(autoRegister=false)</code>永久禁用自动注册。</font><font o="454">您还可以设置<code i="193">spring.cloud.service-registry.auto-registration.enabled=false</code>以通过配置禁用该行为。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_service_registry_actuator_endpoint"><font o="455">服务注册执行器端点</font></h4>
<div class="paragraph">
<p><font o="456">Commons提供<code i="194">/service-registry</code>致动器端点。</font><font o="457">该端点依赖于Spring应用程序上下文中的<code i="195">Registration</code> bean。</font><font o="458">通过GET调用<code i="196">/service-registry/instance-status</code>将返回<code i="197">Registration</code>的状态。</font><font o="459">具有<code i="198">String</code>主体的同一端点的POST将将当前<code i="199">Registration</code>的状态更改为新值。</font><font o="460">请参阅您正在使用的<code i="200">ServiceRegistry</code>实现的文档，以获取更新状态的允许值和为状态获取的值。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_resttemplate_as_a_load_balancer_client"><font o="461">Spring RestTemplate作为负载平衡器客户端</font></h3>
<div class="paragraph">
<p><font o="462"><code i="201">RestTemplate</code>可以自动配置为使用功能区。</font><font o="463">要创建负载平衡<code i="202">RestTemplate</code>创建<code i="203">RestTemplate</code> <code i="204">@Bean</code>并使用<code i="205">@LoadBalanced</code>限定符。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="464">警告</font></div>
</td>
<td class="content"><font o="465">
通过自动配置不再创建<code i="206">RestTemplate</code> bean。</font><font o="466">它必须由单个应用程序创建。
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    public String doOtherStuff() {
        String results = restTemplate.getForObject("http://stores/stores", String.class);
        return results;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="467">URI需要使用虚拟主机名（即服务名称，而不是主机名）。</font><font o="468">Ribbon客户端用于创建完整的物理地址。</font><font o="469">有关</font><font o="469">
如何设置<code i="207">RestTemplate</code>的详细信息，</font><font o="469">请参阅
 </font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonAutoConfiguration.java"><font o="469">RibbonAutoConfiguration</font></a><font o="469">。</font></p>
</div>
<div class="sect3">
<h4 id="_retrying_failed_requests"><font o="470">重试失败的请求</font></h4>
<div class="paragraph">
<p><font o="471">负载平衡<code i="208">RestTemplate</code>可以配置为重试失败的请求。</font><font o="472">默认情况下，该逻辑被禁用，您可以通过将</font><a href="https://github.com/spring-projects/spring-retry"><font o="472">Spring重试</font></a><font o="472">添加到应用程序的类路径</font><font o="472">来启用它</font><font o="472">。</font><font o="473">负载平衡<code i="209">RestTemplate</code>将符合与重试失败请求相关的一些Ribbon配置值。</font><font o="474">如果要在类路径中使用Spring重试来禁用重试逻辑，则可以设置<code i="210">spring.cloud.loadbalancer.retry.enabled=false</code>。</font><font o="475">您可以使用的属性是<code i="211">client.ribbon.MaxAutoRetries</code>，<code i="212">client.ribbon.MaxAutoRetriesNextServer</code>和<code i="213">client.ribbon.OkToRetryOnAllOperations</code>。</font><font o="476">请参阅</font><a href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties"><font o="476">Ribbon文档</font></a><font o="476"> 
，了解属性的具体内容。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="477">注意</font></div>
</td>
<td class="content"><font o="478">
上述示例中的<code i="214">client</code>应替换为您的Ribbon客户端名称。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_resttemplate_objects"><font o="479">多个RestTemplate对象</font></h3>
<div class="paragraph">
<p><font o="480">如果你想要一个没有负载平衡的<code i="215">RestTemplate</code>，创建一个<code i="216">RestTemplate</code> bean并注入它。</font><font o="481">要创建<code i="219">@Bean</code>时，使用<code i="218">@LoadBalanced</code>限定符来访问负载平衡<code i="217">RestTemplate</code>。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="482">重要</font></div>
</td>
<td class="content"><font o="483">
请注意下面示例中的普通<code i="221">RestTemplate</code>声明的<code i="220">@Primary</code>注释，以消除不合格的<code i="222">@Autowired</code>注入。
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate loadBalanced() {
        return new RestTemplate();
    }

    @Primary
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    @LoadBalanced
    private RestTemplate loadBalanced;

    public String doOtherStuff() {
        return loadBalanced.getForObject("http://stores/stores", String.class);
    }

    public String doStuff() {
        return restTemplate.getForObject("http://example.com", String.class);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="484">提示</font></div>
</td>
<td class="content"><font o="485">
如果您看到错误<code i="223">java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89</code>，请尝试注入<code i="224">RestOperations</code>或设置<code i="225">spring.aop.proxyTargetClass=true</code>。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="ignore-network-interfaces"><font o="486">忽略网络接口</font></h3>
<div class="paragraph">
<p><font o="487">有时，忽略某些命名网络接口是有用的，因此可以将其从服务发现注册中排除（例如，在Docker容器中运行）。</font><font o="488">可以设置正则表达式的列表，这将导致所需的网络接口被忽略。</font><font o="489">以下配置将忽略“docker0”接口和以“veth”开头的所有接口。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="490">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    inetutils:
      ignoredInterfaces:
        - docker0
        - veth.*</pre>
</div>
</div>
<div class="paragraph">
<p><font o="491">您还可以强制使用正则表达式列表中指定的网络地址：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="492">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    inetutils:
      preferredNetworks:
        - 192.168
        - 10.0</pre>
</div>
</div>
<div class="paragraph">
<p><font o="493">您也可以强制仅使用站点本地地址。</font><font o="494">有关</font><font o="494">更多详细信息，</font><font o="494">请参阅</font><a href="https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--"><font o="494">Inet4Address.html.isSiteLocalAddress（））</font></a><font o="494">是什么是站点本地地址。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="495">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    inetutils:
      useOnlySiteLocalInterfaces: true</pre>
</div>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_config" class="sect0">Spring Cloud Config</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><strong><font o="497">Dalston.RELEASE</font></strong></p>
</div>
<div class="paragraph">
<p><font o="498">Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。</font><font o="499">使用Config Server，您可以在所有环境中管理应用程序的外部属性。</font><font o="500">客户端和服务器上的概念映射与Spring <code i="226">Environment</code>和<code i="227">PropertySource</code>抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。</font><font o="501">随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。</font><font o="502">服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。</font><font o="503">很容易添加替代实现，并使用Spring配置将其插入。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_quick_start"><font o="504">快速开始</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="505">启动服务器：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ cd spring-cloud-config-server
$ ../mvnw spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p><font o="506">该服务器是一个Spring Boot应用程序，所以您可以从IDE运行它，而不是喜欢（主类是<code i="228">ConfigServerApplication</code>）。</font><font o="507">然后尝试一个客户端：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ curl localhost:8888/foo/development
{"name":"development","label":"master","propertySources":[
  {"name":"https://github.com/scratches/config-repo/foo-development.properties","source":{"bar":"spam"}},
  {"name":"https://github.com/scratches/config-repo/foo.properties","source":{"foo":"bar"}}
]}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="508">定位资源的默认策略是克隆一个git仓库（在<code i="229">spring.cloud.config.server.git.uri</code>），并使用它来初始化一个迷你<code i="230">SpringApplication</code>。</font><font o="509">小应用程序的<code i="231">Environment</code>用于枚举属性源并通过JSON端点发布。</font></p>
</div>
<div class="paragraph">
<p><font o="510">HTTP服务具有以下格式的资源：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</pre>
</div>
</div>
<div class="paragraph">
<p><font o="511">其中“应用程序”作为<code i="233">SpringApplication</code>中的<code i="232">spring.config.name</code>注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。</font></p>
</div>
<div class="paragraph">
<p><font o="512">Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_client_side_usage"><font o="513">客户端使用</font></h3>
<div class="paragraph">
<p><font o="514">要在应用程序中使用这些功能，只需将其构建为依赖于spring-cloud-config-client的Spring引导应用程序（例如，查看配置客户端或示例应用程序的测试用例）。</font><font o="515">添加依赖关系的最方便的方法是通过Spring Boot启动器<code i="234">org.springframework.cloud:spring-cloud-starter-config</code>。</font><font o="516">还有一个Maven用户的父pom和BOM（<code i="235">spring-cloud-starter-parent</code>）和用于Gradle和Spring CLI用户的Spring IO版本管理属性文件。</font><font o="517">示例Maven配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="518">的pom.xml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">   &lt;parent&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
       &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
       &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
       &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
   &lt;/parent&gt;

&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;Brixton.RELEASE&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
	&lt;plugins&gt;
           &lt;plugin&gt;
               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
           &lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;

   &lt;!-- repositories also needed for snapshots and milestones --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="519">那么你可以创建一个标准的Spring Boot应用程序，像这个简单的HTTP服务器：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="520">当它运行它将从端口8888上的默认本地配置服务器接收外部配置，如果它正在运行。</font><font o="521">要修改启动行为，您可以使用<code i="236">bootstrap.properties</code>（如<code i="237">application.properties</code>）更改配置服务器的位置，但用于应用程序上下文的引导阶段），例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.config.uri: http://myconfigserver.com</pre>
</div>
</div>
<div class="paragraph">
<p><font o="522">引导属性将在<code i="238">/env</code>端点中显示为高优先级属性源，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ curl localhost:8080/env
{
  "profiles":[],
  "configService:https://github.com/spring-cloud-samples/config-repo/bar.properties":{"foo":"bar"},
  "servletContextInitParams":{},
  "systemProperties":{...},
  ...
}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="523">（名为“configService：&lt;远程存储库的URL&gt; / &lt;文件名&gt;”的属性源包含值为“bar”的属性“foo”，是最高优先级）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="524">注意</font></div>
</td>
<td class="content"><font o="525">
属性源名称中的URL是git存储库，而不是配置服务器URL。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_config_server"><font o="526">Spring Cloud Config服务器</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="527">服务器为外部配置（名称值对或等效的YAML内容）提供了基于资源的HTTP。</font><font o="528">服务器可以使用<code i="239">@EnableConfigServer</code>注释轻松嵌入到Spring Boot应用程序中。</font><font o="529">所以这个应用程序是一个配置服务器：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="530">ConfigServer.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableConfigServer
public class ConfigServer {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServer.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="531">像所有的默认端口8080上运行的所有Spring Boot应用程序一样，但您可以通过各种方式将其切换到常规端口8888。</font><font o="532">最简单的也是设置一个默认配置库，它是通过启动它的<code i="240">spring.config.name=configserver</code>（在Config Server jar中有一个<code i="241">configserver.yml</code>）。</font><font o="533">另一个是使用你自己的<code i="242">application.properties</code>，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="534">application.properties</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-properties" data-lang="properties">server.port: 8888
spring.cloud.config.server.git.uri: file://${user.home}/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="535">其中<code i="243">${user.home}/config-repo</code>是包含YAML和属性文件的git仓库。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="536">注意</font></div>
</td>
<td class="content"><font o="537">
在Windows中，如果文件URL为绝对驱动器前缀，例如<code i="244"><a href="file:///$%7Buser.home%7D/config-repo" class="bare">file:///${user.home}/config-repo</a></code>，则需要额外的“/”。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="538">提示</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="539">以下是上面示例中创建git仓库的方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ echo info.foo: bar &gt; application.properties
$ git add -A .
$ git commit -m "Add application.properties"</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="540">警告</font></div>
</td>
<td class="content"><font o="541">
使用本地文件系统进行git存储库仅用于测试。</font><font o="542">使用服务器在生产环境中托管配置库。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="543">警告</font></div>
</td>
<td class="content"><font o="544">
如果您只保留文本文件，则配置库的初始克隆将会快速有效。</font><font o="545">如果您开始存储二进制文件，尤其是较大的文件，则可能会遇到服务器中第一个配置请求和/或内存不足错误的延迟。
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="_environment_repository"><font o="546">环境库</font></h3>
<div class="paragraph">
<p><font o="547">您要在哪里存储配置服务器的配置数据？</font><font o="548">管理此行为的策略是<code i="245">EnvironmentRepository</code>，服务于<code i="246">Environment</code>对象。</font><font o="549">此<code i="247">Environment</code>是Spring <code i="248">Environment</code>（包括<code i="249">propertySources</code>作为主要功能）的域的浅层副本。</font><font o="550"><code i="250">Environment</code>资源由三个变量参数化：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="551"><code i="251">{application}</code>映射到客户端的“spring.application.name”;</font></p>
</li>
<li>
<p><font o="552"><code i="252">{profile}</code>映射到客户端上的“spring.profiles.active”（逗号分隔列表）; </font><font o="553">和</font></p>
</li>
<li>
<p><font o="554"><code i="253">{label}</code>这是一个服务器端功能，标记“版本”的配置文件集。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="555">存储库实现通常表现得像一个Spring Boot应用程序从“spring.config.name”等于<code i="254">{application}</code>参数加载配置文件，“spring.profiles.active”等于<code i="255">{profiles}</code>参数。</font><font o="556">配置文件的优先级规则也与常规启动应用程序相同：活动配置文件优先于默认配置，如果有多个配置文件，则最后一个获胜（例如向<code i="256">Map</code>添加条目）。</font></p>
</div>
<div class="paragraph">
<p><font o="557">示例：客户端应用程序具有此引导配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="558">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  application:
    name: foo
  profiles:
    active: dev,mysql</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="559">（通常使用Spring Boot应用程序，这些属性也可以设置为环境变量或命令行参数）。</font></p>
</div>
<div class="paragraph">
<p><font o="560">如果存储库是基于文件的，则服务器将从<code i="258">application.yml</code>创建<code i="257">Environment</code>（在所有客户端之间共享），<code i="259">foo.yml</code>（以<code i="260">foo.yml</code>优先））。</font><font o="561">如果YAML文件中有文件指向Spring配置文件，那么应用的优先级更高（按照列出的配置文件的顺序），并且如果存在特定于配置文件的YAML（或属性）文件，那么这些文件也应用于优先级高于默认值。</font><font o="562">较高优先级转换为<code i="262">Environment</code>之前列出的<code i="261">PropertySource</code>。</font><font o="563">（这些规则与独立的Spring Boot应用程序相同。）</font></p>
</div>
<div class="sect3">
<h4 id="_git_backend"><font o="564">Git后端</font></h4>
<div class="paragraph">
<p><font o="565"><code i="263">EnvironmentRepository</code>的默认实现使用Git后端，这对于管理升级和物理环境以及审核更改非常方便。</font><font o="566">要更改存储库的位置，可以在Config Server中设置“spring.cloud.config.server.git.uri”配置属性（例如<code i="264">application.yml</code>）。</font><font o="567">如果您使用<code i="265">file:</code>前缀进行设置，则应从本地存储库中工作，以便在没有服务器的情况下快速方便地启动，但在这种情况下，服务器将直接在本地存储库上进行操作，而不会克隆如果它不是裸机，因为配置服务器永远不会更改“远程”资源库）。</font><font o="568">要扩展Config Server并使其高度可用，您需要将服务器的所有实例指向同一个存储库，因此只有共享文件系统才能正常工作。</font><font o="569">即使在这种情况下，最好使用共享文件系统存储库的<code i="266">ssh:</code>协议，以便服务器可以将其克隆并使用本地工作副本作为缓存。</font></p>
</div>
<div class="paragraph">
<p><font o="570">该存储库实现将HTTP资源的<code i="267">{label}</code>参数映射到git标签（提交ID，分支名称或标签）。</font><font o="571">如果git分支或标签名称包含斜杠（“/”），则应使用特殊字符串“（_）”指定HTTP URL中的标签，以避免与其他URL路径模糊。</font><font o="572">例如，如果标签为<code i="268">foo/bar</code>，则替换斜杠将导致标签看起来像<code i="269">foo(_)bar</code>。</font><font o="573">如果您使用像curl这样的命令行客户端（例如使用引号将其从shell中转出来），请小心URL中的方括号。</font></p>
</div>
<div class="sect4">
<h5 id="_placeholders_in_git_uri"><font o="574">Git URI中的占位符</font></h5>
<div class="paragraph">
<p><font o="575">Spring Cloud Config服务器支持一个Git仓库URL，其中包含<code i="270">{application}</code>和<code i="271">{profile}</code>（以及<code i="272">{label}</code>）的占位符，如果需要，请记住标签应用为git标签）。</font><font o="576">因此，您可以使用（例如）轻松支持“每个应用程序的一个repo”策略：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/{application}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="577">或使用类似模式但使用<code i="273">{profile}</code>的“每个配置文件一个”策略。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_pattern_matching_and_multiple_repositories"><font o="578">模式匹配和多个存储库</font></h5>
<div class="paragraph">
<p><font o="579">还可以通过应用程序和配置文件名称的模式匹配来支持更复杂的需求。</font><font o="580">模式格式是带有通配符的<code i="274">{application}/{profile}</code>名称的逗号分隔列表（可能需要引用以通配符开头的模式）。</font><font o="581">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            simple: https://github.com/simple/config-repo
            special:
              pattern: special*/dev*,*special*/dev*
              uri: https://github.com/special/config-repo
            local:
              pattern: local*
              uri: file:/home/configsvc/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="582">如果<code i="275">{application}/{profile}</code>不匹配任何模式，它将使用在“spring.cloud.config.server.git.uri”下定义的默认uri。</font><font o="583">在上面的例子中，对于“简单”存储库，模式是<code i="276">simple/*</code>（即所有配置文件中只匹配一个名为“简单”的应用程序）。</font><font o="584">“本地”存储库与所有配置文件中以“local”开头的所有应用程序名称匹配（将<code i="277">/*</code>后缀自动添加到任何没有配置文件匹配器的模式）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="585">注意</font></div>
</td>
<td class="content"><font o="586">
在上述“简单”示例中使用的“单行”快捷方式只能在唯一要设置的属性为URI的情况下使用。</font><font o="587">如果您需要设置其他任何内容（凭据，模式等），则需要使用完整的表单。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="588">repo中的<code i="278">pattern</code>属性实际上是一个数组，因此您可以使用属性文件中的YAML数组（或<code i="279">[0]</code>，<code i="280">[1]</code>等后缀）绑定到多个模式。</font><font o="589">如果要运行具有多个配置文件的应用程序，则可能需要执行此操作。</font><font o="590">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            development:
              pattern:
                - */development
                - */staging
              uri: https://github.com/development/config-repo
            staging:
              pattern:
                - */qa
                - */production
              uri: https://github.com/staging/config-repo</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="591">注意</font></div>
</td>
<td class="content"><font o="592">
Spring Cloud将猜测包含不在<code i="281">*</code>中的配置文件的模式意味着您实际上要匹配从此模式开始的配置文件列表（因此<code i="282">*/staging</code>是<code i="283">["*/staging", "*/staging,*"]</code>）。</font><font o="593">这是常见的，您需要在本地的“开发”配置文件中运行应用程序，但也可以远程运行“云”配置文件。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="594">每个存储库还可以选择将配置文件存储在子目录中，搜索这些目录的模式可以指定为<code i="284">searchPaths</code>。</font><font o="595">例如在顶层：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: foo,bar*</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="596">在此示例中，服务器搜索顶级和“foo /”子目录以及名称以“bar”开头的任何子目录中的配置文件。</font></p>
</div>
<div class="paragraph">
<p><font o="597">默认情况下，首次请求配置时，服务器克隆远程存储库。</font><font o="598">服务器可以配置为在启动时克隆存储库。</font><font o="599">例如在顶层：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          repos:
            team-a:
                pattern: team-a-*
                cloneOnStart: true
                uri: http://git/team-a/config-repo.git
            team-b:
                pattern: team-b-*
                cloneOnStart: false
                uri: http://git/team-b/config-repo.git
            team-c:
                pattern: team-c-*
                uri: http://git/team-a/config-repo.git</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="600">在此示例中，服务器在启动之前克隆了team-a的config-repo，然后它接受任何请求。</font><font o="601">所有其他存储库将不被克隆，直到请求从存储库配置。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="602">注意</font></div>
</td>
<td class="content"><font o="603">
在配置服务器启动时设置要克隆的存储库可以帮助在配置服务器启动时快速识别错误配置的源（例如，无效的存储库URI）。</font><font o="604">配置源不启用<code i="285">cloneOnStart</code>时，配置服务器可能会成功启动配置错误或无效的配置源，而不会检测到错误，直到应用程序从该配置源请求配置为止。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_authentication"><font o="605">认证</font></h5>
<div class="paragraph">
<p><font o="606">要在远程存储库上使用HTTP基本身份验证，请分别添加“username”和“password”属性（不在URL中），例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          username: trolley
          password: strongpassword</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="607">如果您不使用HTTPS和用户凭据，当您将密钥存储在默认目录（<code i="286">~/.ssh</code>）中，并且uri指向SSH位置时，SSH也应该开箱即用，例如“ </font><a href="mailto:git@github.com"><font o="607">git@github.com</font></a><font o="607">：配置/云配置”。</font><font o="608">必须在<code i="287">~/.ssh/known_hosts</code>文件中存在Git服务器的条目，并且它是<code i="288">ssh-rsa</code>格式。</font><font o="609">其他格式（如<code i="289">ecdsa-sha2-nistp256</code>）不受支持。</font><font o="610">为了避免意外，您应该确保Git服务器的<code i="290">known_hosts</code>文件中只有一个条目，并且与您提供给配置服务器的URL匹配。</font><font o="611">如果您在URL中使用了主机名，那么您希望在<code i="291">known_hosts</code>文件中具有这一点，而不是IP。</font><font o="612">使用JGit访问存储库，因此您发现的任何文档都应适用。</font><font o="613">HTTPS代理设置可以<code i="292">~/.git/config</code>设置，也可以通过系统属性（<code i="293">-Dhttps.proxyHost</code>和<code i="294">-Dhttps.proxyPort</code>）与任何其他JVM进程相同。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="614">提示</font></div>
</td>
<td class="content"><font o="615">
如果您不知道<code i="295">~/.git</code>目录使用<code i="296">git config
--global</code>来处理设置的位置（例如<code i="297">git config --global
http.sslVerify false</code>）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_authentication_with_aws_codecommit"><font o="616">使用AWS CodeCommit进行认证</font></h5>
<div class="paragraph">
<p><a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html"><font o="617">AWS CodeCommit</font></a><font o="617">认证也可以完成。</font><font o="618">当从命令行使用Git时，AWS CodeCommit使用身份验证助手。</font><font o="619">该帮助器不与JGit库一起使用，因此如果Git URI与AWS CodeCommit模式匹配，则将创建用于AWS CodeCommit的JGit CredentialProvider。</font><font o="620">AWS CodeCommit URI始终看起来像
 </font><a href="https://git-codecommit.%24%7Baws_region%7D.amazonaws.com/$%7Brepopath%7D" class="bare"><font o="620">https：//git-codecommit.$ {AWS_REGION} .amazonaws.com / $ {repopath}</font></a><font o="620">。</font></p>
</div>
<div class="paragraph">
<p><font o="621">如果您使用AWS CodeCommit URI提供用户名和密码，那么这些URI必须</font><font o="621">
是用于访问存储库</font><font o="621">的</font><a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html"><font o="621">AWS accessKeyId和</font></a><font o="621"> secretAccessKey。</font><font o="622">如果不指定用户名和密码，则将使用</font><a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html"><font o="622">AWS默认凭据提供程序链</font></a><font o="622">检索accessKeyId和secretAccessKey
 </font><font o="622">。</font></p>
</div>
<div class="paragraph">
<p><font o="623">如果您的Git URI与CodeCommit URI模式（上述）匹配，则必须在用户名和密码或默认凭据提供程序链支持的某个位置中提供有效的AWS凭据。</font><font o="624">AWS EC2实例可以使用EC2实例的
 </font><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html"><font o="624">IAM角色</font></a><font o="624">。</font></p>
</div>
<div class="paragraph">
<p><font o="625">注意：aws-java-sdk-core jar是一个可选的依赖关系。</font><font o="626">如果aws-java-sdk-core jar不在您的类路径上，则无论git服务器URI如何，都将不会创建AWS代码提交凭据提供程序。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_placeholders_in_git_search_paths"><font o="627">Git搜索路径中的占位符</font></h5>
<div class="paragraph">
<p><font o="628">Spring Cloud Config服务器还支持具有<code i="298">{application}</code>和<code i="299">{profile}</code>（以及<code i="300">{label}</code>（如果需要））占位符的搜索路径。</font><font o="629">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: '{application}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="630">在资源库中搜索与目录（以及顶级）相同名称的文件。</font><font o="631">通配符在具有占位符的搜索路径中也是有效的（搜索中包含任何匹配的目录）。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_force_pull_in_git_repositories"><font o="632">力拉入Git存储库</font></h5>
<div class="paragraph">
<p><font o="633">如前所述Spring Cloud Config服务器克隆远程git存储库，如果某种方式本地副本变脏（例如，通过操作系统进程更改文件夹内容），则Spring Cloud Config服务器无法从远程存储库更新本地副本。</font></p>
</div>
<div class="paragraph">
<p><font o="634">要解决这个问题，有一个<code i="301">force-pull</code>属性，如果本地副本是脏的，将使Spring Cloud Config Server强制从远程存储库拉。</font><font o="635">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          force-pull: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="636">如果您有多个存储库配置，则可以为每个存储库配置<code i="302">force-pull</code>属性。</font><font o="637">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          force-pull: true
          repos:
            team-a:
                pattern: team-a-*
                uri: http://git/team-a/config-repo.git
                force-pull: true
            team-b:
                pattern: team-b-*
                uri: http://git/team-b/config-repo.git
                force-pull: true
            team-c:
                pattern: team-c-*
                uri: http://git/team-a/config-repo.git</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="638">注意</font></div>
</td>
<td class="content"><font o="639">
<code i="303">force-pull</code>属性的默认值为<code i="304">false</code>。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_version_control_backend_filesystem_use"><font o="640">版本控制后端文件系统使用</font></h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="641">警告</font></div>
</td>
<td class="content"><font o="642">
使用基于VCS的后端（git，svn）文件被检出或克隆到本地文件系统。</font><font o="643">默认情况下，它们放在系统临时目录中，前缀为<code i="305">config-repo-</code>。</font><font o="644">在linux上，例如可以是<code i="306">/tmp/config-repo-&lt;randomid&gt;</code>。</font><font o="645">一些操作系统会</font><a href="https://serverfault.com/questions/377348/when-does-tmp-get-cleared/377349#377349"><font o="645">定期清除</font></a><font o="645">临时目录。</font><font o="646">这可能会导致意外的行为，例如缺少属性。</font><font o="647">为避免此问题，请通过将<code i="307">spring.cloud.config.server.git.basedir</code>或<code i="308">spring.cloud.config.server.svn.basedir</code>设置为不驻留在系统临时结构中的目录来更改Config Server使用的目录。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_file_system_backend"><font o="648">文件系统后端</font></h4>
<div class="paragraph">
<p><font o="649">配置服务器中还有一个不使用Git的“本机”配置文件，只是从本地类路径或文件系统加载配置文件（您想要指向的任何静态URL“spring.cloud.config.server .native.searchLocations“）。</font><font o="650">要使用本机配置文件，只需使用“spring.profiles.active = native”启动Config Server。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="651">注意</font></div>
</td>
<td class="content"><font o="652">
请记住使用<code i="309">file:</code>前缀的文件资源（缺省没有前缀通常是classpath）。</font><font o="653">与任何Spring Boot配置一样，您可以嵌入<code i="310">${}</code>样式的环境占位符，但请记住，Windows中的绝对路径需要额外的“/”，例如<code i="311"><a href="file:///$%7Buser.home%7D/config-repo" class="bare">file:///${user.home}/config-repo</a></code>
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="654">警告</font></div>
</td>
<td class="content"><font o="655">
<code i="312">searchLocations</code>的默认值与本地Spring Boot应用程序（所以<code i="313">[classpath:/, classpath:/config,
file:./, file:./config]</code>）相同。</font><font o="656">这不会将<code i="314">application.properties</code>从服务器暴露给所有客户端，因为在发送到客户端之前，服务器中存在的任何属性源都将被删除。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="657">提示</font></div>
</td>
<td class="content"><font o="658">
文件系统后端对于快速入门和测试是非常好的。</font><font o="659">要在生产中使用它，您需要确保文件系统是可靠的，并在配置服务器的所有实例中共享。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="660">搜索位置可以包含<code i="315">{application}</code>，<code i="316">{profile}</code>和<code i="317">{label}</code>的占位符。</font><font o="661">以这种方式，您可以隔离路径中的目录，并选择一个有用的策略（例如每个应用程序的子目录或每个配置文件的子目录）。</font></p>
</div>
<div class="paragraph">
<p><font o="662">如果您不在搜索位置使用占位符，则该存储库还将HTTP资源的<code i="318">{label}</code>参数附加到搜索路径上的后缀，因此属性文件将从每个搜索位置加载</font><strong><font o="662">并</font></strong><font o="662">具有相同名称的子目录作为标签（标记的属性在Spring环境中优先）。</font><font o="663">因此，没有占位符的默认行为与添加以<code i="319">/{label}/. For example `file:/tmp/config</code>结尾的搜索位置与<code i="320">file:/tmp/config,file:/tmp/config/{label}</code>相同</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_vault_backend"><font o="664">Vault后端</font></h4>
<div class="paragraph">
<p><font o="665">Spring Cloud Config服务器还支持</font><a href="https://www.vaultproject.io/"><font o="665">Vault</font></a><font o="665">作为后端。</font></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><font o="666">Vault是安全访问秘密的工具。</font><font o="667">一个秘密是你想要严格控制访问的任何东西，如API密钥，密码，证书等等。</font><font o="668">Vault为任何秘密提供统一的界面，同时提供严格的访问控制和记录详细的审核日志。</font></p>
</div>
</div>
</div>
<div class="paragraph">
<p><font o="669">有关Vault的更多信息，请参阅</font><a href="https://www.vaultproject.io/intro/index.html"><font o="669">Vault快速入门指南</font></a><font o="669">。</font></p>
</div>
<div class="paragraph">
<p><font o="670">要使配置服务器使用Vault后端，您必须使用<code i="321">vault</code>配置文件运行配置服务器。</font><font o="671">例如在配置服务器的<code i="322">application.properties</code>中，您可以添加<code i="323">spring.profiles.active=vault</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="672">默认情况下，配置服务器将假定您的Vault服务器正在运行于<code i="324"><a href="http://127.0.0.1:8200/" class="bare">http://127.0.0.1:8200</a></code>。</font><font o="673">它还将假定后端名称为<code i="325">secret</code>，密钥为<code i="326">application</code>。</font><font o="674">所有这些默认值都可以在配置服务器的<code i="327">application.properties</code>中配置。</font><font o="675">以下是可配置Vault属性的表。</font><font o="676">所有属性前缀为<code i="328">spring.cloud.config.server.vault</code>。</font></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><font o="677">名称</font></th>
<th class="tableblock halign-left valign-top"><font o="678">默认值</font></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8200</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="681">HTTP</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="682">秘密</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">defaultKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="683">应用</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">profileSeparator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">,</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><font o="685">所有可配置的属性可以在<code i="329">org.springframework.cloud.config.server.environment.VaultEnvironmentRepository</code>找到。</font></p>
</div>
<div class="paragraph">
<p><font o="686">运行配置服务器后，可以向服务器发出HTTP请求，以从Vault后端检索值。</font><font o="687">为此，您需要为Vault服务器创建一个令牌。</font></p>
</div>
<div class="paragraph">
<p><font o="688">首先放置一些数据给你Vault。</font><font o="689">例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-sh" data-lang="sh">$ vault write secret/application foo=bar baz=bam
$ vault write secret/myapp foo=myappsbar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="690">现在，将HTTP请求发送给您的配置服务器以检索值。</font></p>
</div>
<div class="paragraph">
<p><code>$ curl -X "GET" "http://localhost:8888/myapp/default" -H "X-Config-Token: yourtoken"</code></p>
</div>
<div class="paragraph">
<p><font o="691">在提出上述要求后，您应该会看到类似的回复。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
   "name":"myapp",
   "profiles":[
      "default"
   ],
   "label":null,
   "version":null,
   "state":null,
   "propertySources":[
      {
         "name":"vault:myapp",
         "source":{
            "foo":"myappsbar"
         }
      },
      {
         "name":"vault:application",
         "source":{
            "baz":"bam",
            "foo":"bar"
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_multiple_properties_sources"><font o="692">多个Properties来源</font></h5>
<div class="paragraph">
<p><font o="693">使用Vault时，您可以为应用程序提供多个属性源。</font><font o="694">例如，假设您已将数据写入Vault中的以下路径。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-sh" data-lang="sh">secret/myApp,dev
secret/myApp
secret/application,dev
secret/application</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="695">写入<code i="330">secret/application</code>的Properties可
 </font><a href="https://springcloud.cc/spring-cloud-dalston.html#_vault_server"><font o="695">用于使用配置服务器的所有应用程序</font></a><font o="695">。</font><font o="696">名称为<code i="331">myApp</code>的应用程序将具有写入<code i="332">secret/myApp</code>和<code i="333">secret/application</code>的任何属性。</font><font o="697">当<code i="334">myApp</code>启用<code i="335">dev</code>配置文件时，写入所有上述路径的属性将可用，列表中第一个路径中的属性优先于其他路径。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sharing_configuration_with_all_applications"><font o="698">与所有应用共享配置</font></h4>
<div class="sect4">
<h5 id="_file_based_repositories"><font o="699">基于文件的存储库</font></h5>
<div class="paragraph">
<p><font o="700">使用基于文件（即git，svn和native）的存储库，文件名为<code i="336">application*</code>的资源在所有客户端应用程序（所以<code i="337">application.properties</code>，<code i="338">application.yml</code>，<code i="339">application-*.properties</code>等）之间共享）。</font><font o="701">您可以使用这些文件名的资源来配置全局默认值，并根据需要将其覆盖应用程序特定的文件。</font></p>
</div>
<div class="paragraph">
<p><font o="702">#_property_overrides [属性覆盖]功能也可用于设置全局默认值，并且允许占位符应用程序在本地覆盖它们。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="703">提示</font></div>
</td>
<td class="content"><font o="704">
使用“本机”配置文件（本地文件系统后端），建议您使用不属于服务器自身配置的显式搜索位置。</font><font o="705">否则，默认搜索位置中的<code i="340">application*</code>资源将被删除，因为它们是服务器的一部分。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_vault_server"><font o="706">Vault服务器</font></h5>
<div class="paragraph">
<p><font o="707">当使用Vault作为后端时，可以通过将配置放在<code i="341">secret/application</code>中与所有应用程序共享配置。</font><font o="708">例如，如果您运行此Vault命令</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-sh" data-lang="sh">$ vault write secret/application foo=bar baz=bam</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="709">使用配置服务器的所有应用程序都可以使用属性<code i="342">foo</code>和<code i="343">baz</code>。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_composite_environment_repositories"><font o="710">复合环境库</font></h4>
<div class="paragraph">
<p><font o="711">在某些情况下，您可能希望从多个环境存储库中提取配置数据。</font><font o="712">为此，只需在配置服务器的应用程序属性或YAML文件中启用多个配置文件即可。</font><font o="713">例如，如果您要从Git存储库以及SVN存储库中提取配置数据，那么您将为配置服务器设置以下属性。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  profiles:
    active: git, svn
  cloud:
    config:
      server:
        svn:
          uri: file:///path/to/svn/repo
          order: 2
        git:
          uri: file:///path/to/git/repo
          order: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="714">除了指定URI的每个repo之外，还可以指定<code i="344">order</code>属性。</font><font o="715"><code i="345">order</code>属性允许您指定所有存储库的优先级顺序。</font><font o="716"><code i="346">order</code>属性的数值越低，优先级越高。</font><font o="717">存储库的优先顺序将有助于解决包含相同属性的值的存储库之间的任何潜在冲突。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="718">注意</font></div>
</td>
<td class="content"><font o="719">
从环境仓库检索值时的任何类型的故障将导致整个复合环境的故障。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="720">注意</font></div>
</td>
<td class="content"><font o="721">
当使用复合环境时，重要的是所有repos都包含相同的标签。</font><font o="722">如果您有类似于上述的环境，并且使用标签<code i="347">master</code>请求配置数据，但是SVN repo不包含称为<code i="348">master</code>的分支，则整个请求将失败。
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_custom_composite_environment_repositories"><font o="723">自定义复合环境库</font></h5>
<div class="paragraph">
<p><font o="724">除了使用来自Spring Cloud的环境存储库之外，还可以提供自己的<code i="349">EnvironmentRepository</code> bean作为复合环境的一部分。</font><font o="725">要做到这一点，你的bean必须实现<code i="350">EnvironmentRepository</code>接口。</font><font o="726">如果要在复合环境中控制自定义<code i="351">EnvironmentRepository</code>的优先级，您还应该实现<code i="352">Ordered</code>接口并覆盖<code i="353">getOrdered</code>方法。</font><font o="727">如果您不实现<code i="354">Ordered</code>接口，那么您的<code i="355">EnvironmentRepository</code>将被赋予最低优先级。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_property_overrides"><font o="728">属性覆盖</font></h4>
<div class="paragraph">
<p><font o="729">配置服务器具有“覆盖”功能，允许操作员为应用程序使用普通的Spring Boot钩子不会意外更改的所有应用程序提供配置属性。</font><font o="730">要声明覆盖，只需将名称/值对的地图添加到<code i="356">spring.cloud.config.server.overrides</code>。</font><font o="731">例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        overrides:
          foo: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="732">将导致配置客户端的所有应用程序独立于自己的配置读取<code i="357">foo=bar</code>。</font><font o="733">（当然，应用程序可以以任何方式使用Config Server中的数据，因此覆盖不可强制执行，但如果它们是Spring Cloud Config客户端，则它们确实提供有用的默认行为。）</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="734">提示</font></div>
</td>
<td class="content"><font o="735">
通过使用反斜杠（“\”）来转义“$”或“{”，例如<code i="358">\${app.foo:bar}</code>解析，可以转义正常的Spring具有“$ {}”的环境占位符到“bar”，除非应用程序提供自己的“app.foo”。</font><font o="736">请注意，在YAML中，您不需要转义反斜杠本身，而是在您执行的属性文件中配置服务器上的覆盖。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="737">您可以通过在远程存储库中设置标志<code i="359">spring.cloud.config.overrideNone=true</code>（默认为false），将客户端中所有覆盖的优先级更改为更为默认值，允许应用程序在环境变量或系统属性中提供自己的值。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_health_indicator"><font o="738">健康指标</font></h3>
<div class="paragraph">
<p><font o="739">配置服务器附带运行状况指示器，检查配置的<code i="360">EnvironmentRepository</code>是否正常工作。</font><font o="740">默认情况下，它要求<code i="361">EnvironmentRepository</code>应用程序名称为<code i="362">app</code>，<code i="363">default</code>配置文件和<code i="364">EnvironmentRepository</code>实现提供的默认标签。</font></p>
</div>
<div class="paragraph">
<p><font o="741">您可以配置运行状况指示器以检查更多应用程序以及自定义配置文件和自定义标签，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      server:
        health:
          repositories:
            myservice:
              label: mylabel
            myservice-dev:
              name: myservice
              profiles: development</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="742">您可以通过设置<code i="365">spring.cloud.config.server.health.enabled=false</code>来禁用运行状况指示器。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_security"><font o="743">安全</font></h3>
<div class="paragraph">
<p><font o="744">您可以以任何对您有意义的方式（从物理网络安全性到OAuth2承载令牌）保护您的Config Server，并且Spring Security和Spring Boot可以轻松做任何事情。</font></p>
</div>
<div class="paragraph">
<p><font o="745">要使用默认的Spring Boot配置的HTTP Basic安全性，只需在类路径中包含Spring Security（例如通过<code i="366">spring-boot-starter-security</code>）。</font><font o="746">默认值为“user”的用户名和随机生成的密码，这在实践中不会非常有用，因此建议您配置密码（通过<code i="367">security.user.password</code>）并对其进行加密（请参阅下文的说明怎么做）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_encryption_and_decryption_2"><font o="747">加密和解密</font></h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="748">重要</font></div>
</td>
<td class="content">
<strong><font o="749">先决条件：</font></strong><font o="749">要使用加密和解密功能，您需要在JVM中安装全面的JCE（默认情况下不存在）。</font><font o="750">您可以从Oracle下载“Java加密扩展（JCE）无限强度管理策略文件”，并按照安装说明（实际上将JRE lib / security目录中的2个策略文件替换为您下载的文件）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="751">如果远程属性源包含加密内容（以<code i="368">{cipher}</code>开头的值），则在通过HTTP发送到客户端之前，它们将被解密。</font><font o="752">这种设置的主要优点是，当它们“静止”时，属性值不必是纯文本（例如在git仓库中）。</font><font o="753">如果值无法解密，则从属性源中删除该值，并添加具有相同键的附加属性，但以“无效”作为前缀。</font><font o="754">和“不适用”的值（通常为“&lt;n / a&gt;”）。</font><font o="755">这主要是为了防止密码被用作密码并意外泄漏。</font></p>
</div>
<div class="paragraph">
<p><font o="756">如果要为config客户端应用程序设置远程配置存储库，可能会包含一个<code i="369">application.yml</code>，例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="757">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  datasource:
    username: dbuser
    password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="758">.properties文件中的加密值不能用引号括起来，否则不会解密该值：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="759">application.properties</font></div>
<div class="content">
<pre class="notranslate">spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ</pre>
</div>
</div>
<div class="paragraph">
<p><font o="760">您可以安全地将此纯文本推送到共享git存储库，并且保密密码。</font></p>
</div>
<div class="paragraph">
<p><font o="761">服务器还暴露了<code i="370">/encrypt</code>和<code i="371">/decrypt</code>端点（假设这些端点将被保护，并且只能由授权代理访问）。</font><font o="762">如果您正在编辑远程配置文件，可以使用Config Server通过POST到<code i="372">/encrypt</code>端点来加密值，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ curl localhost:8888/encrypt -d mysecret
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="763">注意</font></div>
</td>
<td class="content"><font o="764">
如果要加密的值具有需要进行URL编码的字符，则应使用<code i="373">--data-urlencode</code>选项<code i="374">curl</code>来确保它们已正确编码。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="765">逆向操作也可通过<code i="375">/decrypt</code>获得（如果服务器配置了对称密钥或全密钥对）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ curl localhost:8888/decrypt -d 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="766">提示</font></div>
</td>
<td class="content"><font o="767">
如果您使用curl进行测试，则使用<code i="376">--data-urlencode</code>（而不是<code i="377">-d</code>）或设置显式<code i="378">Content-Type:
text/plain</code>，以确保在有特殊字符时正确地对数据进行编码（'+'特别是棘手）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="768">将加密的值添加到<code i="379">{cipher}</code>前缀，然后再将其放入YAML或属性文件中，然后再提交并将其推送到远程可能不安全的存储区。</font></p>
</div>
<div class="paragraph">
<p><font o="769"><code i="380">/encrypt</code>和<code i="381">/decrypt</code>端点也都接受<code i="382">/*/{name}/{profiles}</code>形式的路径，当客户端调用到主环境资源时，可以用于每个应用程序（名称）和配置文件控制密码。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="770">注意</font></div>
</td>
<td class="content"><font o="771">
为了以这种细微的方式控制密码，您还必须提供一种<code i="384">TextEncryptorLocator</code>类型的<code i="383">@Bean</code>，可以为每个名称和配置文件创建不同的加密器。</font><font o="772">默认提供的不会这样做（所有加密使用相同的密钥）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="773"><code i="385">spring</code>命令行客户端（安装了Spring Cloud CLI扩展）也可以用于加密和解密，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>
</div>
</div>
<div class="paragraph">
<p><font o="774">要在文件中使用密钥（例如用于加密的RSA公钥），使用“@”键入键值，并提供文件路径，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre>
</div>
</div>
<div class="paragraph">
<p><font o="775">关键参数是强制性的（尽管有一个<code i="386">--</code>前缀）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_key_management"><font o="776">密钥管理</font></h3>
<div class="paragraph">
<p><font o="777">Config Server可以使用对称（共享）密钥或非对称密钥（RSA密钥对）。</font><font o="778">非对称选择在安全性方面是优越的，但是使用对称密钥往往更方便，因为它只是配置的一个属性值。</font></p>
</div>
<div class="paragraph">
<p><font o="779">要配置对称密钥，您只需要将<code i="387">encrypt.key</code>设置为一个秘密字符串（或使用环境变量<code i="388">ENCRYPT_KEY</code>将其从纯文本配置文件中删除）。</font></p>
</div>
<div class="paragraph">
<p><font o="780">要配置非对称密钥，您可以将密钥设置为PEM编码的文本值（<code i="389">encrypt.key</code>），也可以通过密钥库设置密钥（例如由JDK附带的<code i="390">keytool</code>实用程序创建）。</font><font o="781">密钥库属性为<code i="391">encrypt.keyStore.*</code>，<code i="392">*</code>等于</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="782"><code i="393">location</code>（a <code i="394">Resource</code>位置），</font></p>
</li>
<li>
<p><font o="783"><code i="395">password</code>（解锁密钥库）和</font></p>
</li>
<li>
<p><font o="784"><code i="396">alias</code>（以识别商店中使用的密钥）。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="785">使用公钥进行加密，需要私钥进行解密。</font><font o="786">因此，原则上您只能在服务器中配置公钥，如果您只想进行加密（并准备使用私钥本地解密值）。</font><font o="787">实际上，您可能不想这样做，因为它围绕所有客户端传播密钥管理流程，而不是将其集中在服务器中。</font><font o="788">另一方面，如果您的配置服务器真的相对不安全，并且只有少数客户端需要加密的属性，这是一个有用的选项。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_key_store_for_testing"><font o="789">创建用于测试的密钥库</font></h3>
<div class="paragraph">
<p><font o="790">要创建一个密钥库进行测试，您可以执行以下操作：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ keytool -genkeypair -alias mytestkey -keyalg RSA \
  -dname "CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeme -keystore server.jks -storepass letmein</pre>
</div>
</div>
<div class="paragraph">
<p><font o="791">将<code i="397">server.jks</code>文件放在类路径（例如）中，然后在您的<code i="398">application.yml</code>中配置服务器：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">encrypt:
  keyStore:
    location: classpath:/server.jks
    password: letmein
    alias: mytestkey
    secret: changeme</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_multiple_keys_and_key_rotation"><font o="792">使用多个键和键旋转</font></h3>
<div class="paragraph">
<p><font o="793">除了加密属性值中的<code i="399">{cipher}</code>前缀之外，配置服务器在（Base64编码）密文开始前查找<code i="400">{name:value}</code>前缀（零或多个）。</font><font o="794">密钥被传递给<code i="401">TextEncryptorLocator</code>，它可以执行找到密码的<code i="402">TextEncryptor</code>所需的任何逻辑。</font><font o="795">如果配置了密钥库（<code i="403">encrypt.keystore.location</code>），默认定位器将使用“key”前缀提供的别名，即使用如下密码查找存储中的密钥：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">foo:
  bar: `{cipher}{key:testkey}...`</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="796">定位器将寻找一个名为“testkey”的键。</font><font o="797">也可以通过前缀中的<code i="404">{secret:…​}</code>值提供一个秘密，但是如果不是默认值，则使用密钥库密码（这是您在构建密钥库时获得的，并且不指定密码）。</font><font o="798">如果你</font><strong><font o="798">这样做</font></strong><font o="798"> 
提供一个秘密建议你也加密使用自定义<code i="405">SecretLocator</code>的秘密。</font></p>
</div>
<div class="paragraph">
<p><font o="799">如果密钥只用于加密几个字节的配置数据（即它们没有在其他地方使用），则密码转换几乎不是必需的，但是如果存在安全漏洞，有时您可能需要更改密钥实例。</font><font o="800">在这种情况下，所有客户端都需要更改其源配置文件（例如，以git格式），并在所有密码中使用新的<code i="406">{key:…​}</code>前缀，当然事先检查密钥别名在配置服务器密钥库中是否可用。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="801">提示</font></div>
</td>
<td class="content"><font o="802">
如果要让Config Server处理所有加密以及解密，也可以将<code i="407">{name:value}</code>前缀添加到发布到<code i="408">/encrypt</code>端点的明文中。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_serving_encrypted_properties"><font o="803">服务加密Properties</font></h3>
<div class="paragraph">
<p><font o="804">有时您希望客户端在本地解密配置，而不是在服务器中进行配置。</font><font o="805">在这种情况下，您仍然可以拥有/加密和解密端点（如果您提供<code i="409">encrypt.*</code>配置来定位密钥），但是您需要使用<code i="410">spring.cloud.config.server.encrypt.enabled=false</code>明确地关闭传出属性的解密。</font><font o="806">如果您不关心端点，那么如果您既不配置密钥也不配置使能的标志，则应该起作用。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serving_alternative_formats"><font o="807">服务替代格式</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="808">来自环境端点的默认JSON格式对于Spring应用程序的消费是完美的，因为它直接映射到<code i="411">Environment</code>抽象。</font><font o="809">如果您喜欢，可以通过向资源路径（“.yml”，“.yaml”或“.properties”）添加后缀来使用与YAML或Java属性相同的数据。</font><font o="810">这对于不关心JSON端点的结构的应用程序或其提供的额外的元数据的应用程序来说可能是有用的，例如，不使用Spring的应用程序可能会受益于此方法的简单性。</font></p>
</div>
<div class="paragraph">
<p><font o="811">YAML和属性表示有一个额外的标志（作为一个布尔查询参数<code i="412">resolvePlaceholders</code>提供）），以标示Spring <code i="413">${…​}</code>形式的源文档中的占位符，应在输出中解析可能在渲染之前。</font><font o="812">对于不了解Spring占位符惯例的消费者来说，这是一个有用的功能。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="813">注意</font></div>
</td>
<td class="content"><font o="814">
使用YAML或属性格式存在局限性，主要是与元数据的丢失有关。</font><font o="815">JSON被构造为属性源的有序列表，例如，名称与源相关联。</font><font o="816">即使源的起源具有多个源，并且原始源文件的名称丢失，YAML和属性表也合并成一个映射。</font><font o="817">YAML表示不一定是后台存储库中YAML源的忠实表示：它是由平面属性源的列表构建的，并且必须对键的形式进行假设。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serving_plain_text"><font o="818">服务纯文本</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="819">您的应用程序可能需要通用的纯文本配置文件，而不是使用<code i="414">Environment</code>抽象（或YAML中的其他替代表示形式或属性格式）。</font><font o="820">配置服务器通过<code i="415">/{name}/{profile}/{label}/{path}</code>附加的端点提供这些服务，其中“name”，“profile”和“label”的含义与常规环境端点相同，但“path”是文件名（例如<code i="416">log.xml</code> ）。</font><font o="821">此端点的源文件位于与环境端点相同的方式：与属性或YAML文件相同的搜索路径，而不是聚合所有匹配的资源，只返回匹配的第一个。</font></p>
</div>
<div class="paragraph">
<p><font o="822">找到资源后，使用正确格式（<code i="417">${…​}</code>）的占位符将使用有效的<code i="418">Environment</code>解析为应用程序名称，配置文件和标签提供。</font><font o="823">以这种方式，资源端点与环境端点紧密集成。</font><font o="824">例如，如果您有一个GIT（或SVN）资源库的布局：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">application.yml
nginx.conf</pre>
</div>
</div>
<div class="paragraph">
<p><font o="825">其中<code i="419">nginx.conf</code>如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">server {
    listen              80;
    server_name         ${nginx.server.name};
}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="826">和<code i="420">application.yml</code>这样：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">nginx:
  server:
    name: example.com
---
spring:
  profiles: development
nginx:
  server:
    name: develop.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="827">那么<code i="421">/foo/default/master/nginx.conf</code>资源如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">server {
    listen              80;
    server_name         example.com;
}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="828">和<code i="422">/foo/development/master/nginx.conf</code>这样：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">server {
    listen              80;
    server_name         develop.com;
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="829">注意</font></div>
</td>
<td class="content"><font o="830">
就像环境配置的源文件一样，“配置文件”用于解析文件名，因此，如果您想要一个特定于配置文件的文件，则<code i="423">/*/development/*/logback.xml</code>将由一个名为<code i="424">logback-development.xml</code>的文件解析（优先于<code i="425">logback.xml</code>）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_embedding_the_config_server"><font o="831">嵌入配置服务器</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="832">配置服务器最好作为独立应用程序运行，但如果需要，可以将其嵌入到另一个应用程序中。</font><font o="833">只需使用<code i="426">@EnableConfigServer</code>注释。</font><font o="834">在这种情况下可以使用的可选属性是<code i="427">spring.cloud.config.server.bootstrap</code>，它是一个标志，表示服务器应该从其自己的远程存储库配置自身。</font><font o="835">该标志默认关闭，因为它可能会延迟启动，但是当嵌入在另一个应用程序中时，以与其他应用程序相同的方式初始化是有意义的。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="836">注意</font></div>
</td>
<td class="content"><font o="837">
应该是显而易见的，但请记住，如果您使用引导标志，配置服务器将需要在<code i="428">bootstrap.yml</code>中配置其名称和存储库URI。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="838">要更改服务器端点的位置，您可以（可选）设置<code i="429">spring.cloud.config.server.prefix</code>，例如“/ config”，以提供前缀下的资源。</font><font o="839">前缀应该开始但不以“/”结尾。</font><font o="840">它被应用于配置服务器中的<code i="430">@RequestMappings</code>（即Spring Boot前缀<code i="431">server.servletPath</code>和<code i="432">server.contextPath</code>）之下。</font></p>
</div>
<div class="paragraph">
<p><font o="841">如果您想直接从后端存储库（而不是从配置服务器）读取应用程序的配置，这基本上是一个没有端点的嵌入式配置服务器。</font><font o="842">如果不使用<code i="433">@EnableConfigServer</code>注释（仅设置<code i="434">spring.cloud.config.server.bootstrap=true</code>），则可以完全关闭端点。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_push_notifications_and_spring_cloud_bus"><font o="843">推送通知和Spring Cloud Bus</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="844">许多源代码存储库提供程序（例如Github，Gitlab或Bitbucket）将通过webhook通知您存储库中的更改。</font><font o="845">您可以通过提供商的用户界面将webhook配置为URL和一组感兴趣的事件。</font><font o="846">例如，
 </font><a href="https://developer.github.com/v3/activity/events/types/#pushevent"><font o="846">Github</font></a><font o="846"> 
将使用包含提交列表的JSON主体和“X-Github-Event”等于“push”的头文件发送到webhook。</font><font o="847">如果在<code i="435">spring-cloud-config-monitor</code>库中添加依赖关系并激活配置服务器中的Spring Cloud Bus，则启用“/ monitor”端点。</font></p>
</div>
<div class="paragraph">
<p><font o="848">当Webhook被激活时，配置服务器将发送一个<code i="436">RefreshRemoteApplicationEvent</code>针对他认为可能已经改变的应用程序。</font><font o="849">变更检测可以进行策略化，但默认情况下，它只是查找与应用程序名称匹配的文件的更改（例如，“foo.properties”针对的是“foo”应用程序，“application.properties”针对所有应用程序） 。</font><font o="850">如果要覆盖该行为的策略是<code i="437">PropertyPathNotificationExtractor</code>，它接受​​请求标头和正文作为参数，并返回更改的文件路径列表。</font></p>
</div>
<div class="paragraph">
<p><font o="851">默认配置与Github，Gitlab或Bitbucket配合使用。</font><font o="852">除了来自Github，Gitlab或Bitbucket的JSON通知之外，您还可以通过使用表单编码的身体参数<code i="438">path={name}</code>通过POST为“/ monitor”来触发更改通知。</font><font o="853">这将广播到匹配“{name}”模式的应用程序（可以包含通配符）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="854">注意</font></div>
</td>
<td class="content"><font o="855">
只有在配置服务器和客户端应用程序中激活<code i="440">spring-cloud-bus</code>时才会传送<code i="439">RefreshRemoteApplicationEvent</code>。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="856">注意</font></div>
</td>
<td class="content"><font o="857">
默认配置还检测本地git存储库中的文件系统更改（在这种情况下不使用webhook，但是一旦编辑配置文件，将会播放刷新）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_config_client"><font o="858">Spring Cloud Config客户端</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="859">Spring Boot应用程序可以立即利用Spring配置服务器（或应用程序开发人员提供的其他外部属性源），并且还将获取与<code i="441">Environment</code>更改事件相关的一些其他有用功能。</font></p>
</div>
<div class="sect2">
<h3 id="config-first-bootstrap"><font o="860">配置第一引导</font></h3>
<div class="paragraph">
<p><font o="861">这是在类路径上具有Spring Cloud Config Client的任何应用程序的默认行为。</font><font o="862">配置客户端启动时，它将通过配置服务器（通过引导配置属性<code i="442">spring.cloud.config.uri</code>）绑定，并使用远程属性源初始化Spring <code i="443">Environment</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="863">这样做的最终结果是所有想要使用Config Server的客户端应用程序需要<code i="444">bootstrap.yml</code>（或环境变量），服务器地址位于<code i="445">spring.cloud.config.uri</code>（默认为“http：// localhost：8888” ）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="discovery-first-bootstrap"><font o="864">发现第一个引导</font></h3>
<div class="paragraph">
<p><font o="865">如果您正在使用DiscoveryClient实现，例如Spring Cloud Netflix和Eureka服务发现或Spring Cloud Consul（Spring Cloud Zookeeper不支持此功能），那么您可以使用Config Server如果您想要发现服务注册，但在默认的“配置优先”模式下，客户端将无法利用注册。</font></p>
</div>
<div class="paragraph">
<p><font o="866">如果您希望使用<code i="446">DiscoveryClient</code>找到配置服务器，可以通过设置<code i="447">spring.cloud.config.discovery.enabled=true</code>（默认为“false”）来实现。</font><font o="867">最终的结果是，客户端应用程序都需要具有适当发现配置的<code i="448">bootstrap.yml</code>（或环境变量）。</font><font o="868">例如，使用Spring Cloud Netflix，您需要定义Eureka服务器地址，例如<code i="449">eureka.client.serviceUrl.defaultZone</code>。</font><font o="869">使用此选项的价格是启动时额外的网络往返，以定位服务注册。</font><font o="870">好处是配置服务器可以更改其坐标，只要发现服务是一个固定点。</font><font o="871">默认的服务标识是“configserver”，但您可以使用<code i="450">spring.cloud.config.discovery.serviceId</code>在客户端进行更改（在服务器上以服务的通常方式更改，例如设置<code i="451">spring.application.name</code>）。</font></p>
</div>
<div class="paragraph">
<p><font o="872">发现客户端实现都支持某种元数据映射（例如Eureka，我们有<code i="452">eureka.instance.metadataMap</code>）。</font><font o="873">可能需要在其服务注册元数据中配置Config Server的一些其他属性，以便客户端可以正确连接。</font><font o="874">如果使用HTTP Basic安全配置服务器，则可以将凭据配置为“用户名”和“密码”。</font><font o="875">并且如果配置服务器具有上下文路径，您可以设置“configPath”。</font><font o="876">例如，对于作为Eureka客户端的配置服务器：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="877">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">eureka:
  instance:
    ...
    metadataMap:
      user: osufhalskjrtl
      password: lviuhlszvaorhvlo5847
      configPath: /config</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="config-client-fail-fast"><font o="878">配置客户端快速失败</font></h3>
<div class="paragraph">
<p><font o="879">在某些情况下，如果服务无法连接到配置服务器，则可能希望启动服务失败。</font><font o="880">如果这是所需的行为，请设置引导配置属性<code i="453">spring.cloud.config.failFast=true</code>，客户端将以异常停止。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="config-client-retry"><font o="881">配置客户端重试</font></h3>
<div class="paragraph">
<p><font o="882">如果您希望配置服务器在您的应用程序启动时可能偶尔不可用，您可以要求它在发生故障后继续尝试。</font><font o="883">首先，您需要设置<code i="454">spring.cloud.config.failFast=true</code>，然后您需要添加<code i="455">spring-retry</code>和<code i="456">spring-boot-starter-aop</code>到您的类路径。</font><font o="884">默认行为是重试6次，初始退避间隔为1000ms，指数乘数为1.1，用于后续退避。</font><font o="885">您可以使用<code i="457">spring.cloud.config.retry.*</code>配置属性配置这些属性（和其他）。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="886">提示</font></div>
</td>
<td class="content"><font o="887">
要完全控制重试，请使用ID“configServerRetryInterceptor”添加<code i="459">RetryOperationsInterceptor</code>类型的<code i="458">@Bean</code>。</font><font o="888">Spring重试有一个<code i="460">RetryInterceptorBuilder</code>可以轻松创建一个。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_locating_remote_configuration_resources"><font o="889">查找远程配置资源</font></h3>
<div class="paragraph">
<p><font o="890">配置服务从<code i="461">/{name}/{profile}/{label}</code>提供属性源，客户端应用程序中的默认绑定</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="891">“name”= <code i="462">${spring.application.name}</code></font></p>
</li>
<li>
<p><font o="892">“profile”= <code i="463">${spring.profiles.active}</code>（实际上是<code i="464">Environment.getActiveProfiles()</code>）</font></p>
</li>
<li>
<p><font o="893">“label”=“master”</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="894">所有这些都可以通过设置<code i="465">spring.cloud.config.*</code>（其中<code i="466">*</code>是“name”，“profile”或“label”）来覆盖。</font><font o="895">“标签”可用于回滚到以前版本的配置; </font><font o="896">使用默认的Config Server实现，它可以是git标签，分支名称或提交ID。</font><font o="897">标签也可以以逗号分隔的列表形式提供，在这种情况下，列表中的项目会逐个尝试，直到成功。</font><font o="898">例如，当您可能希望将配置标签与您的分支对齐，但使其成为可选（例如<code i="467">spring.cloud.config.label=myfeature,develop</code>）时，这对于在特征分支上工作时可能很有用。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_security_2"><font o="899">安全</font></h3>
<div class="paragraph">
<p><font o="900">如果您在服务器上使用HTTP基本安全性，那么客户端只需要知道密码（如果不是默认用户名）。</font><font o="901">您可以通过配置服务器URI，或通过单独的用户名和密码属性，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="902">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
     uri: https://user:secret@myconfig.mycompany.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="903">要么</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="904">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
     uri: https://myconfig.mycompany.com
     username: user
     password: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="905"><code i="468">spring.cloud.config.password</code>和<code i="469">spring.cloud.config.username</code>值覆盖URI中提供的任何内容。</font></p>
</div>
<div class="paragraph">
<p><font o="906">如果您在Cloud Foundry部署应用程序，则提供密码的最佳方式是通过服务凭证（例如URI），因为它甚至不需要在配置文件中。</font><font o="907">在Cloud Foundry上为本地工作的用户提供的服务的一个例子，名为“configserver”：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="908">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
     uri: ${vcap.services.configserver.credentials.uri:http://user:password@localhost:8888}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="909">如果您使用另一种形式的安全性，则可能需要向<code i="471">ConfigServicePropertySourceLocator</code>提供<code i="470">RestTemplate</code>（例如，通过在引导上下文中获取它并注入一个）。</font><font o="909"><code i="471">ConfigServicePropertySourceLocator</code> </font><a href="https://springcloud.cc/spring-cloud-dalston.html#custom-rest-template"><font o="909">提供{470</font></a><font o="909"> /}（例如通过在引导上下文中获取它并注入）。</font></p>
</div>
<div class="sect3">
<h4 id="_health_indicator_2"><font o="910">健康指标</font></h4>
<div class="paragraph">
<p><font o="911">Config Client提供一个尝试从Config Server加载配置的Spring Boot运行状况指示器。</font><font o="912">可以通过设置<code i="472">health.config.enabled=false</code>来禁用运行状况指示器。</font><font o="913">由于性能原因，响应也被缓存。</font><font o="914">默认缓存生存时间为5分钟。</font><font o="915">要更改该值，请设置<code i="473">health.config.time-to-live</code>属性（以毫秒为单位）。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="custom-rest-template"><font o="916">提供自定义RestTemplate</font></h4>
<div class="paragraph">
<p><font o="917">在某些情况下，您可能需要从客户端自定义对配置服务器的请求。</font><font o="918">通常这涉及传递特殊的<code i="474">Authorization</code>标头来对服务器的请求进行身份验证。</font><font o="919">要提供自定义<code i="475">RestTemplate</code>，请按照以下步骤操作。</font></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><font o="920">设置<code i="476">spring.cloud.config.enabled=false</code>以禁用现有的配置服务器属性源。</font></p>
</li>
<li>
<p><font o="921">使用<code i="477">PropertySourceLocator</code>实现创建一个新的配置bean。</font></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title"><font o="922">CustomConfigServiceBootstrapConfiguration.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class CustomConfigServiceBootstrapConfiguration {
    @Bean
    public ConfigClientProperties configClientProperties() {
        ConfigClientProperties client = new ConfigClientProperties(this.environment);
        client.setEnabled(false);
        return client;
    }

    @Bean
    public ConfigServicePropertySourceLocator configServicePropertySourceLocator() {
        ConfigClientProperties clientProperties = configClientProperties();
       ConfigServicePropertySourceLocator configServicePropertySourceLocator =  new ConfigServicePropertySourceLocator(clientProperties);
        configServicePropertySourceLocator.setRestTemplate(customRestTemplate(clientProperties));
        return configServicePropertySourceLocator;
    }
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><font o="923">在<code i="478">resources/META-INF</code>中创建一个名为<code i="479">spring.factories</code>的文件，并指定您的自定义配置。</font></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title"><font o="924">spring.factorties</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-properties" data-lang="properties">org.springframework.cloud.bootstrap.BootstrapConfiguration = com.my.config.client.CustomConfigServiceBootstrapConfiguration</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_vault">Vault</h4>
<div class="paragraph">
<p><font o="926">当使用Vault作为配置服务器的后端时，客户端将需要为服务器提供一个令牌，以从Vault中检索值。</font><font o="927">可以通过在<code i="481">bootstrap.yml</code>中设置<code i="480">spring.cloud.config.token</code>在客户端中提供此令牌。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="928">bootstrap.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  cloud:
    config:
      token: YourVaultToken</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_vault_2">Vault</h3>
<div class="sect3">
<h4 id="_nested_keys_in_vault"><font o="930">Vault中的嵌套密钥</font></h4>
<div class="paragraph">
<p><font o="931">Vault支持将键嵌入存储在Vault中的值。</font><font o="932">例如</font></p>
</div>
<div class="paragraph">
<p><code>echo -n '{"appA": {"secret": "appAsecret"}, "bar": "baz"}' | vault write secret/myapp -</code></p>
</div>
<div class="paragraph">
<p><font o="933">此命令将向您的Vault编写一个JSON对象。</font><font o="934">要在Spring中访问这些值，您将使用传统的点（。）注释。</font><font o="935">例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Value("${appA.secret}")
String name = "World";</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="936">上述代码将<code i="482">name</code>变量设置为<code i="483">appAsecret</code>。</font></p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_netflix" class="sect0">Spring Cloud Netflix</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><strong><font o="938">Dalston.RELEASE</font></strong></p>
</div>
<div class="paragraph">
<p><font o="939">该项目通过自动配置为Spring Boot应用程序提供Netflix OSS集成，并绑定到Spring环境和其他Spring编程模型成语。</font><font o="940">通过几个简单的注释，您可以快速启用和配置应用程序中的常见模式，并通过经过测试的Netflix组件构建大型分布式系统。</font><font o="941">提供的模式包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载平衡（Ribbon）。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_service_discovery_eureka_clients"><font o="942">服务发现：Eureka客户端</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="943">服务发现是基于微服务架构的关键原则之一。</font><font o="944">尝试配置每个客户端或某种形式的约定可能非常困难，可以非常脆弱。</font><font o="945">Netflix服务发现服务器和客户端是Eureka。</font><font o="946">可以将服务器配置和部署为高可用性，每个服务器将注册服务的状态复制到其他服务器。</font></p>
</div>
<div class="sect2">
<h3 id="netflix-eureka-client-starter"><font o="947">如何包含Eureka客户端</font></h3>
<div class="paragraph">
<p><font o="948">要在您的项目中包含Eureka客户端，请使用组<code i="484">org.springframework.cloud</code>和工件ID <code i="485">spring-cloud-starter-eureka</code>的启动器。</font><font o="949">有关</font><font o="949">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="949">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="949">Spring Cloud项目页面</font></a><font o="949">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_registering_with_eureka"><font o="950">注册Eureka</font></h3>
<div class="paragraph">
<p><font o="951">当客户端注册Eureka时，它提供关于自身的元数据，例如主机和端口，健康指示符URL，主页等。Eureka从属于服务的每个实例接收心跳消息。</font><font o="952">如果心跳失败超过可配置的时间表，则通常将该实例从注册表中删除。</font></p>
</div>
<div class="paragraph">
<p><font o="953">示例eureka客户端：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableEurekaClient
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="954">（即完全正常的Spring Boot应用程序）。</font><font o="955">在这个例子中，我们明确地使用<code i="486">@EnableEurekaClient</code>，但只有Eureka可用，你也可以使用<code i="487">@EnableDiscoveryClient</code>。</font><font o="956">需要配置才能找到Eureka服务器。</font><font o="957">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="958">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p><font o="959">其中“defaultZone”是一个魔术字符串后备值，为任何不表示首选项的客户端提供服务URL（即它是有用的默认值）。</font></p>
</div>
<div class="paragraph">
<p><font o="960">从<code i="488">Environment</code>获取的默认应用程序名称（服务ID），虚拟主机和非安全端口分别为<code i="489">${spring.application.name}</code>，<code i="490">${spring.application.name}</code>和<code i="491">${server.port}</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="961"><code i="492">@EnableEurekaClient</code>将应用程序同时进入一个Eureka“实例”（即注册自己）和一个“客户端”（即它可以查询注册表以查找其他服务）。</font><font o="962">实例行为由<code i="493">eureka.instance.*</code>配置键驱动，但是如果您确保您的应用程序具有<code i="494">spring.application.name</code>（这是Eureka服务ID或VIP的默认值），那么默认值将是正常的。</font></p>
</div>
<div class="paragraph">
<p><font o="963">有关可</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java"><font o="963">配置</font></a><font></font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java"><font o="963">选项</font></a><font o="963">的更多详细信息，</font><font o="963">请参阅</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java"><font o="963">EurekaInstanceConfigBean</font></a><font o="963">和</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java"><font o="963">EurekaClientConfigBean</font></a><font o="963">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_authenticating_with_the_eureka_server"><font o="964">使用Eureka服务器进行身份验证</font></h3>
<div class="paragraph">
<p><font o="965">如果其中一个<code i="495">eureka.client.serviceUrl.defaultZone</code>网址中包含一个凭据（如<code i="496"><a href="http://user:password@localhost:8761/eureka" class="bare">http://user:password@localhost:8761/eureka</a></code>）），HTTP基本身份验证将自动添加到您的eureka客户端。</font><font o="966">对于更复杂的需求，您可以创建<code i="498">DiscoveryClientOptionalArgs</code>类型的<code i="497">@Bean</code>，并将<code i="499">ClientFilter</code>实例注入到其中，所有这些都将应用于从客户端到服务器的调用。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="967">注意</font></div>
</td>
<td class="content"><font o="968">
由于Eureka中的限制，不可能支持每个服务器的基本身份验证凭据，所以只能使用第一个找到的集合。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_status_page_and_health_indicator"><font o="969">状态页和健康指标</font></h3>
<div class="paragraph">
<p><font o="970">Eureka实例的状态页面和运行状况指示器分别默认为“/ info”和“/ health”，它们是Spring Boot执行器应用程序中有用端点的默认位置。</font><font o="971">如果您使用非默认上下文路径或servlet路径（例如<code i="500">server.servletPath=/foo</code>）或管理端点路径（例如<code i="501">management.contextPath=/admin</code>），则需要更改这些，即使是执行器应用程序。</font><font o="972">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="973">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  instance:
    statusPageUrlPath: ${management.context-path}/info
    healthCheckUrlPath: ${management.context-path}/health</pre>
</div>
</div>
<div class="paragraph">
<p><font o="974">这些链接显示在客户端使用的元数据中，并在某些情况下用于决定是否将请求发送到应用程序，因此如果它们是准确的，这是有帮助的。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_registering_a_secure_application"><font o="975">注册安全应用程序</font></h3>
<div class="paragraph">
<p><font o="976">如果您的应用程序想通过HTTPS联系，则可以分别在<code i="502">EurekaInstanceConfig</code>，</font><em><font o="976">即</font></em><font o="976"> 
<code i="503">eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]</code> </font><font o="976">中设置两个标志</font><font o="976">。</font><font o="977">这将使Eureka发布实例信息显示安全通信的明确偏好。</font><font o="978">Spring Cloud <code i="504">DiscoveryClient</code>将始终为以这种方式配置的服务返回一个<code i="505"><a href="https://%E2%80%A6%E2%80%8B/" class="bare">https://…​</a>;</code> URI，并且Eureka（本机）实例信息将具有安全的健康检查URL。</font></p>
</div>
<div class="paragraph">
<p><font o="979">由于Eureka内部的工作方式，它仍然会发布状态和主页的非安全网址，除非您也明确地覆盖。</font><font o="980">您可以使用占位符来配置eureka实例URL，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="981">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</pre>
</div>
</div>
<div class="paragraph">
<p><font o="982">（请注意，<code i="506">${eureka.hostname}</code>是仅在稍后版本的Eureka中可用的本地占位符，您也可以使用Spring占位符实现同样的功能，例如使用<code i="507">${eureka.instance.hostName}</code>。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="983">注意</font></div>
</td>
<td class="content"><font o="984">
如果您的应用程序在代理服务器后面运行，并且SSL终止服务在代理中（例如，如果您运行在Cloud Foundry或其他平台作为服务），则需要确保代理“转发”头部被截取并处理应用程序。</font><font o="985">Spring Boot应用程序中的嵌入式Tomcat容器会自动执行“X-Forwarded  -  \ *”标头的显式配置。</font><font o="986">你这个错误的一个迹象就是你的应用程序本身所呈现的链接是错误的（错误的主机，端口或协议）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_eureka_s_health_checks"><font o="987">Eureka的健康检查</font></h3>
<div class="paragraph">
<p><font o="988">默认情况下，Eureka使用客户端心跳来确定客户端是否启动。</font><font o="989">除非另有规定，否则发现客户端将不会根据Spring Boot执行器传播应用程序的当前运行状况检查状态。</font><font o="990">这意味着成功注册后Eureka将永远宣布申请处于“UP”状态。</font><font o="991">通过启用Eureka运行状况检查可以改变此行为，从而将应用程序状态传播到Eureka。</font><font o="992">因此，每个其他应用程序将不会在“UP”之外的状态下将流量发送到应用程序。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="993">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  client:
    healthcheck:
      enabled: true</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="994">警告</font></div>
</td>
<td class="content"><font o="995">
<code i="508">eureka.client.healthcheck.enabled=true</code>只能在<code i="509">application.yml</code>中设置。</font><font o="996">设置<code i="510">bootstrap.yml</code>中的值将导致不期望的副作用，例如在具有<code i="511">UNKNOWN</code>状态的eureka中注册。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="997">如果您需要更多的控制健康检查，您可以考虑实施自己的<code i="512">com.netflix.appinfo.HealthCheckHandler</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_eureka_metadata_for_instances_and_clients"><font o="998">Eureka实例和客户端的元数据</font></h3>
<div class="paragraph">
<p><font o="999">值得花点时间了解Eureka元数据的工作原理，以便您可以在平台上使用它。</font><font o="1000">有主机名，IP地址，端口号，状态页和运行状况检查等标准元数据。</font><font o="1001">这些发布在服务注册表中，由客户使用，以直接的方式联系服务。</font><font o="1002">额外的元数据可以添加到<code i="513">eureka.instance.metadataMap</code>中的实例注册中，并且这将在远程客户端中可访问，但一般不会更改客户端的行为，除非意识到元数据的含义。</font><font o="1003">下面描述了几个特殊情况，其中Spring Cloud已经为元数据映射指定了含义。</font></p>
</div>
<div class="sect3">
<h4 id="_using_eureka_on_cloudfoundry"><font o="1004">在Cloudfoundry上使用Eureka</font></h4>
<div class="paragraph">
<p><font o="1005">Cloudfoundry有一个全局路由器，所以同一个应用程序的所有实例都具有相同的主机名（在具有相似架构的其他PaaS解决方案中也是如此）。</font><font o="1006">这不一定是使用Eureka的障碍，但如果您使用路由器（建议，甚至是强制性的，具体取决于您的平台的设置方式），则需要明确设置主机名和端口号（安全或非安全），以便他们使用路由器。</font><font o="1007">您可能还需要使用实例元数据，以便您可以区分客户端上的实例（例如，在自定义负载平衡器中）。</font><font o="1008">默认情况下，<code i="514">eureka.instance.instanceId</code>为<code i="515">vcap.application.instance_id</code>。</font><font o="1009">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1010">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1011">根据Cloudfoundry实例中安全规则的设置方式，您可以注册并使用主机VM的IP地址进行直接的服务到服务调用。</font><font o="1012">此功能尚未在Pivotal Web Services（</font><a href="https://run.pivotal.io/"><font o="1012">PWS</font></a><font o="1012">）上提供。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_using_eureka_on_aws"><font o="1013">在AWS上使用Eureka</font></h4>
<div class="paragraph">
<p><font o="1014">如果应用程序计划将部署到AWS云，那么Eureka实例必须被配置为AWS意识到，这可以通过定制来完成</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java"><font o="1014">EurekaInstanceConfigBean</font></a><font o="1014">方式如下：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
@Profile("!default")
public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
  EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
  b.setDataCenterInfo(info);
  return b;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changing_the_eureka_instance_id"><font o="1015">更改Eureka实例ID</font></h4>
<div class="paragraph">
<p><font o="1016">香草Netflix Eureka实例注册了与其主机名相同的ID（即每个主机只有一个服务）。</font><font o="1017">Spring Cloud Eureka提供了一个明智的默认，如下所示：<code i="516">${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</code>。</font><font o="1018">例如<code i="517">myhost:myappname:8080</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1019">使用Spring Cloud，您可以通过在<code i="518">eureka.instance.instanceId</code>中提供唯一的标识符来覆盖此。</font><font o="1020">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1021">application.yml</font></div>
<div class="content">
<pre class="notranslate">eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1022">使用这个元数据和在localhost上部署的多个服务实例，随机值将在那里进行，以使实例是唯一的。</font><font o="1023">在Cloudfoundry中，<code i="519">vcap.application.instance_id</code>将在Spring Boot应用程序中自动填充，因此不需要随机值。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_eurekaclient"><font o="1024">使用EurekaClient</font></h3>
<div class="paragraph">
<p><font o="1025">一旦您拥有<code i="520">@EnableDiscoveryClient</code>（或<code i="521">@EnableEurekaClient</code>）的应用程序，您就可以使用它来从</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server"><font o="1025">Eureka服务器</font></a><font o="1025">发现服务实例</font><font o="1025">。</font><font o="1026">一种方法是使用本机<code i="522">com.netflix.discovery.EurekaClient</code>（而不是Spring云<code i="523">DiscoveryClient</code>），例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1027">提示</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1028">不要使用<code i="525">@PostConstruct</code>方法或<code i="526">@Scheduled</code>方法（或<code i="527">ApplicationContext</code>可能尚未启动的任何地方）<code i="524">EurekaClient</code>。</font><font o="1029">它被初始化为<code i="528">SmartLifecycle</code>（带有<code i="529">phase=0</code>），所以最早可以依靠它可用的是另一个具有更高阶段的<code i="530">SmartLifecycle</code>。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives_to_the_native_netflix_eurekaclient"><font o="1030">本机Netflix EurekaClient的替代方案</font></h3>
<div class="paragraph">
<p><font o="1031">您不必使用原始的Netflix <code i="531">EurekaClient</code>，通常在某种包装器后面使用它更为方便。</font><font o="1032">Spring Cloud支持</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign"><font o="1032">Feign</font></a><font o="1032">（REST客户端构建器），还支持</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="1032">Spring <code i="532">RestTemplate</code></font></a><font o="1032">使用逻辑Eureka服务标识符（VIP）而不是物理URL。</font><font o="1033">要使用固定的物理服务器列表配置Ribbon，您可以将<code i="533">&lt;client&gt;.ribbon.listOfServers</code>设置为逗号分隔的物理地址（或主机名）列表，其中<code i="534">&lt;client&gt;</code>是客户端的ID。</font></p>
</div>
<div class="paragraph">
<p><font o="1034">您还可以使用<code i="535">org.springframework.cloud.client.discovery.DiscoveryClient</code>，它为Netflix不具体的发现客户端提供简单的API，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_why_is_it_so_slow_to_register_a_service"><font o="1035">为什么注册服务这么慢？</font></h3>
<div class="paragraph">
<p><font o="1036">作为一个实例也包括定期心跳到注册表（通过客户端的<code i="536">serviceUrl</code>），默认持续时间为30秒。</font><font o="1037">在实例，服务器和客户端在其本地缓存中都具有相同的元数据（因此可能需要3个心跳）之前，客户端才能发现服务。</font><font o="1038">您可以使用<code i="537">eureka.instance.leaseRenewalIntervalInSeconds</code>更改期限，这将加快客户端连接到其他服务的过程。</font><font o="1039">在生产中，最好坚持使用默认值，因为服务器内部有一些计算可以对租赁更新期进行假设。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_zones"><font o="1040">区</font></h3>
<div class="paragraph">
<p><font o="1041">如果您已将Eureka客户端部署到多个区域，您可能希望这些客户端在使用另一个区域中的服务之前，利用同一区域内的服务。</font><font o="1042">为此，您需要正确配置您的Eureka客户端。</font></p>
</div>
<div class="paragraph">
<p><font o="1043">首先，您需要确保将Eureka服务器部署到每个区域，并且它们是彼此的对等体。</font><font o="1044">有关详细信息，请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-server-zones-and-regions"><font o="1044">区域和区域</font></a><font o="1044">部分</font><font o="1044">
。</font></p>
</div>
<div class="paragraph">
<p><font o="1045">接下来，您需要告知Eureka您的服务所在的区域。您可以使用<code i="538">metadataMap</code>属性来执行此操作。</font><font o="1046">例如，如果<code i="539">service 1</code>部署到<code i="540">zone 1</code>和<code i="541">zone 2</code>，则需要在<code i="542">service 1</code>中设置以下Eureka属性</font></p>
</div>
<div class="paragraph">
<p><strong><font o="1047">1区服务1</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>eureka.instance.metadataMap.zone = zone1
eureka.client.preferSameZoneEureka = true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="1048">第2区的服务1</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>eureka.instance.metadataMap.zone = zone2
eureka.client.preferSameZoneEureka = true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-eureka-server"><font o="1049">服务发现：Eureka服务器</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="netflix-eureka-server-starter"><font o="1050">如何包含Eureka服务器</font></h3>
<div class="paragraph">
<p><font o="1051">要在项目中包含Eureka服务器，请使用组<code i="543">org.springframework.cloud</code>和工件id <code i="544">spring-cloud-starter-eureka-server</code>的启动器。</font><font o="1052">有关</font><font o="1052">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1052">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1052">Spring Cloud项目页面</font></a><font o="1052">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-running-eureka-server"><font o="1053">如何运行Eureka服务器</font></h3>
<div class="paragraph">
<p><font o="1054">示例eureka服务器;</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableEurekaServer
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1055">服务器具有一个带有UI的主页，并且根据<code i="545">/eureka/*</code>下的正常Eureka功能的HTTP API端点。</font></p>
</div>
<div class="paragraph">
<p><font o="1056">Eureka背景阅读：看</font><a href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer"><font o="1056">助焊剂电容</font></a><font o="1056">和</font><a href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0"><font o="1056">谷歌小组讨论</font></a><font o="1056">。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1057">提示</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1058">由于Gradle的依赖关系解决规则和父母的bom功能缺乏，只要依靠spring-cloud-starter-eureka-server就可能导致应用程序启动失败。</font><font o="1059">要解决这个问题，必须添加Spring Boot Gradle插件，并且必须导入Spring云启动器父母bom：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1060">的build.gradle</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">buildscript {
  dependencies {
    classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.5.RELEASE")
  }
}

apply plugin: "spring-boot"

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
  }
}</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-eureka-server-zones-and-regions"><font o="1061">高可用性，区域和地区</font></h3>
<div class="paragraph">
<p><font o="1062">Eureka服务器没有后端存储，但是注册表中的服务实例都必须发送心跳以保持其注册更新（因此可以在内存中完成）。</font><font o="1063">客户端还具有eureka注册的内存缓存（因此，他们不必为注册表提供每个服务请求）。</font></p>
</div>
<div class="paragraph">
<p><font o="1064">默认情况下，每个Eureka服务器也是一个Eureka客户端，并且需要（至少一个）服务URL来定位对等体。</font><font o="1065">如果您不提供该服务将运行和工作，但它将淋浴您的日志与大量的噪音无法注册对等体。</font></p>
</div>
<div class="paragraph">
<p><font o="1066">关于区域和区域的客户端</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="1066">Ribbon支持的详细信息，</font></a><font o="1066">请参见</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="1066">下文</font></a><font o="1066">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_standalone_mode"><font o="1067">独立模式</font></h3>
<div class="paragraph">
<p><font o="1068">只要存在某种监视器或弹性运行时间（例如Cloud Foundry），两个高速缓存（客户机和服务器）和心跳的组合使独立的Eureka服务器对故障具有相当的弹性。</font><font o="1069">在独立模式下，您可能更喜欢关闭客户端行为，因此不会继续尝试并且无法访问其对等体。</font><font o="1070">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1071">application.yml（Standalone Eureka Server）</font></div>
<div class="content">
<pre class="notranslate">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1072">请注意，<code i="546">serviceUrl</code>指向与本地实例相同的主机。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_peer_awareness"><font o="1073">同行意识</font></h3>
<div class="paragraph">
<p><font o="1074">通过运行多个实例并请求他们相互注册，可以使Eureka更具弹性和可用性。</font><font o="1075">事实上，这是默认的行为，所以你需要做的只是为对方添加一个有效的<code i="547">serviceUrl</code>，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1076">application.yml（Two Peer Aware Eureka服务器）</font></div>
<div class="content">
<pre class="notranslate">---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: http://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1077">在这个例子中，我们有一个YAML文件，可以通过在不同的Spring配置文件中运行，在2台主机（peer1和peer2）上运行相同的服务器。</font><font o="1078">您可以使用此配置来测试单个主机上的对等体感知（通过操作<code i="548">/etc/hosts</code>来解析主机名，在生产中没有太多价值）。</font><font o="1079">事实上，如果您在一台知道自己的主机名的机器上运行（默认情况下使用<code i="550">java.net.InetAddress</code>查找），则不需要<code i="549">eureka.instance.hostname</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1080">您可以向系统添加多个对等体，只要它们至少一个边缘彼此连接，则它们将在它们之间同步注册。</font><font o="1081">如果对等体在物理上分离（在数据中心内或多个数据中心之间），则系统原则上可以分裂脑型故障。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_prefer_ip_address"><font o="1082">喜欢IP地址</font></h3>
<div class="paragraph">
<p><font o="1083">在某些情况下，Eureka优先发布服务的IP地址而不是主机名。</font><font o="1084">将<code i="551">eureka.instance.preferIpAddress</code>设置为<code i="552">true</code>，并且当应用程序向eureka注册时，它将使用其IP地址而不是其主机名。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_circuit_breaker_hystrix_clients"><font o="1085">断路器：Hystrix客户端</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1086">Netflix的创造了一个调用的库</font><a href="https://github.com/Netflix/Hystrix"><font o="1086">Hystrix</font></a><font o="1086">实现了</font><a href="http://martinfowler.com/bliki/CircuitBreaker.html"><font o="1086">断路器图案</font></a><font o="1086">。</font><font o="1087">在微服务架构中，通常有多层服务调用。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/HystrixGraph.png" alt="HystrixGraph">
</div>
<div class="title"><font o="1088">图1.微服务图</font></div>
</div>
<div class="paragraph">
<p><font o="1089">较低级别的服务中的服务故障可能导致用户级联故障。</font><font o="1090">当对特定服务的呼叫达到一定阈值时（Hystrix中的默认值为5秒内的20次故障），电路打开，不进行通话。</font><font o="1091">在错误和开路的情况下，开发人员可以提供后备。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/HystrixFallback.png" alt="HystrixFallback">
</div>
<div class="title"><font o="1092">图2. Hystrix回退防止级联故障</font></div>
</div>
<div class="paragraph">
<p><font o="1093">开放式电路会停止级联故障，并允许不必要的或失败的服务时间来愈合。</font><font o="1094">回退可以是另一个Hystrix保护的调用，静态数据或一个正常的空值。</font><font o="1095">回退可能被链接，所以第一个回退使得一些其他业务电话又回到静态数据。</font></p>
</div>
<div class="sect2">
<h3 id="netflix-hystrix-starter"><font o="1096">如何加入Hystrix</font></h3>
<div class="paragraph">
<p><font o="1097">要在项目中包含Hystrix，请使用组<code i="553">org.springframework.cloud</code>和artifact id <code i="554">spring-cloud-starter-hystrix</code>的启动器。</font><font o="1098">有关</font><font o="1098">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1098">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1098">Spring Cloud项目页面</font></a><font o="1098">。</font></p>
</div>
<div class="paragraph">
<p><font o="1099">示例启动应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map&lt;String, Object&gt; parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map&lt;String, Object&gt; parameters) {
        return /* something useful */;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1100"><code i="555">@HystrixCommand</code>由名为</font><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica"><font o="1100">“javanica”</font></a><font o="1100">的Netflix contrib库提供
 </font><font o="1100">。</font><font o="1101">Spring Cloud在连接到Hystrix断路器的代理中使用该注释自动包装Spring bean。</font><font o="1102">断路器计算何时打开和关闭电路，以及在发生故障时应该做什么。</font></p>
</div>
<div class="paragraph">
<p><font o="1103">要配置<code i="556">@HystrixCommand</code>，您可以使用<code i="557">commandProperties</code>属性列出<code i="558">@HystrixProperty</code>注释。</font><font o="1104">请参阅
 </font><a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration"><font o="1104">这里</font></a><font o="1104"> 
了解更多详情。</font><font o="1105">有关</font><font o="1105">
可用属性的详细信息，</font><font o="1105">请参阅</font><a href="https://github.com/Netflix/Hystrix/wiki/Configuration"><font o="1105">Hystrix维基</font></a><font o="1105">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_propagating_the_security_context_or_using_spring_scopes"><font o="1106">传播安全上下文或使用Spring范围</font></h3>
<div class="paragraph">
<p><font o="1107">如果您希望某些线程本地上下文传播到<code i="559">@HystrixCommand</code>，默认声明将不起作用，因为它在线程池中执行命令（超时）。</font><font o="1108">您可以使用某些配置或直接在注释中使用与使用相同的线程来调用Hystrix，方法是要求使用不同的“隔离策略”。</font><font o="1109">例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@HystrixCommand(fallbackMethod = "stubMyService",
    commandProperties = {
      @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
    }
)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1110">如果您使用<code i="560">@SessionScope</code>或<code i="561">@RequestScope</code>，同样的事情也适用。</font><font o="1111">您将知道何时需要执行此操作，因为运行时异常说它找不到范围的上下文。</font></p>
</div>
<div class="paragraph">
<p><font o="1112">您还可以将<code i="562">hystrix.shareSecurityContext</code>属性设置为<code i="563">true</code>。</font><font o="1113">这样做会自动配置一个Hystrix并发策略插件钩子，他将<code i="564">SecurityContext</code>从主线程传送到Hystrix命令使用的钩子。</font><font o="1114">Hystrix不允许注册多个hystrix并发策略，因此可以通过将自己的<code i="565">HystrixConcurrencyStrategy</code>声明为Spring bean来实现扩展机制。</font><font o="1115">Spring Cloud将在Spring上下文中查找您的实现，并将其包装在自己的插件中。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_health_indicator_3"><font o="1116">健康指标</font></h3>
<div class="paragraph">
<p><font o="1117">连接断路器的状态也暴露在呼叫应用程序的<code i="566">/health</code>端点中。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "hystrix": {
        "openCircuitBreakers": [
            "StoreIntegration::getStoresByLocationLink"
        ],
        "status": "CIRCUIT_OPEN"
    },
    "status": "UP"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hystrix_metrics_stream"><font o="1118">Hystrix指标流</font></h3>
<div class="paragraph">
<p><font o="1119">要使Hystrix指标流包含对<code i="567">spring-boot-starter-actuator</code>的依赖。</font><font o="1120">这将使<code i="568">/hystrix.stream</code>作为管理端点。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_circuit_breaker_hystrix_dashboard"><font o="1121">断路器：Hystrix仪表板</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1122">Hystrix的主要优点之一是它收集关于每个HystrixCommand的一套指标。</font><font o="1123">Hystrix仪表板以有效的方式显示每个断路器的运行状况。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/Hystrix.png" alt="豪猪">
</div>
<div class="title"><font o="1124">图3. Hystrix仪表板</font></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hystrix_timeouts_and_ribbon_clients"><font o="1125">Hystrix超时和Ribbon客户</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1126">当使用包含Ribbon客户端的Hystrix命令时，您需要确保您的Hystrix超时配置为长于配置的Ribbon超时，包括可能进行的任何潜在的重试。</font><font o="1127">例如，如果您的Ribbon连接超时为一秒钟，并且Ribbon客户端可能会重试该请求三次，那么您的Hystrix超时应该略超过三秒钟。</font></p>
</div>
<div class="sect2">
<h3 id="netflix-hystrix-dashboard-starter"><font o="1128">如何包含Hystrix仪表板</font></h3>
<div class="paragraph">
<p><font o="1129">要在项目中包含Hystrix仪表板，请使用组<code i="569">org.springframework.cloud</code>和工件ID <code i="570">spring-cloud-starter-hystrix-dashboard</code>的启动器。</font><font o="1130">有关</font><font o="1130">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1130">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1130">Spring Cloud项目页面</font></a><font o="1130">。</font></p>
</div>
<div class="paragraph">
<p><font o="1131">要运行Hystrix仪表板使用<code i="571">@EnableHystrixDashboard</code>注释您的Spring Boot主类。</font><font o="1132">然后访问<code i="572">/hystrix</code>，并将仪表板指向Hystrix客户端应用程序中的单个实例<code i="573">/hystrix.stream</code>端点。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_turbine">Turbine</h3>
<div class="paragraph">
<p><font o="1134">从个人实例看，Hystrix数据在系统整体健康方面不是非常有用。</font><a href="https://github.com/Netflix/Turbine"><font o="1135">Turbine</font></a><font o="1135">是将所有相关<code i="574">/hystrix.stream</code>端点聚合到Hystrix仪表板中使用的<code i="575">/turbine.stream</code>的应用程序。</font><font o="1136">个人实例位于Eureka。</font><font o="1137">运行Turbine就像使用<code i="576">@EnableTurbine</code>注释（例如使用spring-cloud-starter-turbine设置类路径）注释主类一样简单。</font><font o="1138">来自</font><a href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)"><font o="1138">Turbine 1维基的</font></a><font o="1138">所有文档配置属性都</font><font o="1138">适用。</font><font o="1139">唯一的区别是<code i="577">turbine.instanceUrlSuffix</code>不需要预先添加的端口，除非<code i="578">turbine.instanceInsertPort=false</code>自动处理。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1140">注意</font></div>
</td>
<td class="content"><font o="1141">
默认情况下，Turbine通过在Eureka中查找其<code i="580">homePageUrl</code>条目，然后将<code i="581">/hystrix.stream</code>附加到注册的实例上查找<code i="579">/hystrix.stream</code>端点。</font><font o="1142">这意味着如果<code i="582">spring-boot-actuator</code>在自己的端口上运行（这是默认值），则对<code i="583">/hystrix.stream</code>的调用将失败。</font><font o="1143">要使涡轮机找到正确端口的Hystrix流，您需要向实例的元数据中添加<code i="584">management.port</code>：
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">eureka:
  instance:
    metadata-map:
      management.port: ${management.port:8081}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1144">配置密钥<code i="585">turbine.appConfig</code>是涡轮机将用于查找实例的尤里卡服务列表。</font><font o="1145">涡轮流然后在Hystrix仪表板中使用如下URL：<code i="586"><a href="http://my.turbine.sever:8080/turbine.stream?cluster=%3CCLUSTERNAME%3E" class="bare">http://my.turbine.sever:8080/turbine.stream?cluster=&lt;CLUSTERNAME&gt;</a>;</code>（如果名称为“默认值”，则可以省略群集参数）。</font><font o="1146"><code i="587">cluster</code>参数必须与<code i="588">turbine.aggregator.clusterConfig</code>中的条目相匹配。</font><font o="1147">从eureka返回的值是大写字母，因此如果有一个名为“customers”的Eureka注册了一个应用程序，我们预计此示例可以正常工作：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1148"><code i="589">clusterName</code>可以通过<code i="590">turbine.clusterNameExpression</code>中的SPEL表达式以root身份<code i="591">InstanceInfo</code>进行自定义。</font><font o="1149">默认值为<code i="592">appName</code>，这意味着Eureka serviceId最终作为集群密钥（即客户的<code i="593">InstanceInfo</code>具有<code i="594">appName</code>“CUSTOMERS”）。</font><font o="1150">一个不同的例子是<code i="595">turbine.clusterNameExpression=aSGName</code>，它将从AWS ASG名称获取集群名称。</font><font o="1151">另一个例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1152">在这种情况下，来自4个服务的集群名称从其元数据映射中提取，并且预期具有包含“SYSTEM”和“USER”的值。</font></p>
</div>
<div class="paragraph">
<p><font o="1153">要为所有应用程序使用“默认”集群，您需要一个字符串文字表达式（带单引号，并且如果它在YAML中也使用双引号进行转义）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1154">Spring Cloud提供了一个<code i="596">spring-cloud-starter-turbine</code>，它具有运行Turbine服务器所需的所有依赖关系。</font><font o="1155">只需创建一个Spring Boot应用程序并用<code i="597">@EnableTurbine</code>注释它。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1156">注意</font></div>
</td>
<td class="content"><font o="1157">
默认情况下，Spring Cloud允许Turbine使用主机和端口允许每个主机在每个群集中进行多个进程。</font><font o="1158">如果你想建成Turbine本地Netflix的行为，它</font><em><font o="1158">不会</font></em><font o="1158">允许每个主机上的多个过程，每簇（关键实例ID是主机名），然后将该属性设置<code i="598">turbine.combineHostPort=false</code>。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_turbine_stream">Turbine Stream</h3>
<div class="paragraph">
<p><font o="1160">在某些环境中（例如，在PaaS设置中），从所有分布式Hystrix命令中提取度量的经典Turbine模型不起作用。</font><font o="1161">在这种情况下，您可能希望让Hystrix命令将度量标准推送到Turbine，并且Spring Cloud可以使用消息传递。</font><font o="1162">您需要在客户端上执行的所有操作都为您选择的<code i="599">spring-cloud-netflix-hystrix-stream</code>和<code i="600">spring-cloud-starter-stream-*</code>添加依赖关系（有关经纪人的详细信息，请参阅Spring Cloud Stream文档，以及如何配置客户端凭据，但是应该为当地经纪人开箱即用）。</font></p>
</div>
<div class="paragraph">
<p><font o="1163">在服务器端只需创建一个Spring Boot应用程序并使用<code i="601">@EnableTurbineStream</code>进行注释，默认情况下将在8989端口（将您的Hystrix仪表板指向该端口，任何路径）。</font><font o="1164">您可以使用<code i="602">server.port</code>或<code i="603">turbine.stream.port</code>自定义端口。</font><font o="1165">如果类路径中还有<code i="604">spring-boot-starter-web</code>和<code i="605">spring-boot-starter-actuator</code>，那么您可以通过提供不同的<code i="606">management.port</code>在单独端口（默认情况下使用Tomcat）打开Actuator端点。</font></p>
</div>
<div class="paragraph">
<p><font o="1166">然后，您可以将Hystrix仪表板指向Turbine Stream服务器，而不是单个Hystrix流。</font><font o="1167">如果Turbine Stream在myhost上的端口8989上运行，则将<code i="607"><a href="http://myhost:8989/" class="bare">http://myhost:8989</a></code>放在Hystrix仪表板中的流输入字段中。</font><font o="1168">电路将以各自的serviceId为前缀，后跟一个点，然后是电路名称。</font></p>
</div>
<div class="paragraph">
<p><font o="1169">Spring Cloud提供了一个<code i="608">spring-cloud-starter-turbine-stream</code>，它具有您需要的Turbine Stream服务器运行所需的所有依赖项，只需添加您选择的Stream binder，例如<code i="609">spring-cloud-starter-stream-rabbit</code>。</font><font o="1170">您需要Java 8来运行应用程序，因为它是基于Netty的。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-ribbon"><font o="1171">客户端负载平衡器：Ribbon</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1172">Ribbon是一个客户端负载均衡器，它可以很好地控制HTTP和TCP客户端的行为。</font><font o="1173">Feign已经使用Ribbon，所以如果您使用<code i="610">@FeignClient</code>，则本节也适用。</font></p>
</div>
<div class="paragraph">
<p><font o="1174">Ribbon中的中心概念是指定客户端的概念。</font><font o="1175">每个负载平衡器是组合的组合的一部分，它们一起工作以根据需要联系远程服务器，并且集合具有您将其作为应用程序开发人员（例如使用<code i="611">@FeignClient</code>注释）的名称。</font><font o="1176">Spring Cloud使用<code i="613">RibbonClientConfiguration</code>为每个命名的客户端根据需要创建一个新的合奏作为<code i="612">ApplicationContext</code>。</font><font o="1177">这包含（除其他外）<code i="614">ILoadBalancer</code>，<code i="615">RestClient</code>和<code i="616">ServerListFilter</code>。</font></p>
</div>
<div class="sect2">
<h3 id="netflix-ribbon-starter"><font o="1178">如何加入Ribbon</font></h3>
<div class="paragraph">
<p><font o="1179">要在项目中包含Ribbon，请使用组<code i="617">org.springframework.cloud</code>和工件ID <code i="618">spring-cloud-starter-ribbon</code>的起始器。</font><font o="1180">有关</font><font o="1180">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1180">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1180">Spring Cloud项目页面</font></a><font o="1180">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_ribbon_client"><font o="1181">自定义Ribbon客户端</font></h3>
<div class="paragraph">
<p><font o="1182">您可以使用<code i="619">&lt;client&gt;.ribbon.*</code>中的外部属性来配置Ribbon客户端的某些位，这与使用Netflix API本身没有什么不同，只能使用Spring Boot配置文件。</font><font o="1183">本机选项可以在<code i="620">CommonClientConfigKey</code>（功能区内核心部分）中作为静态字段进行检查。</font></p>
</div>
<div class="paragraph">
<p><font o="1184">Spring Cloud还允许您通过使用<code i="622">@RibbonClient</code>声明其他配置（位于<code i="621">RibbonClientConfiguration</code>之上）来完全控制客户端。</font><font o="1185">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
@RibbonClient(name = "foo", configuration = FooConfiguration.class)
public class TestConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1186">在这种情况下，客户端由<code i="623">RibbonClientConfiguration</code>中已经存在的组件与<code i="624">FooConfiguration</code>中的任何组件组成（后者通常会覆盖前者）。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1187">警告</font></div>
</td>
<td class="content"><font o="1188">
<code i="625">FooConfiguration</code>必须是<code i="626">@Configuration</code>，但请注意，它不在主应用程序上下文的<code i="627">@ComponentScan</code>中，否则将由所有<code i="628">@RibbonClients</code>共享。</font><font o="1189">如果您使用<code i="629">@ComponentScan</code>（或<code i="630">@SpringBootApplication</code>），则需要采取措施避免包含（例如将其放在一个单独的，不重叠的包中，或者指定要在<code i="631">@ComponentScan</code>）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1190">Spring Cloud Netflix默认情况下为Ribbon（<code i="632">BeanType</code> beanName：<code i="633">ClassName</code>）提供以下bean：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1191"><code i="634">IClientConfig</code> ribbonClientConfig：<code i="635">DefaultClientConfigImpl</code></font></p>
</li>
<li>
<p><font o="1192"><code i="636">IRule</code> ribbonRule：<code i="637">ZoneAvoidanceRule</code></font></p>
</li>
<li>
<p><font o="1193"><code i="638">IPing</code> ribbonPing：<code i="639">NoOpPing</code></font></p>
</li>
<li>
<p><font o="1194"><code i="640">ServerList&lt;Server&gt;</code> ribbonServerList：<code i="641">ConfigurationBasedServerList</code></font></p>
</li>
<li>
<p><font o="1195"><code i="642">ServerListFilter&lt;Server&gt;</code> ribbonServerListFilter：<code i="643">ZonePreferenceServerListFilter</code></font></p>
</li>
<li>
<p><font o="1196"><code i="644">ILoadBalancer</code> ribbonLoadBalancer：<code i="645">ZoneAwareLoadBalancer</code></font></p>
</li>
<li>
<p><font o="1197"><code i="646">ServerListUpdater</code> ribbonServerListUpdater：<code i="647">PollingServerListUpdater</code></font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1198">创建一个类型的bean并将其放置在<code i="648">@RibbonClient</code>配置（例如上面的<code i="649">FooConfiguration</code>）中）允许您覆盖所描述的每个bean。</font><font o="1199">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
    public IPing ribbonPing(IClientConfig config) {
        return new PingUrl();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1200">这用<code i="651">PingUrl</code>代替<code i="650">NoOpPing</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_ribbon_client_using_properties"><font o="1201">使用属性自定义Ribbon客户端</font></h3>
<div class="paragraph">
<p><font o="1202">从版本1.2.0开始，Spring Cloud Netflix现在支持使用属性与</font><a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer"><font o="1202">Ribbon文档兼容来自</font></a><font o="1202">定义Ribbon客户端</font><font o="1202">。</font></p>
</div>
<div class="paragraph">
<p><font o="1203">这允许您在不同环境中更改启动时的行为。</font></p>
</div>
<div class="paragraph">
<p><font o="1204">支持的属性如下所示，应以<code i="652">&lt;clientName&gt;.ribbon.</code>为前缀：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1205"><code i="653">NFLoadBalancerClassName</code>：应实施<code i="654">ILoadBalancer</code></font></p>
</li>
<li>
<p><font o="1206"><code i="655">NFLoadBalancerRuleClassName</code>：应实施<code i="656">IRule</code></font></p>
</li>
<li>
<p><font o="1207"><code i="657">NFLoadBalancerPingClassName</code>：应实施<code i="658">IPing</code></font></p>
</li>
<li>
<p><font o="1208"><code i="659">NIWSServerListClassName</code>：应实施<code i="660">ServerList</code></font></p>
</li>
<li>
<p><font o="1209"><code i="661">NIWSServerListFilterClassName</code>应实施<code i="662">ServerListFilter</code></font></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1210">注意</font></div>
</td>
<td class="content"><font o="1211">
在这些属性中定义的类优先于使用<code i="663">@RibbonClient(configuration=MyRibbonConfig.class)</code>定义的bean和由Spring Cloud Netflix提供的默认值。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1212">要设置服务名称<code i="665">users</code>的<code i="664">IRule</code>，您可以设置以下内容：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1213">application.yml</font></div>
<div class="content">
<pre class="notranslate">users:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</pre>
</div>
</div>
<div class="paragraph">
<p><font o="1214">有关</font><a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers"><font o="1214">Ribbon</font></a><font o="1214">提供的实现，</font><font o="1214">请参阅</font><a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers"><font o="1214">Ribbon文档</font></a><font o="1214">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_using_ribbon_with_eureka"><font o="1215">在Eureka中使用Ribbon</font></h3>
<div class="paragraph">
<p><font o="1216">当Eureka与Ribbon结合使用（即两者都在类路径上）时，<code i="666">ribbonServerList</code>将被扩展为<code i="667">DiscoveryEnabledNIWSServerList</code>，扩展名为Eureka的服务器列表。</font><font o="1217">它还用<code i="669">NIWSDiscoveryPing</code>替换<code i="668">IPing</code>接口，代理到Eureka以确定服务器是否启动。</font><font o="1218">默认情况下安装的<code i="670">ServerList</code>是一个<code i="671">DomainExtractingServerList</code>，其目的是使物理元数据可用于负载平衡器，而不使用AWS AMI元数据（这是Netflix依赖的）。</font><font o="1219">默认情况下，服务器列表将使用实例元数据（如远程客户端集合<code i="672">eureka.instance.metadataMap.zone</code>）中提供的“区域”信息构建，如果缺少，则可以使用服务器主机名中的域名作为代理用于区域（如果设置了标志<code i="673">approximateZoneFromHostname</code>）。</font><font o="1220">一旦区域信息可用，它可以在<code i="674">ServerListFilter</code>中使用。</font><font o="1221">默认情况下，它将用于定位与客户端相同区域的服务器，因为默认值为<code i="675">ZonePreferenceServerListFilter</code>。</font><font o="1222">默认情况下，客户端的区域与远程实例的方式相同，即通过<code i="676">eureka.instance.metadataMap.zone</code>。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1223">注意</font></div>
</td>
<td class="content"><font o="1224">
设置客户端区域的正统“archaius”方式是通过一个名为“@zone”的配置属性，如果可用，Spring Cloud将优先使用所有其他设置（请注意，该键必须被引用）在YAML配置中）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1225">注意</font></div>
</td>
<td class="content"><font o="1226">
如果没有其他的区域数据源，则基于客户端配置（与实例配置相反）进行猜测。</font><font o="1227">我们将<code i="677">eureka.client.availabilityZones</code>（从区域名称映射到区域列表），并将实例自己的区域的第一个区域（即<code i="678">eureka.client.region</code>，其默认为“us-east-1”为与本机Netflix的兼容性）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-ribbon-without-eureka"><font o="1228">示例：如何使用Ribbon不使用Eureka</font></h3>
<div class="paragraph">
<p><font o="1229">Eureka是一种方便的方式来抽象远程服务器的发现，因此您不必在客户端中对其URL进行硬编码，但如果您不想使用它，Ribbon和Feign仍然是适用的。</font><font o="1230">假设您已经为“商店”申请了<code i="679">@RibbonClient</code>，并且Eureka未被使用（甚至不在类路径上）。</font><font o="1231">Ribbon客户端默认为已配置的服务器列表，您可以提供这样的配置</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1232">application.yml</font></div>
<div class="content">
<pre class="notranslate">stores:
  ribbon:
    listOfServers: example.com,google.com</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_example_disable_eureka_use_in_ribbon"><font o="1233">示例：在Ribbon中禁用Eureka使用</font></h3>
<div class="paragraph">
<p><font o="1234">设置属性<code i="680">ribbon.eureka.enabled = false</code>将明确禁用在Ribbon中使用Eureka。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1235">application.yml</font></div>
<div class="content">
<pre class="notranslate">ribbon:
  eureka:
   enabled: false</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_ribbon_api_directly"><font o="1236">直接使用Ribbon API</font></h3>
<div class="paragraph">
<p><font o="1237">您也可以直接使用<code i="681">LoadBalancerClient</code>。</font><font o="1238">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class MyClass {
    @Autowired
    private LoadBalancerClient loadBalancer;

    public void doStuff() {
        ServiceInstance instance = loadBalancer.choose("stores");
        URI storesUri = URI.create(String.format("http://%s:%s", instance.getHost(), instance.getPort()));
        // ... do something with the URI
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ribbon-child-context-eager-load"><font o="1239">缓存Ribbon配置</font></h3>
<div class="paragraph">
<p><font o="1240">每个Ribbon命名的客户端都有一个相应的子应用程序上下文，Spring Cloud维护，这个应用程序上下文在第一个请求中被延迟加载到命名的客户端。</font><font o="1241">可以通过指定Ribbon客户端的名称，在启动时，可以更改此延迟加载行为，从而热切加载这些子应用程序上下文。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1242">application.yml</font></div>
<div class="content">
<pre class="notranslate">ribbon:
  eager-load:
    enabled: true
    clients: client1, client2, client3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-feign"><font o="1243">声明性REST客户端：Feign</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/Netflix/feign"><font o="1244">Feign</font></a><font o="1244">是一个声明式的Web服务客户端。</font><font o="1245">这使得Web服务客户端的写入更加方便 </font><font o="1246">要使用Feign创建一个界面并对其进行注释。</font><font o="1247">它具有可插入注释支持，包括Feign注释和JAX-RS注释。</font><font o="1248">Feign还支持可插拔编码器和解码器。</font><font o="1249">Spring Cloud增加了对Spring MVC注释的支持，并使用Spring Web中默认使用的<code i="682">HttpMessageConverters</code>。</font><font o="1250">Spring Cloud集成Ribbon和Eureka以在使用Feign时提供负载均衡的http客户端。</font></p>
</div>
<div class="sect2">
<h3 id="netflix-feign-starter"><font o="1251">如何加入Feign</font></h3>
<div class="paragraph">
<p><font o="1252">要在您的项目中包含Feign，请使用组<code i="683">org.springframework.cloud</code>和工件ID <code i="684">spring-cloud-starter-feign</code>的启动器。</font><font o="1253">有关</font><font o="1253">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1253">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1253">Spring Cloud项目页面</font></a><font o="1253">。</font></p>
</div>
<div class="paragraph">
<p><font o="1254">示例spring boot应用</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
@ComponentScan
@EnableAutoConfiguration
@EnableEurekaClient
@EnableFeignClients
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><font o="1255">StoreClient.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient("stores")
public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    List&lt;Store&gt; getStores();

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathVariable("storeId") Long storeId, Store store);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1256">在<code i="685">@FeignClient</code>注释中，String值（以上“存储”）是一个任意的客户端名称，用于创建Ribbon负载平衡器（</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="1256">有关Ribbon支持的详细信息，</font></a><font o="1256">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon"><font o="1256">下文</font></a><font o="1256">））。</font><font o="1257">您还可以使用<code i="686">url</code>属性（绝对值或只是主机名）指定URL。</font><font o="1258">应用程序上下文中的bean的名称是该接口的完全限定名称。</font><font o="1259">要指定您自己的别名值，您可以使用<code i="688">@FeignClient</code>注释的<code i="687">qualifier</code>值。</font></p>
</div>
<div class="paragraph">
<p><font o="1260">以上的Ribbon客户端将会发现“商店”服务的物理地址。</font><font o="1261">如果您的应用程序是Eureka客户端，那么它将解析Eureka服务注册表中的服务。</font><font o="1262">如果您不想使用Eureka，您可以简单地配置外部配置中的服务器列表（</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka"><font o="1262">例如，</font></a><font o="1262">参见
 </font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka"><font o="1262">上文</font></a><font o="1262">）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-feign-overriding-defaults"><font o="1263">覆盖Feign默认值</font></h3>
<div class="paragraph">
<p><font o="1264">Spring Cloud的Feign支持的中心概念是指定的客户端。</font><font o="1265">每个假装客户端都是组合的组件的一部分，它们一起工作以根据需要联系远程服务器，并且该集合具有您将其作为应用程序开发人员使用<code i="689">@FeignClient</code>注释的名称。</font><font o="1266">Spring Cloud根据需要，使用<code i="691">FeignClientsConfiguration</code>为每个已命名的客户端创建一个新的集合<code i="690">ApplicationContext</code>。</font><font o="1267">这包含（除其他外）<code i="692">feign.Decoder</code>，<code i="693">feign.Encoder</code>和<code i="694">feign.Contract</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1268">Spring Cloud可以通过使用<code i="696">@FeignClient</code>声明额外的配置（<code i="695">FeignClientsConfiguration</code>）来完全控制假客户端。</font><font o="1269">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient(name = "stores", configuration = FooConfiguration.class)
public interface StoreClient {
    //..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1270">在这种情况下，客户端由<code i="697">FeignClientsConfiguration</code>中的组件与<code i="698">FooConfiguration</code>中的任何组件组成（后者将覆盖前者）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1271">注意</font></div>
</td>
<td class="content"><font o="1272">
<code i="699">FooConfiguration</code>不需要使用<code i="700">@Configuration</code>注释。</font><font o="1273">但是，如果是，则请注意将其从任何<code i="701">@ComponentScan</code>中排除，否则将包含此配置，因为它将成为<code i="702">feign.Decoder</code>，<code i="703">feign.Encoder</code>，<code i="704">feign.Contract</code>等的默认来源，指定时。</font><font o="1274">这可以通过将其放置在任何<code i="705">@ComponentScan</code>或<code i="706">@SpringBootApplication</code>的单独的不重叠的包中，或者可以在<code i="707">@ComponentScan</code>中明确排除。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1275">注意</font></div>
</td>
<td class="content"><font o="1276">
<code i="708">serviceId</code>属性现在已被弃用，有利于<code i="709">name</code>属性。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1277">警告</font></div>
</td>
<td class="content"><font o="1278">
以前，使用<code i="710">url</code>属性，不需要<code i="711">name</code>属性。</font><font o="1279">现在需要使用<code i="712">name</code>。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1280"><code i="713">name</code>和<code i="714">url</code>属性支持占位符。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient(name = "${feign.name}", url = "${feign.url}")
public interface StoreClient {
    //..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1281">Spring Cloud Netflix默认为feign（<code i="715">BeanType</code> beanName：<code i="716">ClassName</code>）提供以下bean：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1282"><code i="717">Decoder</code> feignDecoder：<code i="718">ResponseEntityDecoder</code>（其中包含<code i="719">SpringDecoder</code>）</font></p>
</li>
<li>
<p><font o="1283"><code i="720">Encoder</code> feignEncoder：<code i="721">SpringEncoder</code></font></p>
</li>
<li>
<p><font o="1284"><code i="722">Logger</code> feignLogger：<code i="723">Slf4jLogger</code></font></p>
</li>
<li>
<p><font o="1285"><code i="724">Contract</code> feignContract：<code i="725">SpringMvcContract</code></font></p>
</li>
<li>
<p><font o="1286"><code i="726">Feign.Builder</code> feignBuilder：<code i="727">HystrixFeign.Builder</code></font></p>
</li>
<li>
<p><font o="1287"><code i="728">Client</code> feignClient：如果Ribbon启用，则为<code i="729">LoadBalancerFeignClient</code>，否则将使用默认的feign客户端。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1288">可以通过将<code i="730">feign.okhttp.enabled</code>或<code i="731">feign.httpclient.enabled</code>设置为<code i="732">true</code>，并将它们放在类路径上来使用OkHttpClient和ApacheHttpClient feign客户端。</font></p>
</div>
<div class="paragraph">
<p><font o="1289">Spring Cloud Netflix </font><font o="1289">默认情况下</font><em><font o="1289">不</font></em><font o="1289">提供以下bean，但是仍然从应用程序上下文中查找这些类型的bean以创建假客户机：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Logger.Level</code></p>
</li>
<li>
<p><code>Retryer</code></p>
</li>
<li>
<p><code>ErrorDecoder</code></p>
</li>
<li>
<p><code>Request.Options</code></p>
</li>
<li>
<p><code>Collection&lt;RequestInterceptor&gt;</code></p>
</li>
<li>
<p><code>SetterFactory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1290">创建一个类型的bean并将其放置在<code i="733">@FeignClient</code>配置（例如上面的<code i="734">FooConfiguration</code>）中）允许您覆盖所描述的每个bean。</font><font o="1291">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
    public Contract feignContract() {
        return new feign.Contract.Default();
    }

    @Bean
    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        return new BasicAuthRequestInterceptor("user", "password");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1292">这将<code i="735">SpringMvcContract</code>替换为<code i="736">feign.Contract.Default</code>，并将<code i="737">RequestInterceptor</code>添加到<code i="738">RequestInterceptor</code>的集合中。</font></p>
</div>
<div class="paragraph">
<p><font o="1293">可以在<code i="739">@EnableFeignClients</code>属性<code i="740">defaultConfiguration</code>中以与上述相似的方式指定默认配置。</font><font o="1294">不同之处在于，此配置将适用于</font><em><font o="1294">所有</font></em><font o="1294">假客户端。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1295">注意</font></div>
</td>
<td class="content"><font o="1296">
如果您需要在<code i="742">RequestInterceptor`s you will need to either set the
thread isolation strategy for Hystrix to `SEMAPHORE</code>中使用<code i="741">ThreadLocal</code>绑定变量，或在Feign中禁用Hystrix。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1297">application.yml</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"># To disable Hystrix in Feign
feign:
  hystrix:
    enabled: false

# To set thread isolation to SEMAPHORE
hystrix:
  command:
    default:
      execution:
        isolation:
          strategy: SEMAPHORE</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_feign_clients_manually"><font o="1298">手动创建Feign客户端</font></h3>
<div class="paragraph">
<p><font o="1299">在某些情况下，可能需要以上述方法不可能自定义您的Feign客户端。</font><font o="1300">在这种情况下，您可以使用</font><a href="https://github.com/OpenFeign/feign/#basics"><font o="1300">Feign Builder API</font></a><font o="1300">创建客户端
 </font><font o="1300">。</font><font o="1301">下面是一个创建两个具有相同接口的Feign客户端的示例，但是使用单独的请求拦截器配置每个客户端。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Import(FeignClientsConfiguration.class)
class FooController {

	private FooClient fooClient;

	private FooClient adminClient;

    @Autowired
	public FooController(
			Decoder decoder, Encoder encoder, Client client) {
		this.fooClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(new BasicAuthRequestInterceptor("user", "user"))
				.target(FooClient.class, "http://PROD-SVC");
		this.adminClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.requestInterceptor(new BasicAuthRequestInterceptor("admin", "admin"))
				.target(FooClient.class, "http://PROD-SVC");
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1302">注意</font></div>
</td>
<td class="content"><font o="1303">
在上面的例子中，<code i="743">FeignClientsConfiguration.class</code>是Spring Cloud Netflix提供的默认配置。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1304">注意</font></div>
</td>
<td class="content"><font o="1305">
<code i="744">PROD-SVC</code>是客户端将要求的服务的名称。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-feign-hystrix"><font o="1306">Feign Hystrix支持</font></h3>
<div class="paragraph">
<p><font o="1307">如果Hystrix在类路径上，<code i="745">feign.hystrix.enabled=true</code>，Feign将用断路器包装所有方法。</font><font o="1308">还可以返回<code i="746">com.netflix.hystrix.HystrixCommand</code>。</font><font o="1309">这样就可以使用无效模式（调用<code i="747">.toObservable()</code>或<code i="748">.observe()</code>或异步使用（调用<code i="749">.queue()</code>））。</font></p>
</div>
<div class="paragraph">
<p><font o="1310">要在每个客户端基础上禁用Hystrix支持创建一个带有“原型”范围的香草<code i="750">Feign.Builder</code>，例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
	@Scope("prototype")
	public Feign.Builder feignBuilder() {
		return Feign.builder();
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1311">警告</font></div>
</td>
<td class="content"><font o="1312">
在Spring Cloud达尔斯顿发布之前，如果Hystrix在类路径Feign中默认将所有方法包装在断路器中。</font><font o="1313">这种默认行为在Spring Cloud达尔斯顿改变了赞成选择加入的方式。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-feign-hystrix-fallback"><font o="1314">Feign Hystrix回退</font></h3>
<div class="paragraph">
<p><font o="1315">Hystrix支持回退的概念：当电路断开或出现错误时执行的默认代码路径。</font><font o="1316">要为给定的<code i="751">@FeignClient</code>启用回退，请将<code i="752">fallback</code>属性设置为实现回退的类名。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient(name = "hello", fallback = HystrixClientFallback.class)
protected interface HystrixClient {
    @RequestMapping(method = RequestMethod.GET, value = "/hello")
    Hello iFailSometimes();
}

static class HystrixClientFallback implements HystrixClient {
    @Override
    public Hello iFailSometimes() {
        return new Hello("fallback");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1317">如果需要访问导致回退触发的原因，可以使用<code i="754">@FeignClient</code>内的<code i="753">fallbackFactory</code>属性。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient(name = "hello", fallbackFactory = HystrixClientFallbackFactory.class)
protected interface HystrixClient {
	@RequestMapping(method = RequestMethod.GET, value = "/hello")
	Hello iFailSometimes();
}

@Component
static class HystrixClientFallbackFactory implements FallbackFactory&lt;HystrixClient&gt; {
	@Override
	public HystrixClient create(Throwable cause) {
		return new HystrixClientWithFallBackFactory() {
			@Override
			public Hello iFailSometimes() {
				return new Hello("fallback; reason was: " + cause.getMessage());
			}
		};
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1318">警告</font></div>
</td>
<td class="content"><font o="1319">
在Feign中执行回退以及Hystrix回退的工作方式存在局限性。</font><font o="1320">当前返回<code i="755">com.netflix.hystrix.HystrixCommand</code>和<code i="756">rx.Observable</code>的方法目前不支持回退。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_feign_and_code_primary_code"><font o="1321">Feign和<code i="757">@Primary</code></font></h3>
<div class="paragraph">
<p><font o="1322">当使用Feign与Hystrix回退时，在同一类型的<code i="758">ApplicationContext</code>中有多个bean。</font><font o="1323">这将导致<code i="759">@Autowired</code>不起作用，因为没有一个bean，或者标记为主。</font><font o="1324">要解决这个问题，Spring Cloud Netflix将所有Feign实例标记为<code i="760">@Primary</code>，所以Spring Framework将知道要注入哪个bean。</font><font o="1325">在某些情况下，这可能是不可取的。</font><font o="1326">要关闭此行为，将<code i="762">@FeignClient</code>的<code i="761">primary</code>属性设置为false。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@FeignClient(name = "hello", primary = false)
public interface HelloClient {
	// methods here
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-feign-inheritance"><font o="1327">Feign继承支持</font></h3>
<div class="paragraph">
<p><font o="1328">Feign通过单继承接口支持样板apis。</font><font o="1329">这样就可以将常用操作分成方便的基本界面。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1330">UserService.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface UserService {

    @RequestMapping(method = RequestMethod.GET, value ="/users/{id}")
    User getUser(@PathVariable("id") long id);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><font o="1331">UserResource.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RestController
public class UserResource implements UserService {

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><font o="1332">UserClient.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package project.user;

@FeignClient("users")
public interface UserClient extends UserService {

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1333">注意</font></div>
</td>
<td class="content"><font o="1334">
通常不建议在服务器和客户端之间共享接口。</font><font o="1335">它引入了紧耦合，并且实际上并不适用于当前形式的Spring MVC（方法参数映射不被继承）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_feign_request_response_compression"><font o="1336">Feign请求/响应压缩</font></h3>
<div class="paragraph">
<p><font o="1337">您可以考虑为Feign请求启用请求或响应GZIP压缩。</font><font o="1338">您可以通过启用其中一个属性来执行此操作：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">feign.compression.request.enabled=true
feign.compression.response.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1339">Feign请求压缩为您提供与您为Web服务器设置的设置相似的设置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=2048</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1340">这些属性可以让您对压缩介质类型和最小请求阈值长度有选择性。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_feign_logging"><font o="1341">Feign日志记录</font></h3>
<div class="paragraph">
<p><font o="1342">为每个创建的Feign客户端创建一个记录器。</font><font o="1343">默认情况下，记录器的名称是用于创建Feign客户端的接口的完整类名。</font><font o="1344">Feign日志记录仅响应<code i="763">DEBUG</code>级别。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1345">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">logging.level.project.user.UserClient: DEBUG</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1346">您可以为每个客户端配置的<code i="764">Logger.Level</code>对象告诉Feign记录多少。</font><font o="1347">选择是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1348"><code i="765">NONE</code>，无记录（</font><strong><font o="1348">DEFAULT</font></strong><font o="1348">）。</font></p>
</li>
<li>
<p><font o="1349"><code i="766">BASIC</code>，只记录请求方法和URL以及响应状态代码和执行时间。</font></p>
</li>
<li>
<p><font o="1350"><code i="767">HEADERS</code>，记录基本信息以及请求和响应标头。</font></p>
</li>
<li>
<p><font o="1351"><code i="768">FULL</code>，记录请求和响应的头文件，正文和元数据。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1352">例如，以下将<code i="769">Logger.Level</code>设置为<code i="770">FULL</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_external_configuration_archaius"><font o="1353">外部配置：Archaius</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/Netflix/archaius"><font></font></a><font o="1354">Netflix客户端配置库</font><a href="https://github.com/Netflix/archaius"><font o="1354">Archaius </font></a><font o="1355">它是所有Netflix OSS组件用于配置的库。</font><font o="1356">Archaius是</font><a href="https://commons.apache.org/proper/commons-configuration"><font o="1356">Apache Commons Configuration</font></a><font o="1356">项目的</font><a href="https://commons.apache.org/proper/commons-configuration"><font o="1356">扩展</font></a><font o="1356">。</font><font o="1357">它允许通过轮询源进行更改或将源更改推送到客户端来进行配置更新。</font><font o="1358">Archaius使用Dynamic &lt;Type&gt; Property类作为属性的句柄。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1359">Archaius示例</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">class ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty("my.prop");

    void doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1360">Archaius具有自己的一组配置文件和加载优先级。</font><font o="1361">Spring应用程序一般不应直接使用Archaius，但本地仍然需要配置Netflix工具。</font><font o="1362">Spring Cloud具有Spring环境桥，所以Archaius可以从Spring环境读取属性。</font><font o="1363">这允许Spring Boot项目使用正常的配置工具链，同时允许他们在文档中大部分配置Netflix工具。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_router_and_filter_zuul"><font o="1364">路由器和过滤器：Zuul</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1365">路由在微服务体系结构的一个组成部分。</font><font o="1366">例如，<code i="771">/</code>可以映射到您的Web应用程序，<code i="772">/api/users</code>映射到用户服务，并将<code i="773">/api/shop</code>映射到商店服务。</font><a href="https://github.com/Netflix/zuul"><font o="1367">Zuul</font></a><font o="1367">是Netflix的基于JVM的路由器和服务器端负载均衡器。</font></p>
</div>
<div class="paragraph">
<p><a href="http://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27"><font o="1368">Netflix使用Zuul</font></a><font o="1368">进行以下操作：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1369">认证</font></p>
</li>
<li>
<p><font o="1370">洞察</font></p>
</li>
<li>
<p><font o="1371">压力测试</font></p>
</li>
<li>
<p><font o="1372">金丝雀测试</font></p>
</li>
<li>
<p><font o="1373">动态路由</font></p>
</li>
<li>
<p><font o="1374">服务迁移</font></p>
</li>
<li>
<p><font o="1375">负载脱落</font></p>
</li>
<li>
<p><font o="1376">安全</font></p>
</li>
<li>
<p><font o="1377">静态响应处理</font></p>
</li>
<li>
<p><font o="1378">主动/主动流量管理</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1379">Zuul的规则引擎允许基本上写任何JVM语言编写规则和过滤器，内置Java和Groovy。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1380">注意</font></div>
</td>
<td class="content"><font o="1381">
配置属性<code i="774">zuul.max.host.connections</code>已被两个新属性<code i="775">zuul.host.maxTotalConnections</code>和<code i="776">zuul.host.maxPerRouteConnections</code>替换，分别默认为200和20。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1382">注意</font></div>
</td>
<td class="content"><font o="1383">
所有路由的默认Hystrix隔离模式（ExecutionIsolationStrategy）为SEMAPHORE。</font><font o="1384">如果此隔离模式是首选，则<code i="777">zuul.ribbonIsolationStrategy</code>可以更改为THREAD。
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="netflix-zuul-starter"><font o="1385">如何加入Zuul</font></h3>
<div class="paragraph">
<p><font o="1386">要在您的项目中包含Zuul，请使用组<code i="778">org.springframework.cloud</code>和artifact id <code i="779">spring-cloud-starter-zuul</code>的启动器。</font><font o="1387">有关</font><font o="1387">
使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="1387">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="1387">Spring Cloud项目页面</font></a><font o="1387">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="netflix-zuul-reverse-proxy"><font o="1388">嵌入式Zuul反向代理</font></h3>
<div class="paragraph">
<p><font o="1389">Spring Cloud已经创建了一个嵌入式Zuul代理，以简化UI应用程序想要代理对一个或多个后端服务的呼叫的非常常见的用例的开发。</font><font o="1390">此功能对于用户界面对其所需的后端服务进行代理是有用的，避免了对所有后端独立管理CORS和验证问题的需求。</font></p>
</div>
<div class="paragraph">
<p><font o="1391">要启用它，使用<code i="780">@EnableZuulProxy</code>注释Spring Boot主类，并将本地调用转发到相应的服务。</font><font o="1392">按照惯例，具有ID“用户”的服务将接收来自位于<code i="781">/users</code>（具有前缀stripped）的代理的请求。</font><font o="1393">代理使用Ribbon来定位一个通过发现转发的实例，并且所有请求都以
 </font><a href="https://springcloud.cc/spring-cloud-dalston.html#hystrix-fallbacks-for-routes"><font o="1393">hystrix命令执行</font></a><font o="1393">，所以故障将显示在Hystrix指标中，一旦电路打开，代理将不会尝试联系服务。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1394">注意</font></div>
</td>
<td class="content"><font o="1395">
Zuul启动器不包括发现客户端，因此对于基于服务ID的路由，您还需要在类路径中提供其中一个路由（例如Eureka）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1396">要跳过自动添加的服务，请将<code i="782">zuul.ignored-services</code>设置为服务标识模式列表。</font><font o="1397">如果一个服务匹配一个被忽略的模式，而且包含在明确配置的路由映射中，那么它将被无符号。</font><font o="1398">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1399">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  ignoredServices: '*'
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1400">在此示例中，</font><strong><font o="1400">除</font></strong><font o="1400"> “用户” </font><strong><font o="1400">之外</font></strong><font o="1400">，所有服务都被忽略</font><font o="1400">。</font></p>
</div>
<div class="paragraph">
<p><font o="1401">要扩充或更改代理路由，可以添加如下所示的外部配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1402">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1403">这意味着对“/ myusers”的http呼叫转发到“用户”服务（例如“/ myusers / 101”转发到“/ 101”）。</font></p>
</div>
<div class="paragraph">
<p><font o="1404">要获得对路由的更细粒度的控制，您可以独立地指定路径和serviceId：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1405">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users_service</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1406">这意味着对“/ myusers”的http呼叫转发到“users_service”服务。</font><font o="1407">路由必须有一个“路径”，可以指定为蚂蚁样式模式，所以“/ myusers / *”只匹配一个级别，但“/ myusers / **”分层匹配。</font></p>
</div>
<div class="paragraph">
<p><font o="1408">后端的位置可以被指定为“serviceId”（用于发现的服务）或“url”（对于物理位置），例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1409">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      url: http://example.com/users_service</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1410">这些简单的URL路由不会被执行为<code i="783">HystrixCommand</code>，也不能使用Ribbon对多个URL进行负载平衡。</font><font o="1411">为此，请指定service-route并为serviceId配置Ribbon客户端（目前需要在Ribbon中禁用Eureka支持：详见</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbon-without-eureka"><font o="1411">上文</font></a><font o="1411">），例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1412">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users

ribbon:
  eureka:
    enabled: false

users:
  ribbon:
    listOfServers: example.com,google.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1413">您可以使用regexmapper在serviceId和路由之间提供约定。</font><font o="1414">它使用名为group的正则表达式从serviceId中提取变量并将它们注入到路由模式中。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1415">ApplicationConfiguration.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
public PatternServiceRouteMapper serviceRouteMapper() {
    return new PatternServiceRouteMapper(
        "(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)",
        "${version}/${name}");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1416">这意味着serviceId“myusers-v1”将被映射到路由“/ v1 / myusers / **”。</font><font o="1417">任何正则表达式都被接受，但所有命名组都必须存在于servicePattern和routePattern中。</font><font o="1418">如果servicePattern与serviceId不匹配，则使用默认行为。</font><font o="1419">在上面的示例中，serviceId“myusers”将被映射到路由“/ myusers / **”（检测不到版本）此功能默认禁用，仅适用于已发现的服务。</font></p>
</div>
<div class="paragraph">
<p><font o="1420">要为所有映射添加前缀，请将<code i="784">zuul.prefix</code>设置为一个值，例如<code i="785">/api</code>。</font><font o="1421">默认情况下，请求被转发之前，代理前缀被删除（使用<code i="786">zuul.stripPrefix=false</code>关闭此行为）。</font><font o="1422">您还可以关闭从各路线剥离服务特定的前缀，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1423">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      stripPrefix: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1424">注意</font></div>
</td>
<td class="content"><font o="1425">
<code i="787">zuul.stripPrefix</code>仅适用于<code i="788">zuul.prefix</code>中设置的前缀。</font><font o="1426">它对给定路由<code i="789">path</code>中定义的前缀有影响。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1427">在本示例中，对“/ myusers / 101”的请求将转发到“/ myusers / 101”上的“users”服务。</font></p>
</div>
<div class="paragraph">
<p><font o="1428"><code i="790">zuul.routes</code>条目实际上绑定到类型为<code i="791">ZuulProperties</code>的对象。</font><font o="1429">如果您查看该对象的属性，您将看到它还具有“可重试”标志。</font><font o="1430">将该标志设置为“true”使Ribbon客户端自动重试失败的请求（如果需要，可以使用Ribbon客户端配置修改重试操作的参数）。</font></p>
</div>
<div class="paragraph">
<p><font o="1431">默认情况下，将<code i="792">X-Forwarded-Host</code>标头添加到转发的请求中。</font><font o="1432">关闭set <code i="793">zuul.addProxyHeaders = false</code>。</font><font o="1433">默认情况下，前缀路径被删除，对后端的请求会拾取一个标题“X-Forwarded-Prefix”（上述示例中的“/ myusers”）。</font></p>
</div>
<div class="paragraph">
<p><font o="1434">如果您设置默认路由（“/”），则<code i="794">@EnableZuulProxy</code>的应用程序可以作为独立服务器，例如<code i="795">zuul.route.home:
/</code>将路由所有流量（即“/ **”）到“home”服务。</font></p>
</div>
<div class="paragraph">
<p><font o="1435">如果需要更细粒度的忽略，可以指定要忽略的特定模式。</font><font o="1436">在路由位置处理开始时评估这些模式，这意味着前缀应包含在模式中以保证匹配。</font><font o="1437">忽略的模式跨越所有服务，并取代任何其他路由规范。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1438">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  ignoredPatterns: /**/admin/**
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1439">这意味着诸如“/ myusers / 101”的所有呼叫将被转发到“用户”服务上的“/ 101”。</font><font o="1440">但是包含“/ admin /”的呼叫将无法解决。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1441">警告</font></div>
</td>
<td class="content"><font o="1442">
如果您需要您的路由保留订单，则需要使用YAML文件，因为使用属性文件将会丢失订购。</font><font o="1443">例如：
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title"><font o="1444">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
    legacy:
      path: /**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1445">如果要使用属性文件，则<code i="796">legacy</code>路径可能会在<code i="797">users</code>路径前面展开，从而使<code i="798">users</code>路径不可达。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_zuul_http_client"><font o="1446">Zuul Http客户端</font></h3>
<div class="paragraph">
<p><font o="1447">zuul使用的默认HTTP客户端现在由Apache HTTP Client支持，而不是不推荐使用的Ribbon <code i="799">RestClient</code>。</font><font o="1448">要分别使用<code i="800">RestClient</code>或使用<code i="801">okhttp3.OkHttpClient</code>集合<code i="802">ribbon.restclient.enabled=true</code>或<code i="803">ribbon.okhttp.enabled=true</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_cookies_and_sensitive_headers"><font o="1449">Cookie和敏感标题</font></h3>
<div class="paragraph">
<p><font o="1450">在同一个系统中的服务之间共享标题是可行的，但是您可能不希望敏感标头泄漏到外部服务器的下游。</font><font o="1451">您可以在路由配置中指定被忽略头文件列表。</font><font o="1452">Cookies起着特殊的作用，因为它们在浏览器中具有明确的语义，并且它们总是被视为敏感的。</font><font o="1453">如果代理的消费者是浏览器，则下游服务的cookie也会导致用户出现问题，因为它们都被混淆（所有下游服务看起来都是来自同一个地方）。</font></p>
</div>
<div class="paragraph">
<p><font o="1454">如果您对服务的设计非常谨慎，例如，如果只有一个下游服务设置了Cookie，那么您可能可以让他们从后台一直到调用者。</font><font o="1455">另外，如果您的代理设置cookie和所有后台服务都是同一系统的一部分，那么简单地共享它们就可以自然（例如使用Spring Session将它们链接到一些共享状态）。</font><font o="1456">除此之外，由下游服务设置的任何Cookie可能对呼叫者来说都不是很有用，因此建议您将（至少）“Set-Cookie”和“Cookie”设置为不属于您的域名。</font><font o="1457">即使</font><strong><font o="1457">是</font></strong><font o="1457">属于您域名</font><font o="1457">的路线</font><font o="1457">，请尝试仔细考虑允许Cookie在代理之间流动的含义。</font></p>
</div>
<div class="paragraph">
<p><font o="1458">灵敏头可以配置为每个路由的逗号分隔列表，例如</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1459">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders: Cookie,Set-Cookie,Authorization
      url: https://downstream</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1460">注意</font></div>
</td>
<td class="content"><font o="1461">
这是<code i="804">sensitiveHeaders</code>的默认值，因此您不需要设置它，除非您希望它不同。</font><font o="1462">注意这是Spring Cloud Netflix 1.1中的新功能（1.0中，用户无法控制标题，所有Cookie都在两个方向上流动）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1463"><code i="805">sensitiveHeaders</code>是一个黑名单，默认值不为空，所以要使Zuul发送所有标题（“被忽略”除外），您必须将其显式设置为空列表。</font><font o="1464">如果您要将Cookie或授权标头传递到后端，这是必要的。</font><font o="1465">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1466">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders:
      url: https://downstream</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1467">也可以通过设置<code i="806">zuul.sensitiveHeaders</code>来全局设置敏感标题。</font><font o="1468">如果在路由上设置<code i="807">sensitiveHeaders</code>，则将覆盖全局<code i="808">sensitiveHeaders</code>设置。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_ignored_headers"><font o="1469">被忽略的标题</font></h3>
<div class="paragraph">
<p><font o="1470">除了每个路由的敏感标头，您还可以为与下游服务交互期间应该丢弃的值（请求和响应）设置全局值为<code i="809">zuul.ignoredHeaders</code>。</font><font o="1471">默认情况下，如果Spring安全性不在类路径上，则它们是空的，否则它们被初始化为由Spring Security指定的一组众所周知的“安全性”头（例如涉及缓存）。</font><font o="1472">在这种情况下的假设是下游服务可能也添加这些头，我们希望代理的值。</font><font o="1473">为了不丢弃这些众所周知的安全标头，只要Spring安全性在类路径上，您可以将<code i="810">zuul.ignoreSecurityHeaders</code>设置为<code i="811">false</code>。</font><font o="1474">如果您禁用Spring安全性中的HTTP安全性响应头，并希望由下游服务提供的值，这可能很有用</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_the_routes_endpoint"><font o="1475">路线端点</font></h3>
<div class="paragraph">
<p><font o="1476">如果您在Spring Boot执行器中使用<code i="812">@EnableZuulProxy</code>，您将启用（默认情况下）另一个端点，通过HTTP可用<code i="813">/routes</code>。</font><font o="1477">到此端点的GET将返回映射路由的列表。</font><font o="1478">POST将强制刷新现有路由（例如，如果服务目录中有更改）。</font><font o="1479">您可以通过将<code i="814">endpoints.routes.enabled</code>设置为<code i="815">false</code>来禁用此端点。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1480">注意</font></div>
</td>
<td class="content"><font o="1481">
路由应自动响应服务目录中的更改，但POST到/路由是强制更改立即发生的一种方式。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_strangulation_patterns_and_local_forwards"><font o="1482">扼杀模式和本地前进</font></h3>
<div class="paragraph">
<p><font o="1483">迁移现有应用程序或API时的常见模式是“扼杀”旧端点，用不同的实现慢慢替换它们。</font><font o="1484">Zuul代理是一个有用的工具，因为您可以使用它来处理来自旧端点的客户端的所有流量，但将一些请求重定向到新端点。</font></p>
</div>
<div class="paragraph">
<p><font o="1485">示例配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1486">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    first:
      path: /first/**
      url: http://first.example.com
    second:
      path: /second/**
      url: forward:/second
    third:
      path: /third/**
      url: forward:/3rd
    legacy:
      path: /**
      url: http://legacy.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1487">在这个例子中，我们扼杀了“遗留”应用程序，该应用程序映射到所有与其他模式不匹配的请求。</font><font o="1488"><code i="816">/first/**</code>中的路径已被提取到具有外部URL的新服务中。</font><font o="1489">并且<code i="817">/second/**</code>中的路径被转发，以便它们可以在本地处理，例如具有正常的Spring <code i="818">@RequestMapping</code>。</font><font o="1490"><code i="819">/third/**</code>中的路径也被转发，但具有不同的前缀（即<code i="820">/third/foo</code>转发到<code i="821">/3rd/foo</code>）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1491">注意</font></div>
</td>
<td class="content"><font o="1492">
被忽略的模式并不完全被忽略，它们只是不被代理处理（因此它们也被有效地转发到本地）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_uploading_files_through_zuul"><font o="1493">通过Zuul上传文件</font></h3>
<div class="paragraph">
<p><font o="1494">如果您<code i="822">@EnableZuulProxy</code>您可以使用代理路径上传文件，只要文件很小，它就应该工作。</font><font o="1495">对于大文件，有一个替代路径绕过“/ zuul / *”中的Spring <code i="823">DispatcherServlet</code>（以避免多部分处理）。</font><font o="1496">也就是说，如果<code i="824">zuul.routes.customers=/customers/**</code>则可以将大文件发送到“/ zuul / customers / *”。</font><font o="1497">servlet路径通过<code i="825">zuul.servletPath</code>进行外部化。</font><font o="1498">如果代理路由引导您通过Ribbon负载均衡器，例如，超大文件也将需要提升超时设置</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1499">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 60000</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1500">请注意，要使用大型文件进行流式传输，您需要在请求中使用分块编码（某些浏览器默认情况下不会执行）。</font><font o="1501">例如在命令行：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ curl -v -H "Transfer-Encoding: chunked" \
    -F "file=@mylarge.iso" localhost:9999/zuul/simple/file</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_string_encoding"><font o="1502">查询字符串编码</font></h3>
<div class="paragraph">
<p><font o="1503">处理传入的请求时，查询参数被解码，因此可以在Zuul过滤器中进行修改。</font><font o="1504">然后在路由过滤器中构建后端请求时重新编码它们。</font><font o="1505">如果使用Javascript的<code i="826">encodeURIComponent()</code>方法编码，结果可能与原始输入不同。</font><font o="1506">虽然这在大多数情况下不会出现任何问题，但一些Web服务器可以用复杂查询字符串的编码来挑选。</font></p>
</div>
<div class="paragraph">
<p><font o="1507">要强制查询字符串的原始编码，可以将特殊标志传递给<code i="827">ZuulProperties</code>，以便查询字符串与<code i="828">HttpServletRequest::getQueryString</code>方法相同：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1508">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  forceOriginalQueryStringEncoding: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="1509">注意：</font></strong><font o="1509">此特殊标志仅适用于<code i="829">SimpleHostRoutingFilter</code>，您可以使用<code i="830">RequestContext.getCurrentContext().setRequestQueryParams(someOverriddenParameters)</code>轻松覆盖查询参数，因为查询字符串现在直接在原始的<code i="831">HttpServletRequest</code>上获取。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_plain_embedded_zuul"><font o="1510">普通嵌入Zuul</font></h3>
<div class="paragraph">
<p><font o="1511">如果您使用<code i="832">@EnableZuulServer</code>（而不是<code i="833">@EnableZuulProxy</code>），您也可以运行不带代理的Zuul服务器，或者有选择地切换代理平台的部分。</font><font o="1512">您添加到<code i="834">ZuulFilter</code>类型的应用程序的任何bean都将自动安装，与<code i="835">@EnableZuulProxy</code>一样，但不会自动添加任何代理过滤器。</font></p>
</div>
<div class="paragraph">
<p><font o="1513">在这种情况下，仍然通过配置“zuul.routes。*”来指定进入Zuul服务器的路由，但没有服务发现和代理，所以“serviceId”和“url”设置将被忽略。</font><font o="1514">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1515">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml"> zuul:
  routes:
    api: /api/**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1516">将“/ api / **”中的所有路径映射到Zuul过滤器链。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_disable_zuul_filters"><font o="1517">禁用Zuul过滤器</font></h3>
<div class="paragraph">
<p><font o="1518">Spring Cloud的Zuul在代理和服务器模式下默认启用了多个<code i="836">ZuulFilter</code> bean。</font><font o="1519">有关</font><font o="1519">启用的可能过滤器，</font><font o="1519">请参阅</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters"><font o="1519">zuul过滤器包</font></a><font o="1519">。</font><font o="1520">如果要禁用它，只需设置<code i="837">zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</code>。</font><font o="1521">按照惯例，<code i="838">filters</code>之后的包是Zuul过滤器类型。</font><font o="1522">例如，禁用<code i="839">org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code>设置<code i="840">zuul.SendResponseFilter.post.disable=true</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="hystrix-fallbacks-for-routes"><font o="1523">为路线提供Hystrix回退</font></h3>
<div class="paragraph">
<p><font o="1524">当Zuul中给定路由的电路跳闸时，您可以通过创建类型为<code i="841">ZuulFallbackProvider</code>的bean来提供回退响应。</font><font o="1525">在这个bean中，您需要指定回退的路由ID，并提供返回的<code i="842">ClientHttpResponse</code>作为后备。</font><font o="1526">这是一个非常简单的<code i="843">ZuulFallbackProvider</code>实现。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">class MyFallbackProvider implements ZuulFallbackProvider {
    @Override
    public String getRoute() {
        return "customers";
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1527">这里是路由配置的样子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">zuul:
  routes:
    customers: /customers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1528">如果您希望为所有路由提供默认的回退，您可以创建一个类型为<code i="844">ZuulFallbackProvider</code>的bean，并且<code i="845">getRoute</code>方法返回<code i="846">*</code>或<code i="847">null</code>。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">class MyFallbackProvider implements ZuulFallbackProvider {
    @Override
    public String getRoute() {
        return "*";
    }

    @Override
    public ClientHttpResponse fallbackResponse() {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zuul-developer-guide"><font o="1529">Zuul开发人员指南</font></h3>
<div class="paragraph">
<p><font o="1530">有关Zuul如何工作的一般概述，请参阅</font><a href="https://github.com/Netflix/zuul/wiki/How-it-Works"><font o="1530">Zuul维基</font></a><font o="1530">。</font></p>
</div>
<div class="sect3">
<h4 id="_the_zuul_servlet"><font o="1531">Zuul Servlet</font></h4>
<div class="paragraph">
<p><font o="1532">Zuul被实现为Servlet。</font><font o="1533">对于一般情况，Zuul嵌入到Spring调度机制中。</font><font o="1534">这允许Spring MVC控制路由。</font><font o="1535">在这种情况下，Zuul被配置为缓冲请求。</font><font o="1536">如果需要通过Zuul不缓冲请求（例如大文件上传），Servlet也将安装在Spring调度程序之外。</font><font o="1537">默认情况下，它位于<code i="848">/zuul</code>。</font><font o="1538">可以使用<code i="849">zuul.servlet-path</code>属性更改此路径。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_zuul_requestcontext"><font o="1539">Zuul RequestContext</font></h4>
<div class="paragraph">
<p><font o="1540">要在过滤器之间传递信息，Zuul使用a </font><a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java"><code>RequestContext</code></a><font o="1540">。</font><font o="1541">其数据按照每个请求的<code i="850">ThreadLocal</code>进行。</font><font o="1542">关于路由请求，错误以及实际<code i="851">HttpServletRequest</code>和<code i="852">HttpServletResponse</code>的路由信息​​。</font><font o="1543"><code i="853">RequestContext</code>扩展<code i="854">ConcurrentHashMap</code>，所以任何东西都可以存储在上下文中。</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/support/FilterConstants.java"><code>FilterConstants</code></a><font o="1544">包含由Spring Cloud Netflix安装的过滤器使用的密钥（稍后再安装）。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="__code_enablezuulproxy_code_vs_code_enablezuulserver_code"><font o="1545"><code i="855">@EnableZuulProxy</code>与<code i="856">@EnableZuulServer</code></font></h4>
<div class="paragraph">
<p><font o="1546">Spring Cloud Netflix根据使用何种注释来启用Zuul安装多个过滤器。</font><font o="1547"><code i="857">@EnableZuulProxy</code>是<code i="858">@EnableZuulServer</code>的超集。</font><font o="1548">换句话说，<code i="859">@EnableZuulProxy</code>包含<code i="860">@EnableZuulServer</code>安装的所有过滤器。</font><font o="1549">“代理”中的其他过滤器启用路由功能。</font><font o="1550">如果你想要一个“空白”Zuul，你应该使用<code i="861">@EnableZuulServer</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="__code_enablezuulserver_code_filters"><font o="1551"><code i="862">@EnableZuulServer</code>过滤器</font></h4>
<div class="paragraph">
<p><font o="1552">创建从Spring Boot配置文件加载路由定义的<code i="863">SimpleRouteLocator</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1553">安装了以下过滤器（正常Spring豆类）：</font></p>
</div>
<div class="paragraph">
<p><font o="1554">前置过滤器</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1555"><code i="864">ServletDetectionFilter</code>：检测请求是否通过Spring调度程序。</font><font o="1556">使用键<code i="865">FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code>设置布尔值。</font></p>
</li>
<li>
<p><font o="1557"><code i="866">FormBodyWrapperFilter</code>：解析表单数据，并对下游请求进行重新编码。</font></p>
</li>
<li>
<p><font o="1558"><code i="867">DebugFilter</code>：如果设置<code i="868">debug</code>请求参数，则此过滤器将<code i="869">RequestContext.setDebugRouting()</code>和<code i="870">RequestContext.setDebugRequest()</code>设置为true。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1559">路由过滤器</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1560"><code i="871">SendForwardFilter</code>：此过滤器使用Servlet <code i="872">RequestDispatcher</code>转发请求。</font><font o="1561">转发位置存储在<code i="873">RequestContext</code>属性<code i="874">FilterConstants.FORWARD_TO_KEY</code>中。</font><font o="1562">这对于转发到当前应用程序中的端点很有用。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1563">过滤器：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1564"><code i="875">SendResponseFilter</code>：将代理请求的响应写入当前响应。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1565">错误过滤器：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1566"><code i="876">SendErrorFilter</code>：如果<code i="877">RequestContext.getThrowable()</code>不为null，则转发到/错误（默认情况下）。</font><font o="1567">可以通过设置<code i="879">error.path</code>属性来更改默认转发路径（<code i="878">/error</code>）。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="__code_enablezuulproxy_code_filters"><font o="1568"><code i="880">@EnableZuulProxy</code>过滤器</font></h4>
<div class="paragraph">
<p><font o="1569">创建从<code i="882">DiscoveryClient</code>（如Eureka）以及属性加载路由定义的<code i="881">DiscoveryClientRouteLocator</code>。</font><font o="1570">每个<code i="883">serviceId</code>从<code i="884">DiscoveryClient</code>创建路由。</font><font o="1571">随着新服务的添加，路由将被刷新。</font></p>
</div>
<div class="paragraph">
<p><font o="1572">除了上述过滤器之外，还安装了以下过滤器（正常Spring豆类）：</font></p>
</div>
<div class="paragraph">
<p><font o="1573">前置过滤器</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1574"><code i="885">PreDecorationFilter</code>：此过滤器根据提供的<code i="886">RouteLocator</code>确定在哪里和如何路由。</font><font o="1575">它还为下游请求设置各种与代理相关的头。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1576">路由过滤器</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1577"><code i="887">RibbonRoutingFilter</code>：此过滤器使用Ribbon，Hystrix和可插拔HTTP客户端发送请求。</font><font o="1578">服务ID位于<code i="888">RequestContext</code>属性<code i="889">FilterConstants.SERVICE_ID_KEY</code>中。</font><font o="1579">此过滤器可以使用不同的HTTP客户端。</font><font o="1580">他们是：</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="1581">Apache <code i="890">HttpClient</code>。</font><font o="1582">这是默认的客户端。</font></p>
</li>
<li>
<p><font o="1583">Squareup <code i="891">OkHttpClient</code> v3。</font><font o="1584">通过在类路径上设置<code i="892">com.squareup.okhttp3:okhttp</code>库并设置<code i="893">ribbon.okhttp.enabled=true</code>来启用此功能。</font></p>
</li>
<li>
<p><font o="1585">Netflix Ribbon HTTP客户端。</font><font o="1586">这可以通过设置<code i="894">ribbon.restclient.enabled=true</code>来启用。</font><font o="1587">这个客户端有限制，比如它不支持PATCH方法，还有内置的重试。</font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="1588"><code i="895">SimpleHostRoutingFilter</code>：此过滤器通过Apache HttpClient发送请求到预定的URL。</font><font o="1589">URL位于<code i="896">RequestContext.getRouteHost()</code>。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_custom_zuul_filter_examples"><font o="1590">自定义Zuul过滤示例</font></h4>
<div class="paragraph">
<p><font o="1591">以下大部分以下“如何撰写”示例都包含</font><a href="https://github.com/spring-cloud-samples/sample-zuul-filters"><font o="1591">示例Zuul过滤器</font></a><font o="1591">项目。</font><font o="1592">还有一些操作该存储库中的请求或响应正文的例子。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_how_to_write_a_pre_filter"><font o="1593">如何编写预过滤器</font></h4>
<div class="paragraph">
<p><font o="1594">前置过滤器用于设置<code i="897">RequestContext</code>中的数据，用于下游的过滤器。</font><font o="1595">主要用例是设置路由过滤器所需的信息。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class QueryParamPreFilter extends ZuulFilter {
	@Override
	public int filterOrder() {
		return PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration
	}

	@Override
	public String filterType() {
		return PRE_TYPE;
	}

	@Override
	public boolean shouldFilter() {
		RequestContext ctx = RequestContext.getCurrentContext();
		return !ctx.containsKey(FORWARD_TO_KEY) // a filter has already forwarded
				&amp;&amp; !ctx.containsKey(SERVICE_ID_KEY); // a filter has already determined serviceId
	}
    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
		HttpServletRequest request = ctx.getRequest();
		if (request.getParameter("foo") != null) {
		    // put the serviceId in `RequestContext`
    		ctx.put(SERVICE_ID_KEY, request.getParameter("foo"));
    	}
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1596">上面的过滤器从<code i="899">foo</code>请求参数填充<code i="898">SERVICE_ID_KEY</code>。</font><font o="1597">实际上，做这种直接映射并不是一个好主意，而是从<code i="900">foo</code>的值来查看服务ID。</font></p>
</div>
<div class="paragraph">
<p><font o="1598">现在填写<code i="901">SERVICE_ID_KEY</code>，<code i="902">PreDecorationFilter</code>将不会运行，<code i="903">RibbonRoutingFilter</code>将会。</font><font o="1599">如果您想要路由到完整的网址，请改用<code i="904">ctx.setRouteHost(url)</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1600">要修改路由过滤器将转发的路径，请设置<code i="905">REQUEST_URI_KEY</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_how_to_write_a_route_filter"><font o="1601">如何编写路由过滤器</font></h4>
<div class="paragraph">
<p><font o="1602">路由过滤器在预过滤器之后运行，并用于向其他服务发出请求。</font><font o="1603">这里的大部分工作是将请求和响应数据转换到客户端所需的模型。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class OkHttpRoutingFilter extends ZuulFilter {
	@Autowired
	private ProxyRequestHelper helper;

	@Override
	public String filterType() {
		return ROUTE_TYPE;
	}

	@Override
	public int filterOrder() {
		return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1;
	}

	@Override
	public boolean shouldFilter() {
		return RequestContext.getCurrentContext().getRouteHost() != null
				&amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
	}

    @Override
    public Object run() {
		OkHttpClient httpClient = new OkHttpClient.Builder()
				// customize
				.build();

		RequestContext context = RequestContext.getCurrentContext();
		HttpServletRequest request = context.getRequest();

		String method = request.getMethod();

		String uri = this.helper.buildZuulRequestURI(request);

		Headers.Builder headers = new Headers.Builder();
		Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
		while (headerNames.hasMoreElements()) {
			String name = headerNames.nextElement();
			Enumeration&lt;String&gt; values = request.getHeaders(name);

			while (values.hasMoreElements()) {
				String value = values.nextElement();
				headers.add(name, value);
			}
		}

		InputStream inputStream = request.getInputStream();

		RequestBody requestBody = null;
		if (inputStream != null &amp;&amp; HttpMethod.permitsRequestBody(method)) {
			MediaType mediaType = null;
			if (headers.get("Content-Type") != null) {
				mediaType = MediaType.parse(headers.get("Content-Type"));
			}
			requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
		}

		Request.Builder builder = new Request.Builder()
				.headers(headers.build())
				.url(uri)
				.method(method, requestBody);

		Response response = httpClient.newCall(builder.build()).execute();

		LinkedMultiValueMap&lt;String, String&gt; responseHeaders = new LinkedMultiValueMap&lt;&gt;();

		for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : response.headers().toMultimap().entrySet()) {
			responseHeaders.put(entry.getKey(), entry.getValue());
		}

		this.helper.setResponse(response.code(), response.body().byteStream(),
				responseHeaders);
		context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running
		return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1604">上述过滤器将Servlet请求信息转换为OkHttp3请求信息，执行HTTP请求，然后将OkHttp3响应信息转换为Servlet响应。</font><font o="1605">警告：此过滤器可能有错误，但功能不正确。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_how_to_write_a_post_filter"><font o="1606">如何编写过滤器</font></h4>
<div class="paragraph">
<p><font o="1607">后置过滤器通常操纵响应。</font><font o="1608">在下面的过滤器中，我们添加一个随机<code i="906">UUID</code>作为<code i="907">X-Foo</code>头。</font><font o="1609">其他操作，如转换响应体，要复杂得多，计算密集。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class AddResponseHeaderFilter extends ZuulFilter {
	@Override
	public String filterType() {
		return POST_TYPE;
	}

	@Override
	public int filterOrder() {
		return SEND_RESPONSE_FILTER_ORDER - 1;
	}

	@Override
	public boolean shouldFilter() {
		return true;
	}

	@Override
	public Object run() {
		RequestContext context = RequestContext.getCurrentContext();
    	HttpServletResponse servletResponse = context.getResponse();
		servletResponse.addHeader("X-Foo", UUID.randomUUID().toString());
		return null;
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_how_zuul_errors_work"><font o="1610">Zuul错误如何工作</font></h4>
<div class="paragraph">
<p><font o="1611">如果在Zuul过滤器生命周期的任何部分抛出异常，则会执行错误过滤器。</font><font o="1612"><code i="908">SendErrorFilter</code>只有<code i="909">RequestContext.getThrowable()</code>不是<code i="910">null</code>才会运行。</font><font o="1613">然后在请求中设置特定的<code i="911">javax.servlet.error.*</code>属性，并将请求转发到Spring Boot错误页面。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_zuul_eager_application_context_loading"><font o="1614">Zuul渴望应用程序上下文加载</font></h4>
<div class="paragraph">
<p><font o="1615">Zuul内部使用Ribbon调用远程URL，并且Ribbon客户端默认在第一次调用时由Spring Cloud加载。</font><font o="1616">可以使用以下配置更改Zuul的此行为，并将导致在应用程序启动时，子Ribbon相关的应用程序上下文正在加载。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1617">application.yml</font></div>
<div class="content">
<pre class="notranslate">zuul:
  ribbon:
    eager-load:
      enabled: true</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_polyglot_support_with_sidecar"><font o="1618">Polyglot支持Sidecar</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1619">你有没有非jvm的语言你想利用Eureka，Ribbon和配置服务器？</font><a href="https://github.com/Netflix/Prana"><font o="1620">Netflix Prana</font></a><font o="1620">启发了Spring Cloud Netflix Sidecar
 </font><font o="1620">。</font><font o="1621">它包含一个简单的http api来获取给定服务的所有实例（即主机和端口）。</font><font o="1622">您还可以通过从Eureka获取其路由条目的嵌入式Zuul代理来代理服务调用。</font><font o="1623">可以通过主机查找或通过Zuul代理访问Spring Cloud Config服务器。</font><font o="1624">非jvm应用程序应该执行健康检查，以便Sidecar可以向应用程序启动或关闭时向eureka报告。</font></p>
</div>
<div class="paragraph">
<p><font o="1625">要在项目中包含Sidecar，使用组<code i="912">org.springframework.cloud</code>和artifact id <code i="913">spring-cloud-netflix-sidecar</code>的依赖关系。</font></p>
</div>
<div class="paragraph">
<p><font o="1626">要启用Sidecar，请使用<code i="914">@EnableSidecar</code>创建Spring Boot应用程序。</font><font o="1627">此注释包括<code i="915">@EnableCircuitBreaker</code>，<code i="916">@EnableDiscoveryClient</code>和<code i="917">@EnableZuulProxy</code>。</font><font o="1628">在与非jvm应用程序相同的主机上运行生成的应用程序。</font></p>
</div>
<div class="paragraph">
<p><font o="1629">要配置侧车将<code i="918">sidecar.port</code>和<code i="919">sidecar.health-uri</code>添加到<code i="920">application.yml</code>。</font><font o="1630"><code i="921">sidecar.port</code>属性是非jvm应用程序正在侦听的端口。</font><font o="1631">这样，Sidecar可以使用Eureka正确注册该应用。</font><font o="1632"><code i="922">sidecar.health-uri</code>是可以在非jvm应用程序上访问的，可以模拟Spring Boot健康指标。</font><font o="1633">它应该返回一个json文档，如下所示：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1634">健康-URI文档</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
  "status":"UP"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1635">以下是Sidecar应用程序的application.yml示例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1636">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">server:
  port: 5678
spring:
  application:
    name: sidecar

sidecar:
  port: 8000
  health-uri: http://localhost:8000/health.json</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1637"><code i="923">DiscoveryClient.getInstances()</code>方法的api为<code i="924">/hosts/{serviceId}</code>。</font><font o="1638">以下是<code i="925">/hosts/customers</code>在不同主机上返回两个实例的示例响应。</font><font o="1639">这个api可以访问<code i="926"><a href="http://localhost:5678/hosts/%7BserviceId%7D" class="bare">http://localhost:5678/hosts/{serviceId}</a></code>的非jvm应用程序（如果侧面在端口5678上）。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="1640">/主机/客户</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">[
    {
        "host": "myhost",
        "port": 9000,
        "uri": "http://myhost:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    },
    {
        "host": "myhost2",
        "port": 9000,
        "uri": "http://myhost2:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1641">Zuul代理自动将eureka中已知的每个服务的路由添加到<code i="927">/&lt;serviceId&gt;</code>，因此客户服务可在<code i="928">/customers</code>获得。</font><font o="1642">非jvm应用程序可以通过<code i="929"><a href="http://localhost:5678/customers" class="bare">http://localhost:5678/customers</a></code>访问客户服务（假设边界正在侦听端口5678）。</font></p>
</div>
<div class="paragraph">
<p><font o="1643">如果配置服务器已注册到Eureka，则非jvm应用程序可以通过Zuul代理访问它。</font><font o="1644">如果ConfigServer的serviceId为<code i="930">configserver</code>且端口5678为Sidecar，则可以在
 </font><a href="http://localhost:5678/configserver" class="bare"><font o="1644">http：// localhost：5678 / configserver</font></a></p>
</div>
<div class="paragraph">
<p><font o="1645">非jvm应用程序可以利用Config Server返回YAML文档的功能。</font><font o="1646">例如，调用</font><a href="http://sidecar.local.spring.io:5678/configserver/default-master.yml" class="bare"><font o="1646">http://sidecar.local.spring.io:5678/configserver/default-master.yml</font></a><font o="1646"> 
可能会导致一个YAML文档，如下所示</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  password: password
info:
  description: Spring Cloud Samples
  url: https://github.com/spring-cloud-samples</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="netflix-rxjava-springmvc"><font o="1647">RxJava与Spring MVC</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1648">Spring Cloud Netflix包括</font><a href="https://github.com/ReactiveX/RxJava"><font o="1648">RxJava</font></a><font o="1648">。</font></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><font o="1649">RxJava是</font><a href="http://reactivex.io/"><font o="1649">Reactive Extensions</font></a><font o="1649">的Java VM实现</font><font o="1649">：用于通过使用observable序列来构建异步和基于事件的程序的库。</font></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><font o="1650">Spring Cloud Netflix支持从Spring MVC控制器返回<code i="931">rx.Single</code>对象。</font><font o="1651">它还支持对</font><a href="https://en.wikipedia.org/wiki/Server-sent_events"><font o="1651">服务器发送事件（SSE）</font></a><font o="1651">使用<code i="932">rx.Observable</code>对象</font><font o="1651">。</font><font o="1652">如果您的内部API已经使用RxJava构建（参见</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feign-hystrix"><font o="1652">Feign Hystrix支持</font></a><font o="1652">示例），</font><font o="1652">这可能非常方便</font><font o="1652">。</font></p>
</div>
<div class="paragraph">
<p><font o="1653">以下是使用<code i="933">rx.Single</code>的一些示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RequestMapping(method = RequestMethod.GET, value = "/single")
public Single&lt;String&gt; single() {
	return Single.just("single value");
}

@RequestMapping(method = RequestMethod.GET, value = "/singleWithResponse")
public ResponseEntity&lt;Single&lt;String&gt;&gt; singleWithResponse() {
	return new ResponseEntity&lt;&gt;(Single.just("single value"),
			HttpStatus.NOT_FOUND);
}

@RequestMapping(method = RequestMethod.GET, value = "/singleCreatedWithResponse")
public Single&lt;ResponseEntity&lt;String&gt;&gt; singleOuterWithResponse() {
	return Single.just(new ResponseEntity&lt;&gt;("single value", HttpStatus.CREATED));
}

@RequestMapping(method = RequestMethod.GET, value = "/throw")
public Single&lt;Object&gt; error() {
	return Single.error(new RuntimeException("Unexpected"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1654">如果您有<code i="934">Observable</code>而不是单个，则可以使用<code i="935">.toSingle()</code>或<code i="936">.toList().toSingle()</code>。</font><font o="1655">这里有些例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RequestMapping(method = RequestMethod.GET, value = "/single")
public Single&lt;String&gt; single() {
    return Observable.just("single value").toSingle();
}

@RequestMapping(method = RequestMethod.GET, value = "/multiple")
public Single&lt;List&lt;String&gt;&gt; multiple() {
    return Observable.just("multiple", "values").toList().toSingle();
}

@RequestMapping(method = RequestMethod.GET, value = "/responseWithObservable")
public ResponseEntity&lt;Single&lt;String&gt;&gt; responseWithObservable() {

    Observable&lt;String&gt; observable = Observable.just("single value");
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(APPLICATION_JSON_UTF8);
    return new ResponseEntity&lt;&gt;(observable.toSingle(), headers, HttpStatus.CREATED);
}

@RequestMapping(method = RequestMethod.GET, value = "/timeout")
public Observable&lt;String&gt; timeout() {
    return Observable.timer(1, TimeUnit.MINUTES).map(new Func1&lt;Long, String&gt;() {
        @Override
        public String call(Long aLong) {
            return "single value";
        }
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1656">如果您有流式端点和客户端，SSE可以是一个选项。</font><font o="1657">要将<code i="937">rx.Observable</code>转换为Spring <code i="938">SseEmitter</code>使用<code i="939">RxResponse.sse()</code>。</font><font o="1658">这里有些例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RequestMapping(method = RequestMethod.GET, value = "/sse")
public SseEmitter single() {
	return RxResponse.sse(Observable.just("single value"));
}

@RequestMapping(method = RequestMethod.GET, value = "/messages")
public SseEmitter messages() {
	return RxResponse.sse(Observable.just("message 1", "message 2", "message 3"));
}

@RequestMapping(method = RequestMethod.GET, value = "/events")
public SseEmitter event() {
	return RxResponse.sse(APPLICATION_JSON_UTF8,
			Observable.just(new EventDto("Spring io", getDate(2016, 5, 19)),
					new EventDto("SpringOnePlatform", getDate(2016, 8, 1))));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="netflix-metrics"><font o="1659">指标：Spectator，Servo和Atlas</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1660">当一起使用时，Spectator / Servo和Atlas提供了近乎实时的操作洞察平台。</font></p>
</div>
<div class="paragraph">
<p><font o="1661">Netflix的度量收集库Spectator和Servo </font><font o="1662">Atlas是用于管理维度时间序列数据的Netflix指标后端。</font></p>
</div>
<div class="paragraph">
<p><font o="1663">Servo为Netflix服务了好几年，仍然可以使用，但逐渐被淘汰出局Spectator，这只适用于Java 8. Spring Cloud Netflix提供了支持，但Java 8鼓励基于应用的应用程序使用Spectator。</font></p>
</div>
<div class="sect2">
<h3 id="_dimensional_vs_hierarchical_metrics"><font o="1664">维度与层次度量</font></h3>
<div class="paragraph">
<p><font o="1665">Spring Boot执行器指标是层次结构，指标只能由名称分隔。</font><font o="1666">这些名称通常遵循将密钥/值属性对（维）嵌入到以句点分隔的名称中的命名约定。</font><font o="1667">考虑以下两个端点（root和star-star）的指标：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "counter.status.200.root": 20,
    "counter.status.400.root": 3,
    "counter.status.200.star-star": 5,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1668">第一个指标给出了每单位时间内针对根端点的成功请求的归一化计数。</font><font o="1669">但是如果系统有20个端点，并且想要获得针对所有端点的成功请求计数呢？</font><font o="1670">一些分级度量后端将允许您指定一个通配符，例如<code i="940">counter.status.200.<strong></strong></code> </font><strong><font o="1670">，它将读取所有20个指标并聚合结果。</font><font o="1671">或者，您可以提供<code i="941">HandlerInterceptorAdapter</code>拦截并记录所有成功请求的<code i="942">counter.status.200.all</code>等指标，而不考虑端点，但现在您必须编写20 + 1个不同的指标。</font><font o="1672">同样，如果您想知道服务中所有端点的成功请求总数，您可以指定一个通配符，例如<code i="943">counter.status.2</code></font></strong><font o="1672"> <code i="944">.*</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1673">即使在分级度量后端的通配符支持的情况下，命名一致性也是困难的。</font><font o="1674">具体来说，这些标签在名称字符串中的位置可能会随着时间而滑落，从而导致查询错 </font><font o="1675">例如，假设我们为上述HTTP方法添加了一个额外的维度。</font><font o="1676">那么<code i="945">counter.status.200.root</code>成为<code i="946">counter.status.200.method.get.root</code>等等。我们的<code i="947">counter.status.200.*</code>突然不再具有相同的语义。</font><font o="1677">此外，如果新的维度在整个代码库中不均匀地应用，某些查询可能会变得不可能。</font><font o="1678">这可以很快失控。</font></p>
</div>
<div class="paragraph">
<p><font o="1679">Netflix指标被标记（又称维度）。</font><font o="1680">每个指标都有一个名称，但是这个单一的命名度量可以包含多个统计信息和“标签”键/值对，这允许更多的查询灵活性。</font><font o="1681">实际上统计本身就是记录在一个特殊的标签上。</font></p>
</div>
<div class="paragraph">
<p><font o="1682">使用Netflix Servo或Spectator记录，上述根端点的计时器包含每个状态码的4个统计信息，其中计数统计信息与Spring Boot执行器计数器相同。</font><font o="1683">如果到目前为止，我们遇到了HTTP 200和400，将有8个可用数据点：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "root(status=200,stastic=count)": 20,
    "root(status=200,stastic=max)": 0.7265630630000001,
    "root(status=200,stastic=totalOfSquares)": 0.04759702862580789,
    "root(status=200,stastic=totalTime)": 0.2093076914666667,
    "root(status=400,stastic=count)": 1,
    "root(status=400,stastic=max)": 0,
    "root(status=400,stastic=totalOfSquares)": 0,
    "root(status=400,stastic=totalTime)": 0,
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_default_metrics_collection"><font o="1684">默认度量集合</font></h3>
<div class="paragraph">
<p><font o="1685">没有任何附加依赖或配置，基于Spring Cloud的服务将自动配置Servo <code i="948">MonitorRegistry</code>，并开始收集每个Spring MVC请求的指标。</font><font o="1686">默认情况下，将为每个MVC请求记录名称为<code i="949">rest</code>的Servo定时器，其标记为：</font></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><font o="1687">HTTP方法</font></p>
</li>
<li>
<p><font o="1688">HTTP状态（例如200,400,500）</font></p>
</li>
<li>
<p><font o="1689">URI（如果URI为空，则为“root”），为Atlas</font></p>
</li>
<li>
<p><font o="1690">异常类名称，如果请求处理程序抛出异常</font></p>
</li>
<li>
<p><font o="1691">如果在请求上设置了匹配<code i="950">netflix.metrics.rest.callerHeader</code>的密钥的请求头，则呼叫者。</font><font o="1692"><code i="951">netflix.metrics.rest.callerHeader</code>没有默认键。</font><font o="1693">如果您希望收集来电者信息，则必须将其添加到应用程序属性中。</font></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><font o="1694">设置<code i="952">netflix.metrics.rest.metricName</code>属性将度量值的名称从<code i="953">rest</code>更改为您提供的名称。</font></p>
</div>
<div class="paragraph">
<p><font o="1695">如果Spring AOP已启用，并且<code i="954">org.aspectj:aspectjweaver</code>存在于您的运行时类路径上，则Spring Cloud还将收集每个使用<code i="955">RestTemplate</code>进行的客户端调用的指标。</font><font o="1696">将为每个具有以下标签的MVC请求记录名称为<code i="956">restclient</code>的Servo定时器：</font></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><font o="1697">HTTP方法</font></p>
</li>
<li>
<p><font o="1698">HTTP状态（例如200,400,500），如果响应返回为空，则为“CLIENT_ERROR”;如果在执行<code i="958">RestTemplate</code>方法期间发生<code i="957">IOException</code>，则为“IO_ERROR”</font></p>
</li>
<li>
<p><font o="1699">URI，为Atlas</font></p>
</li>
<li>
<p><font o="1700">客户名称</font></p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1701">警告</font></div>
</td>
<td class="content"><font o="1702">
避免在<code i="959">RestTemplate</code>内使用硬编码的url参数。</font><font o="1703">定位动态端点时使用URL变量。</font><font o="1704">这将避免<code i="960">ServoMonitorCache</code>将每个网址视为唯一密钥的潜在“GC覆盖限制达到”问题。
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// recommended
String orderid = "1";
restTemplate.getForObject("http://testeurekabrixtonclient/orders/{orderid}", String.class, orderid)

// avoid
restTemplate.getForObject("http://testeurekabrixtonclient/orders/1", String.class)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="netflix-metrics-spectator"><font o="1705">指标集：Spectator</font></h3>
<div class="paragraph">
<p><font o="1706">要启用Spectator指标，请在<code i="961">spring-boot-starter-spectator</code>上包含依赖关系：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-spectator&lt;/artifactId&gt;
    &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1707">在Spectator说明中，仪表是一个命名，打字和标记的配置，而指标表示给定仪表在某个时间点的值。</font><font o="1708">Spectator米由注册表创建和控制，注册表目前有几个不同的实现。</font><font o="1709">Spectator提供4米类型：计数器，定时器，量规和分配摘要。</font></p>
</div>
<div class="paragraph">
<p><font o="1710">Spring Cloud Spectator集成为您配置可注入的<code i="962">com.netflix.spectator.api.Registry</code>实例。</font><font o="1711">具体来说，它配置一个<code i="963">ServoRegistry</code>实例，以统一REST度量标准的集合，并将度量标准导出到Servo API下的Atlas后端。</font><font o="1712">实际上，这意味着您的代码可能会使用Servo显示器和Spectator米的混合，并且都将由Spring Boot Actuator <code i="964">MetricReader</code>实例舀取，并将两者都发送到Atlas后端</font></p>
</div>
<div class="sect3">
<h4 id="_spectator_counter"><font o="1713">Spectator柜台</font></h4>
<div class="paragraph">
<p><font o="1714">计数器用于测量某些事件发生的速率。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// create a counter with a name and a set of tags
Counter counter = registry.counter("counterName", "tagKey1", "tagValue1", ...);
counter.increment(); // increment when an event occurs
counter.increment(10); // increment by a discrete amount</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1715">计数器记录单个时间归一化统计量。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_spectator_timer"><font o="1716">Spectator计时器</font></h4>
<div class="paragraph">
<p><font o="1717">一个计时器用于测量一些事件需要多长时间。</font><font o="1718">Spring Cloud自动记录Spring MVC请求和有条件<code i="965">RestTemplate</code>请求的定时器，稍后可用于为请求相关指标创建仪表板，如延迟：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/RequestLatency.png" alt="RequestLatency">
</div>
<div class="title"><font o="1719">图4.请求延迟</font></div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// create a timer with a name and a set of tags
Timer timer = registry.timer("timerName", "tagKey1", "tagValue1", ...);

// execute an operation and time it at the same time
T result = timer.record(() -&gt; fooReturnsT());

// alternatively, if you must manually record the time
Long start = System.nanoTime();
T result = fooReturnsT();
timer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS);</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1720">计时器同时记录4个统计信息：count，max，totalOfSquares和totalTime。</font><font o="1721">如果您在每次记录时间时在计数器上调用了<code i="966">increment()</code>一次，计数统计量将始终与计数器提供的单个归一化值相匹配，因此对于单个操作，不需要单独计数和分时。</font></p>
</div>
<div class="paragraph">
<p><font o="1722">对于</font><a href="https://github.com/Netflix/spectator/wiki/Timer-Usage#longtasktimer"><font o="1722">长时间运行的操作</font></a><font o="1722">，Spectator提供了一个特殊的<code i="967">LongTaskTimer</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_spectator_gauge"><font o="1723">Spectator量规</font></h4>
<div class="paragraph">
<p><font o="1724">量规用于确定一些当前值，如队列的大小或处于运行状态的线程数。</font><font o="1725">由于仪表被采样，它们不提供关于这些值在样品之间如何波动的信息。</font></p>
</div>
<div class="paragraph">
<p><font o="1726">仪器的正常使用包括在初始化中使用标识符注册仪表，对要采样的对象的引用，以及基于对象获取或计算数值的功能。</font><font o="1727">对对象的引用被单独传递，Spectator注册表将保留对该对象的弱引用。</font><font o="1728">如果对象被垃圾回收，则Spectator将自动删除注册。</font><font o="1729">见</font><a href="https://github.com/Netflix/spectator/wiki/Gauge-Usage#using-lambda"><font o="1729">注</font></a><font o="1729"> Spectator是关于潜在的内存泄漏的文件中，如果这个API被滥用。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// the registry will automatically sample this gauge periodically
registry.gauge("gaugeName", pool, Pool::numberOfRunningThreads);

// manually sample a value in code at periodic intervals -- last resort!
registry.gauge("gaugeName", Arrays.asList("tagKey1", "tagValue1", ...), 1000);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_spectator_distribution_summaries"><font o="1730">Spectator分发摘要</font></h4>
<div class="paragraph">
<p><font o="1731">分发摘要用于跟踪事件的分布情况。</font><font o="1732">它类似于一个计时器，但更普遍的是，大小不一定是一段时间。</font><font o="1733">例如，分发摘要可用于测量服务器的请求的有效载荷大小。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// the registry will automatically sample this gauge periodically
DistributionSummary ds = registry.distributionSummary("dsName", "tagKey1", "tagValue1", ...);
ds.record(request.sizeInBytes());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="netflix-metrics-servo"><font o="1734">指标集：Servo</font></h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1735">警告</font></div>
</td>
<td class="content"><font o="1736">
如果您的代码在Java 8上编译，请使用Spectator而不是Servo，因为Spectator注定要从长期来替换Servo。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1737">在Servo语言中，监视器是一个命名，键入和标记的配置，而指标表示给定监视器在某个时间点的值。</font><font o="1738">Servo显示器在逻辑上相当于Spectator米。</font><font o="1739">Servo显示器由<code i="968">MonitorRegistry</code>创建和控制。</font><font o="1740">尽管有上述警告，Servo确实具有</font><font o="1740">比Spectator有米</font><font o="1740">的</font><a href="https://github.com/Netflix/servo/wiki/Getting-Started"><font o="1740">更广泛</font></a><font o="1740">的监视器选项。</font></p>
</div>
<div class="paragraph">
<p><font o="1741">Spring Cloud集成为您配置可注入的<code i="969">com.netflix.servo.MonitorRegistry</code>实例。</font><font o="1742">在Servo中创建了相应的<code i="970">Monitor</code>类型后，记录数据的过程完全类似于Spectator。</font></p>
</div>
<div class="sect3">
<h4 id="_creating_servo_monitors"><font o="1743">创建Servo显示器</font></h4>
<div class="paragraph">
<p><font o="1744">如果您正在使用由Spring Cloud提供的Servo <code i="971">MonitorRegistry</code>实例（具体来说是<code i="972">DefaultMonitorRegistry</code>的实例），则Servo提供了用于检索</font><a href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamiccounter"><font o="1744">计数器</font></a><font o="1744">和</font><a href="https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamictimer"><font o="1744">计时器的</font></a><font o="1744">便利类</font><font o="1744">。</font><font o="1745">这些便利类确保每个唯一的名称和标签组合只注册一个<code i="973">Monitor</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="1746">要在Servo中手动创建监视器类型，特别是对于不提供方便方法的异域监视器类型，通过提供<code i="974">MonitorConfig</code>实例来实例化适当的类型：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">MonitorConfig config = MonitorConfig.builder("timerName").withTag("tagKey1", "tagValue1").build();

// somewhere we should cache this Monitor by MonitorConfig
Timer timer = new BasicTimer(config);
monitorRegistry.register(timer);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="netflix-metrics-atlas"><font o="1747">指标后端：Atlas</font></h3>
<div class="paragraph">
<p><font o="1748">Netflix开发了Atlas来管理维度时间序列数据，实现近实时操作洞察。</font><font o="1749">Atlas具有内存中数据存储功能，可以非常快速地收集和报告大量的指标。</font></p>
</div>
<div class="paragraph">
<p><font o="1750">Atlas捕获操作情报。</font><font o="1751">而商业智能是收集的数据，用于分析一段时间内的趋势，操作情报提供了系统中目前发生的情况。</font></p>
</div>
<div class="paragraph">
<p><font o="1752">Spring Cloud提供了一个<code i="975">spring-cloud-starter-atlas</code>，它具有您需要的所有依赖关系。</font><font o="1753">然后只需使用<code i="976">@EnableAtlas</code>注释您的Spring Boot应用程序，并为您运行的Atlas服务器提供<code i="977">netflix.atlas.uri</code>属性的位置。</font></p>
</div>
<div class="sect3">
<h4 id="_global_tags"><font o="1754">全球标签</font></h4>
<div class="paragraph">
<p><font o="1755">您可以通过Spring Cloud向发送到Atlas后端的每个度量标准添加标签。</font><font o="1756">全局标签可用于按应用程序名称，环境，区域等分隔度量。</font></p>
</div>
<div class="paragraph">
<p><font o="1757">实现<code i="978">AtlasTagProvider</code>的每个bean将贡献全局标签列表：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
AtlasTagProvider atlasCommonTags(
    @Value("${spring.application.name}") String appName) {
  return () -&gt; Collections.singletonMap("app", appName);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_atlas"><font o="1758">使用Atlas</font></h4>
<div class="paragraph">
<p><font o="1759">要引导内存独立的Atlas实例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">$ curl -LO https://github.com/Netflix/atlas/releases/download/v1.4.2/atlas-1.4.2-standalone.jar
$ java -jar atlas-1.4.2-standalone.jar</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1760">提示</font></div>
</td>
<td class="content"><font o="1761">
运行在r3.2xlarge（61GB RAM）上的Atlas独立节点可以在给定的6小时窗口内每分钟处理大约200万个度量值。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1762">一旦运行，您收集了少量指标，请通过在Atlas服务器上列出代码来验证您的设置是否正确：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">$ curl http://ATLAS/api/v1/tags</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1763">提示</font></div>
</td>
<td class="content"><font o="1764">
在针对您的服务执行多个请求后，您可以通过在浏览器中粘贴以下URL来收集关于每个请求的请求延迟的一些非常基本的信息：<code i="979"><a href="http://atlas/api/v1/graph?q=name,rest,:eq,:avg" class="bare">http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg</a></code>
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1765">Atlas wiki包含</font><font o="1765">各种场景</font><a href="https://github.com/Netflix/atlas/wiki/Single-Line"><font o="1765">样本查询</font></a><font o="1765">的汇编。</font></p>
</div>
<div class="paragraph">
<p><font o="1766">确保</font><font o="1766">使用</font><a href="https://github.com/Netflix/atlas/wiki/DES"><font o="1766">双指数平滑</font></a><font o="1766">来查看</font><a href="https://github.com/Netflix/atlas/wiki/Alerting-Philosophy"><font o="1766">警报原理</font></a><font o="1766">和文档，</font><font o="1766">以生成动态警报阈值。</font><a href="https://github.com/Netflix/atlas/wiki/DES"><font></font></a><font></font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="retrying-failed-requests"><font o="1767">重试失败的请求</font></h3>
<div class="paragraph">
<p><font o="1768">Spring Cloud Netflix提供了多种方式来进行HTTP请求。</font><font o="1769">您可以使用负载平衡<code i="980">RestTemplate</code>，Ribbon或Feign。</font><font o="1770">无论您如何选择HTTP请求，始终有可能失败的请求。</font><font o="1771">当请求失败时，您可能希望自动重试该请求。</font><font o="1772">要在使用Sping Cloud Netflix时完成此操作，您需要</font><font o="1772">在应用程序的类路径</font><font o="1772">中包含
 </font><a href="https://github.com/spring-projects/spring-retry"><font o="1772">Spring重试</font></a><font o="1772">。</font><font o="1773">当Spring重试出现负载平衡<code i="981">RestTemplates</code>时，Feign和Zuul将自动重试任何失败的请求（假设配置允许）。</font></p>
</div>
<div class="sect3">
<h4 id="_configuration"><font o="1774">组态</font></h4>
<div class="paragraph">
<p><font o="1775">随时Ribbon与Spring重试一起使用，您可以通过配置某些Ribbon属性来控制重试功能。</font><font o="1776">您可以使用的属性是<code i="982">client.ribbon.MaxAutoRetries</code>，<code i="983">client.ribbon.MaxAutoRetriesNextServer</code>和<code i="984">client.ribbon.OkToRetryOnAllOperations</code>。</font><font o="1777">请参阅</font><a href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties"><font o="1777">Ribbon文档</font></a><font o="1777"> 
，了解属性的具体内容。</font></p>
</div>
<div class="paragraph">
<p><font o="1778">此外，您可能希望在响应中返回某些状态代码时重试请求。</font><font o="1779">您可以列出您希望Ribbon客户端使用属性<code i="985">clientName.ribbon.retryableStatusCodes</code>重试的响应代码。</font><font o="1780">例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">clientName:
  ribbon:
    retryableStatusCodes: 404,502</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1781">您还可以创建一个类型为<code i="986">LoadBalancedRetryPolicy</code>的bean，并实现<code i="987">retryableStatusCode</code>方法来确定是否要重试发出状态代码的请求。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_zuul">Zuul</h4>
<div class="paragraph">
<p><font o="1783">您可以通过将<code i="988">zuul.retryable</code>设置为<code i="989">false</code>来关闭Zuul的重试功能。</font><font o="1784">您还可以通过将<code i="990">zuul.routes.routename.retryable</code>设置为<code i="991">false</code>，以路由方式禁用重试功能。</font></p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_stream" class="sect0"><font o="1785">Spring Cloud Stream</font></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><font o="1786">本节将详细介绍如何使用Spring Cloud Stream。</font><font o="1787">它涵盖了创建和运行流应用程序等主题。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introducing_spring_cloud_stream"><font o="1788">介绍Spring Cloud Stream</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1789">Spring Cloud Stream是构建消息驱动的微服务应用程序的框架。</font><font o="1790">Spring Cloud Stream基于Spring Boot建立独立的生产级Spring应用程序，并使用Spring Integration提供与消息代理的连接。</font><font o="1791">它提供了来自几家供应商的中间件的意见配置，介绍了持久发布订阅语义，消费者组和分区的概念。</font></p>
</div>
<div class="paragraph">
<p><font o="1792">您可以将<code i="992">@EnableBinding</code>注释添加到应用程序，以便立即连接到消息代理，并且可以将<code i="993">@StreamListener</code>添加到方法中，以使其接收流处理的事件。</font><font o="1793">以下是接收外部消息的简单接收器应用程序。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class VoteRecordingSinkApplication {

  public static void main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.class, args);
  }

  @StreamListener(Sink.INPUT)
  public void processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1794"><code i="994">@EnableBinding</code>注释需要一个或多个接口作为参数（在这种情况下，该参数是单个<code i="995">Sink</code>接口）。</font><font o="1795">接口声明输入和/或输出通道。</font><font o="1796">Spring Cloud Stream提供了接口<code i="996">Source</code>，<code i="997">Sink</code>和<code i="998">Processor</code>; </font><font o="1797">您还可以定义自己的界面。</font></p>
</div>
<div class="paragraph">
<p><font o="1798">以下是<code i="999">Sink</code>接口的定义：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Sink {
  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1799"><code i="1000">@Input</code>注释标识</font><em><font o="1799">输入通道</font></em><font o="1799">，通过该</font><em><font o="1799">输入通道</font></em><font o="1799">接收到的消息进入应用程序; </font><font o="1800"><code i="1001">@Output</code>注释标识</font><em><font o="1800">输出通道</font></em><font o="1800">，发布的消息将通过该</font><em><font o="1800">通道</font></em><font o="1800">离开应用程序。</font><font o="1801"><code i="1002">@Input</code>和<code i="1003">@Output</code>注释可以使用频道名称作为参数; </font><font o="1802">如果未提供名称，将使用注释方法的名称。</font></p>
</div>
<div class="paragraph">
<p><font o="1803">Spring Cloud Stream将为您创建一个界面的实现。</font><font o="1804">您可以在应用程序中通过自动连接来使用它，如下面的测试用例示例。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = VoteRecordingSinkApplication.class)
@WebAppConfiguration
@DirtiesContext
public class StreamApplicationTests {

  @Autowired
  private Sink sink;

  @Test
  public void contextLoads() {
    assertNotNull(this.sink.input());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_main_concepts"><font o="1805">主要概念</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1806">Spring Cloud Stream提供了一些简化了消息驱动的微服务应用程序编写的抽象和原语。</font><font o="1807">本节概述了以下内容：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1808">Spring Cloud Stream的应用模型</font></p>
</li>
<li>
<p><font o="1809">Binder抽象</font></p>
</li>
<li>
<p><font o="1810">持续的发布 - 订阅支持</font></p>
</li>
<li>
<p><font o="1811">消费者群体支持</font></p>
</li>
<li>
<p><font o="1812">分区支持</font></p>
</li>
<li>
<p><font o="1813">一个可插拔的Binder API</font></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_application_model"><font o="1814">应用模型</font></h3>
<div class="paragraph">
<p><font o="1815">一个Spring Cloud Stream应用程序由一个中间件中立的核心组成。</font><font o="1816">该应用程序</font><font o="1816">通过Spring Cloud Stream注入到其中的</font><font o="1816">输入和输出</font><em><font o="1816">通道</font></em><font o="1816">与外界进行通信</font><font o="1816">。</font><font o="1817">渠道通过中间件特定的Binder实现连接到外部经纪人。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/SCSt-with-binder.png" alt="SCSt与粘合剂" width="300">
</div>
<div class="title"><font o="1818">图5. Spring Cloud Stream应用</font></div>
</div>
<div class="sect3">
<h4 id="_fat_jar"><font o="1819">胖JAR</font></h4>
<div class="paragraph">
<p><font o="1820">Spring Cloud Stream应用程序可以在独立模式下从IDE运行进行测试。</font><font o="1821">要在生产中运行Spring Cloud Stream应用程序，您可以使用为Maven或Gradle提供的标准Spring Boot工具创建可执行文件（或“胖”）JAR。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_binder_abstraction"><font o="1822">Binder抽象</font></h3>
<div class="paragraph">
<p><font o="1823">Spring Cloud Stream为</font><a href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-kafka"><font o="1823">Kafka</font></a><font o="1823">和</font><a href="https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-rabbit"><font o="1823">Rabbit MQ</font></a><font o="1823">提供Binder实现</font><font o="1823">。</font><font o="1824">Spring Cloud Stream还包括一个</font><a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java"><font o="1824">TestSupportBinder</font></a><font o="1824">，它保留了</font><font o="1824">一个</font><a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java"><font o="1824">未修改</font></a><font o="1824">的通道，以便测试可以直接和可靠地与通道进行交互。</font><font o="1825">您可以使用可扩展API编写自己的Binder。</font></p>
</div>
<div class="paragraph">
<p><font o="1826">Spring Cloud Stream使用Spring Boot进行配置，Binder抽象使得Spring Cloud Stream应用程序可以灵活地连接到中间件。</font><font o="1827">例如，部署者可以在运行时动态地选择通道连接的目的地（例如，Kafka主题或RabbitMQ交换）。</font><font o="1828">可以通过外部配置属性和Spring Boot（包括应用程序参数，环境变量和<code i="1004">application.yml</code>或<code i="1005">application.properties</code>文件）支持的任何形式提供此类配置。</font><font o="1829">在</font><a href="https://springcloud.cc/spring-cloud-dalston.html#_introducing_spring_cloud_stream"><font o="1829">引入Spring Cloud Stream</font></a><font o="1829">部分</font><font o="1829">的接收器示例</font><font o="1829">中，将应用程序属性<code i="1006">spring.cloud.stream.bindings.input.destination</code>设置为<code i="1007">raw-sensor-data</code>将使其从<code i="1008">raw-sensor-data</code> Kafka主题或从绑定到<code i="1009">raw-sensor-data</code> RabbitMQ交换。</font></p>
</div>
<div class="paragraph">
<p><font o="1830">Spring Cloud Stream自动检测并使用类路径中找到的binder。</font><font o="1831">您可以使用相同的代码轻松使用不同类型的中间件：在构建时只包含不同的绑定器。</font><font o="1832">对于更复杂的用例，您还可以在应用程序中打包多个绑定器，并在运行时选择绑定器，甚至是否为不同的通道使用不同的绑定器。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_persistent_publish_subscribe_support"><font o="1833">持续发布 - 订阅支持</font></h3>
<div class="paragraph">
<p><font o="1834">应用之间的通信遵循发布订阅模式，其中通过共享主题广播数据。</font><font o="1835">这可以在下图中看到，它显示了一组交互式的Spring Cloud Stream应用程序的典型部署。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/SCSt-sensors.png" alt="SCSt传感器" width="300">
</div>
<div class="title"><font o="1836">图6. Spring Cloud Stream Publish-Subscribe</font></div>
</div>
<div class="paragraph">
<p><font o="1837">传感器向HTTP端点报告的数据将发送到名为<code i="1010">raw-sensor-data</code>的公共目标。</font><font o="1838">从目的地，它由微服务应用程序独立处理，该应用程序计算时间窗口平均值，以及另一个将原始数据导入HDFS的微服务应用程序。</font><font o="1839">为了处理数据，两个应用程序在运行时将主题声明为它们的输入。</font></p>
</div>
<div class="paragraph">
<p><font o="1840">发布订阅通信模型降低了生产者和消费者的复杂性，并允许将新应用程序添加到拓扑中，而不会中断现有流。</font><font o="1841">例如，在平均计算应用程序的下游，您可以添加一个计算显示和监视的最高温度值的应用程序。</font><font o="1842">然后，您可以添加另一个解释相同的故障检测平均流程的应用程序。</font><font o="1843">通过共享主题而不是点对点队列进行所有通信可以减少微服务之间的耦合。</font></p>
</div>
<div class="paragraph">
<p><font o="1844">虽然发布订阅消息的概念不是新的，但是Spring Cloud Stream需要额外的步骤才能使其成为其应用模型的一个有意义的选择。</font><font o="1845">通过使用本地中间件支持，Spring Cloud Stream还简化了在不同平台上使用发布订阅模型。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="consumer-groups"><font o="1846">消费群体</font></h3>
<div class="paragraph">
<p><font o="1847">虽然发布订阅模型可以轻松地通过共享主题连接应用程序，但通过创建给定应用程序的多个实例来扩展的能力同样重要。</font><font o="1848">当这样做时，应用程序的不同实例被放置在竞争的消费者关系中，其中只有一个实例预期处理给定消息。</font></p>
</div>
<div class="paragraph">
<p><font o="1849">Spring Cloud Stream通过</font><em><font o="1849">消费者组</font></em><font o="1849">的概念来模拟此行为</font><font o="1849">。</font><font o="1850">（Spring Cloud Stream消费者组与Kafka消费者组相似并受到启发。）每个消费者绑定可以使用<code i="1011">spring.cloud.stream.bindings.&lt;channelName&gt;.group</code>属性来指定组名称。</font><font o="1851">对于下图所示的消费者，此属性将设置为<code i="1012">spring.cloud.stream.bindings.&lt;channelName&gt;.group=hdfsWrite</code>或<code i="1013">spring.cloud.stream.bindings.&lt;channelName&gt;.group=average</code>。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/SCSt-groups.png" alt="SCSt组" width="300">
</div>
<div class="title"><font o="1852">图7. Spring Cloud Stream消费者组</font></div>
</div>
<div class="paragraph">
<p><font o="1853">订阅给定目标的所有组都会收到已发布数据的副本，但每个组中只有一个成员从该目的地接收给定的消息。</font><font o="1854">默认情况下，当未指定组时，Spring Cloud Stream将应用程序分配给与所有其他消费者组发布 - 订阅关系的匿名独立单个成员消费者组。</font></p>
</div>
<div class="sect3">
<h4 id="durability"><font o="1855">耐久力</font></h4>
<div class="paragraph">
<p><font o="1856">符合Spring Cloud Stream的有意义的应用模式，消费者群体订阅是</font><em><font o="1856">持久的</font></em><font o="1856">。</font><font o="1857">也就是说，绑定实现确保组预订是持久的，一旦已经创建了一个组的至少一个订阅，即使组中的所有应用程序都被停止，组也将接收消息。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1858">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1859">匿名订阅本质上是不耐用的。</font><font o="1860">对于某些binder实现（例如RabbitMQ），可以具有非持久组的订阅。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="1861">通常，当将应用绑定到给定目的地时，最好始终指定消费者组。</font><font o="1862">在扩展Spring Cloud Stream应用程序时，必须为每个输入绑定指定一个使用者组。</font><font o="1863">这样可以防止应用程序的实例收到重复的消息（除非需要这种行为，这是不寻常的）。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="partitioning"><font o="1864">分区支持</font></h3>
<div class="paragraph">
<p><font o="1865">Spring Cloud Stream提供对</font><font o="1865">给定应用程序的多个实例之间</font><font o="1865">的</font><em><font o="1865">分区</font></em><font o="1865">数据的</font><font o="1865">支持</font><font o="1865">。</font><font o="1866">在分区场景中，物理通信介质（例如，代理主题）被视为被构造成多个分区。</font><font o="1867">一个或多个生产者应用程序实例将数据发送到多个消费者应用程序实例，并确保由共同特征标识的数据由相同的消费者实例处理。</font></p>
</div>
<div class="paragraph">
<p><font o="1868">Spring Cloud Stream提供了统一方式实现分区处理用例的通用抽象。</font><font o="1869">因此，无论代理本身是否自然分区（例如Kafka）（例如RabbitMQ），分区可以被使用。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/SCSt-partitioning.png" alt="SCSt分区" width="300">
</div>
<div class="title"><font o="1870">图8. Spring Cloud Stream分区</font></div>
</div>
<div class="paragraph">
<p><font o="1871">分区是状态处理中的一个关键概念，无论是性能还是一致性原因，它都是批评性的，以确保所有相关数据一起处理。</font><font o="1872">例如，在时间平均计算示例中，重要的是所有给定传感器的所有测量都由相同的应用实例进行处理。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1873">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1874">要设置分区处理方案，您必须同时配置数据生成和数据消耗结束。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programming_model"><font o="1875">编程模型</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="1876">本节介绍Spring Cloud Stream的编程模型。</font><font o="1877">Spring Cloud Stream提供了许多预定义的注释，用于声明绑定的输入和输出通道，以及如何收听频道。</font></p>
</div>
<div class="sect2">
<h3 id="_declaring_and_binding_channels"><font o="1878">声明和绑定频道</font></h3>
<div class="sect3">
<h4 id="_triggering_binding_via_code_enablebinding_code"><font o="1879">触发绑定<code i="1014">@EnableBinding</code></font></h4>
<div class="paragraph">
<p><font o="1880">您可以将Spring应用程序转换为Spring Cloud Stream应用程序，将<code i="1015">@EnableBinding</code>注释应用于应用程序的配置类之一。</font><font o="1881"><code i="1016">@EnableBinding</code>注释本身使用<code i="1017">@Configuration</code>进行元注释，并触发Spring Cloud Stream基础架构的配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">...
@Import(...)
@Configuration
@EnableIntegration
public @interface EnableBinding {
    ...
    Class&lt;?&gt;[] value() default {};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1882"><code i="1018">@EnableBinding</code>注释可以将一个或多个接口类作为参数，这些接口类包含表示可绑定组件（通常是消息通道）的方法。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1883">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1884">在Spring Cloud Stream 1.0中，唯一支持的可绑定组件是Spring消息传递<code i="1019">MessageChannel</code>及其扩展名<code i="1020">SubscribableChannel</code>和<code i="1021">PollableChannel</code>。</font><font o="1885">未来版本应该使用相同的机制将此支持扩展到其他类型的组件。</font><font o="1886">在本文档中，我们将继续参考渠道。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="__code_input_code_and_code_output_code"><font o="1887"><code i="1022">@Input</code>和<code i="1023">@Output</code></font></h4>
<div class="paragraph">
<p><font o="1888">Spring Cloud Stream应用程序可以在接口中定义任意数量的输入和输出通道为<code i="1024">@Input</code>和<code i="1025">@Output</code>方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Barista {

    @Input
    SubscribableChannel orders();

    @Output
    MessageChannel hotDrinks();

    @Output
    MessageChannel coldDrinks();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1889">使用此接口作为参数<code i="1026">@EnableBinding</code>将分别触发三个绑定的通道名称为<code i="1027">orders</code>，<code i="1028">hotDrinks</code>和<code i="1029">coldDrinks</code>。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Barista.class)
public class CafeConfiguration {

   ...
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_customizing_channel_names"><font o="1890">自定义频道名称</font></h5>
<div class="paragraph">
<p><font o="1891">使用<code i="1030">@Input</code>和<code i="1031">@Output</code>注释，您可以指定频道的自定义频道名称，如以下示例所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Barista {
    ...
    @Input("inboundOrders")
    SubscribableChannel orders();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1892">在这个例子中，创建的绑定通道将被命名为<code i="1032">inboundOrders</code>。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="__code_source_code_code_sink_code_and_code_processor_code"><font o="1893"><code i="1033">Source</code>，<code i="1034">Sink</code>和<code i="1035">Processor</code></font></h5>
<div class="paragraph">
<p><font o="1894">为了方便寻址最常见的用例，涉及输入通道，输出通道或两者，Spring Cloud Stream提供了开箱即用的三个预定义接口。</font></p>
</div>
<div class="paragraph">
<p><font o="1895"><code i="1036">Source</code>可用于具有单个出站通道的应用程序。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1896"><code i="1037">Sink</code>可用于具有单个入站通道的应用程序。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Sink {

  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1897"><code i="1038">Processor</code>可用于具有入站通道和出站通道的应用程序。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Processor extends Source, Sink {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1898">Spring Cloud Stream不为任何这些接口提供特殊处理; </font><font o="1899">它们只是开箱即用。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_accessing_bound_channels"><font o="1900">访问绑定通道</font></h4>
<div class="sect4">
<h5 id="_injecting_the_bound_interfaces"><font o="1901">注入绑定界面</font></h5>
<div class="paragraph">
<p><font o="1902">对于每个绑定接口，Spring Cloud Stream将生成一个实现该接口的bean。</font><font o="1903">调用其中一个bean的<code i="1039">@Input</code>注释或<code i="1040">@Output</code>注释方法将返回相关的绑定通道。</font></p>
</div>
<div class="paragraph">
<p><font o="1904">以下示例中的bean在调用其<code i="1041">hello</code>方法时在输出通道上发送消息。</font><font o="1905">它在注入的<code i="1043">Source</code> bean上调用<code i="1042">output()</code>来检索目标通道。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Component
public class SendingBean {

    private Source source;

    @Autowired
    public SendingBean(Source source) {
        this.source = source;
    }

    public void sayHello(String name) {
         source.output().send(MessageBuilder.withPayload(name).build());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_injecting_channels_directly"><font o="1906">直接注入渠道</font></h5>
<div class="paragraph">
<p><font o="1907">绑定通道也可以直接注入：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Component
public class SendingBean {

    private MessageChannel output;

    @Autowired
    public SendingBean(MessageChannel output) {
        this.output = output;
    }

    public void sayHello(String name) {
         output.send(MessageBuilder.withPayload(name).build());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1908">如果在声明注释上定制了通道的名称，则应使用该名称而不是方法名称。</font><font o="1909">给出以下声明：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface CustomSource {
    ...
    @Output("customOutput")
    MessageChannel output();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1910">通道将被注入，如下例所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Component
public class SendingBean {

    private MessageChannel output;

    @Autowired
    public SendingBean(@Qualifier("customOutput") MessageChannel output) {
        this.output = output;
    }

    public void sayHello(String name) {
         this.output.send(MessageBuilder.withPayload(name).build());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_producing_and_consuming_messages"><font o="1911">生产和消费消息</font></h4>
<div class="paragraph">
<p><font o="1912">您可以使用Spring Integration注解或Spring Cloud Stream的<code i="1044">@StreamListener</code>注释编写Spring Cloud Stream应用程序。</font><font o="1913"><code i="1045">@StreamListener</code>注释在其他Spring消息传递注释（例如<code i="1046">@MessageMapping</code>，<code i="1047">@JmsListener</code>，<code i="1048">@RabbitListener</code>等）之后建模，但添加内容类型管理和类型强制功能。</font></p>
</div>
<div class="sect4">
<h5 id="_native_spring_integration_support"><font o="1914">本地Spring Integration支持</font></h5>
<div class="paragraph">
<p><font o="1915">由于Spring Cloud Stream基于Spring Integration，Stream完全继承了Integration的基础和基础架构以及组件本身。</font><font o="1916">例如，您可以将<code i="1049">Source</code>的输出通道附加到<code i="1050">MessageSource</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Source.class)
public class TimerSource {

  @Value("${format}")
  private String format;

  @Bean
  @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "${fixedDelay}", maxMessagesPerPoll = "1"))
  public MessageSource&lt;String&gt; timerMessageSource() {
    return () -&gt; new GenericMessage&lt;&gt;(new SimpleDateFormat(format).format(new Date()));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1917">或者您可以在变压器中使用处理器的通道：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {
  @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
  public Object transform(String message) {
    return message.toUpperCase();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spring_integration_error_channel_support"><font o="1918">Spring Integration错误通道支持</font></h5>
<div class="paragraph">
<p><font o="1919">Spring Cloud Stream支持发布Spring Integration全局错误通道收到的错误消息。</font><font o="1920">发送到<code i="1051">errorChannel</code>的错误消息可以通过为名为<code i="1052">error</code>的出站目标配置绑定，将其发布到代理的特定目标。</font><font o="1921">例如，要将错误消息发布到名为“myErrors”的代理目标，请提供以下属性：<code i="1053">spring.cloud.stream.bindings.error.destination=myErrors</code></font></p>
</div>
</div>
<div class="sect4">
<h5 id="_using_streamlistener_for_automatic_content_type_handling"><font o="1922">使用@StreamListener进行自动内容类型处理</font></h5>
<div class="paragraph">
<p><font o="1923">Spring Integration支持Spring Cloud Stream提供自己的<code i="1054">@StreamListener</code>注释，以其他Spring消息传递注释（例如<code i="1055">@MessageMapping</code>，<code i="1056">@JmsListener</code>，<code i="1057">@RabbitListener</code>等） ）。</font><font o="1924"><code i="1058">@StreamListener</code>注释提供了一种更简单的处理入站邮件的模型，特别是在处理涉及内容类型管理和类型强制的用例时。</font></p>
</div>
<div class="paragraph">
<p><font o="1925">Spring Cloud Stream提供了一种可扩展的<code i="1059">MessageConverter</code>机制，用于通过绑定通道处理数据转换，并且在这种情况下，将调度到使用<code i="1060">@StreamListener</code>注释的方法。</font><font o="1926">以下是处理外部<code i="1061">Vote</code>事件的应用程序的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
public class VoteHandler {

  @Autowired
  VotingService votingService;

  @StreamListener(Sink.INPUT)
  public void handle(Vote vote) {
    votingService.record(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1927">当考虑<code i="1065">String</code>有效载荷和<code i="1066">contentType</code>标题<code i="1067">application/json</code>的入站<code i="1064">Message</code>时，可以看到<code i="1062">@StreamListener</code>和Spring Integration <code i="1063">@ServiceActivator</code>之间的区别。</font><font o="1928">在<code i="1068">@StreamListener</code>的情况下，<code i="1069">MessageConverter</code>机制将使用<code i="1070">contentType</code>标头将<code i="1071">String</code>有效载荷解析为<code i="1072">Vote</code>对象。</font></p>
</div>
<div class="paragraph">
<p><font o="1929">与其他Spring消息传递方法一样，方法参数可以用<code i="1073">@Payload</code>，<code i="1074">@Headers</code>和<code i="1075">@Header</code>注释。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1930">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1931">对于返回数据的方法，您必须使用<code i="1076">@SendTo</code>注释来指定方法返回的数据的输出绑定目的地：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {

  @Autowired
  VotingService votingService;

  @StreamListener(Processor.INPUT)
  @SendTo(Processor.OUTPUT)
  public VoteResult handle(Vote vote) {
    return votingService.record(vote);
  }
}</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_using_streamlistener_for_dispatching_messages_to_multiple_methods"><font o="1932">使用@StreamListener将消息分派到多个方法</font></h5>
<div class="paragraph">
<p><font o="1933">自1.2版本以来，Spring Cloud Stream支持根据条件向在输入通道上注册的多个<code i="1077">@StreamListener</code>方法发送消息。</font></p>
</div>
<div class="paragraph">
<p><font o="1934">为了有资格支持有条件的调度，一种方法必须满足以下条件：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1935">它不能返回值</font></p>
</li>
<li>
<p><font o="1936">它必须是一个单独的消息处理方法（不支持的反应API方法）</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1937">条件通过注释的<code i="1078">condition</code>属性中的SpEL表达式指定，并为每个消息进行评估。</font><font o="1938">匹配条件的所有处理程序将在同一个线程中被调用，并且不必对调用发生的顺序做出假设。</font></p>
</div>
<div class="paragraph">
<p><font o="1939">使用<code i="1079">@StreamListener</code>具有调度条件的示例可以在下面看到。</font><font o="1940">在此示例中，带有值为<code i="1081">foo</code>的标题<code i="1080">type</code>的所有消息将被分派到<code i="1082">receiveFoo</code>方法，所有带有值为<code i="1084">bar</code>的标题<code i="1083">type</code>的消息将被分派到<code i="1085">receiveBar</code>方法。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class TestPojoWithAnnotatedArguments {

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='foo'")
    public void receiveFoo(@Payload FooPojo fooPojo) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bar'")
    public void receiveBar(@Payload BarPojo barPojo) {
       // handle the message
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1941">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1942">仅通过<code i="1086">@StreamListener</code>条件进行调度仅对单个消息的处理程序支持，而不适用于无效编程支持（如下所述）。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reactive_programming_support"><font o="1943">反应式编程支持</font></h4>
<div class="paragraph">
<p><font o="1944">Spring Cloud Stream还支持使用反应性API，其中将传入和传出数据作为连续数据流处理。</font><font o="1945">通过<code i="1087">spring-cloud-stream-reactive</code>提供对反应性API的支持，需要将其明确添加到您的项目中。</font></p>
</div>
<div class="paragraph">
<p><font o="1946">具有反应性API的编程模型是声明式的，而不是指定如何处理每个单独的消息，您可以使用描述从入站到出站数据流的功能转换的运算符。</font></p>
</div>
<div class="paragraph">
<p><font o="1947">Spring Cloud Stream支持以下反应性API：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1948">反应堆</font></p>
</li>
<li>
<p><font o="1949">RxJava 1.x</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1950">将来，它旨在支持基于活动流的更通用的模型。</font></p>
</div>
<div class="paragraph">
<p><font o="1951">反应式编程模型还使用<code i="1088">@StreamListener</code>注释来设置反应处理程序。</font><font o="1952">差异在于：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1953"><code i="1089">@StreamListener</code>注释不能指定输入或输出，因为它们作为参数提供，并从方法返回值;</font></p>
</li>
<li>
<p><font o="1954">必须使用<code i="1090">@Input</code>和<code i="1091">@Output</code>注释方法的参数，指示输入和分别输出的数据流连接到哪个输入或输出;</font></p>
</li>
<li>
<p><font o="1955">方法的返回值（如果有的话）将用<code i="1092">@Output</code>注释，表示要发送数据的输入。</font></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1956">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1957">反应式编程支持需要Java 1.8。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1958">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1959">截至Spring Cloud Stream 1.1.1及更高版本（从布鲁克林发行版开始列出），反应式编程支持需要使用Reactor 3.0.4.RELEASE和更高版本。</font><font o="1960">不支持早期的Reactor版本（包括3.0.1.RELEASE，3.0.2.RELEASE和3.0.3.RELEASE）。</font><font o="1961"><code i="1093">spring-cloud-stream-reactive</code>将会过渡地检索正确的版本，但项目结构有可能将<code i="1094">io.projectreactor:reactor-core</code>的版本管理到较早版本，特别是在使用Maven时。</font><font o="1962">对于通过Spring Initializr（Spring Boot 1.x）生成的项目，这将覆盖Reactor版本为<code i="1095">2.0.8.RELEASE</code>。</font><font o="1963">在这种情况下，您必须确保释放正确版本的工件。</font><font o="1964">这可以通过在<code i="1096">io.projectreactor:reactor-core</code>上直接依赖于<code i="1097">3.0.4.RELEASE</code>或更高版本的项目来简单地实现。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1965">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1966">术语<code i="1098">reactive</code>的使用目前指的是正在使用的反应性API，而不是执行模型是无效的（即，绑定的端点仍然使用“推”而不是“拉”模型）。</font><font o="1967">虽然通过使用Reactor提供了一些背压支持，但我们希望长期以来通过使用连接的中间件的本机反应客户端来支持完全无反应的管道。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_reactor_based_handlers"><font o="1968">基于反应器的处理程序</font></h5>
<div class="paragraph">
<p><font o="1969">基于反应器的处理程序可以具有以下参数类型：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1970">对于用<code i="1099">@Input</code>注释的参数，它支持反应器类型<code i="1100">Flux</code>。</font><font o="1971">入站通量的参数化遵循与单个消息处理相同的规则：它可以是整个<code i="1101">Message</code>，一个可以是<code i="1102">Message</code>有效负载的POJO，也可以是一个POJO基于<code i="1103">Message</code>内容类型头的转换。</font><font o="1972">提供多个输入;</font></p>
</li>
<li>
<p><font o="1973">对于使用<code i="1104">Output</code>注释的参数，它支持将方法生成的<code i="1106">Flux</code>与输出连接的类型<code i="1105">FluxSender</code>。</font><font o="1974">一般来说，仅当方法可以有多个输出时才建议指定输出作为参数;</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1975">基于反应器的处理程序支持<code i="1107">Flux</code>的返回类型，其中必须使用<code i="1108">@Output</code>注释。</font><font o="1976">当单个输出通量可用时，我们建议使用该方法的返回值。</font></p>
</div>
<div class="paragraph">
<p><font o="1977">这是一个简单的基于反应器的处理器的例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Flux&lt;String&gt; receive(@Input(Processor.INPUT) Flux&lt;String&gt; input) {
    return input.map(s -&gt; s.toUpperCase());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1978">使用输出参数的同一个处理器如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Flux&lt;String&gt; input,
     @Output(Processor.OUTPUT) FluxSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rxjava_1_x_support"><font o="1979">RxJava 1.x支持</font></h5>
<div class="paragraph">
<p><font o="1980">RxJava 1.x处理程序遵循与基于反应器的规则相同的规则，但将使用<code i="1109">Observable</code>和<code i="1110">ObservableSender</code>参数和返回类型。</font></p>
</div>
<div class="paragraph">
<p><font o="1981">所以上面的第一个例子会变成：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Observable&lt;String&gt; receive(@Input(Processor.INPUT) Observable&lt;String&gt; input) {
    return input.map(s -&gt; s.toUpperCase());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="1982">上面的第二个例子将会变成：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Observable&lt;String&gt; input,
     @Output(Processor.OUTPUT) ObservableSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_aggregation"><font o="1983">聚合</font></h4>
<div class="paragraph">
<p><font o="1984">Spring Cloud Stream支持将多个应用程序聚合在一起，直接连接其输入和输出通道，并避免通过代理交换消息的额外成本。</font><font o="1985">从版本1.0的Spring Cloud Stream开始，仅对以下类型的应用程序支持聚合：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><em><font o="1986">来源</font></em><font o="1986"> - 具有名为<code i="1111">output</code>的单个输出通道的应用程序，通常具有类型为<code i="1112">org.springframework.cloud.stream.messaging.Source</code>的单个绑定</font></p>
</li>
<li>
<p><em><font o="1987">接收器</font></em><font o="1987"> - 具有名为<code i="1113">input</code>的单个输入通道的应用程序，通常具有类型为<code i="1114">org.springframework.cloud.stream.messaging.Sink</code>的单个绑定</font></p>
</li>
<li>
<p><em><font o="1988">处理器</font></em><font o="1988"> - 具有名为<code i="1115">input</code>的单个输入通道和名为<code i="1116">output</code>的单个输出通道的应用程序，通常具有类型为<code i="1117">org.springframework.cloud.stream.messaging.Processor</code>的单个绑定。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1989">它们可以通过创建一系列互连的应用程序来聚合在一起，其中序列中的元素的输出通道连接到下一个元素的输入通道（如果存在）。</font><font o="1990">序列可以从</font><em><font o="1990">源</font></em><font o="1990">或</font><em><font o="1990">处理器开始</font></em><font o="1990">，它可以包含任意数量的</font><em><font o="1990">处理器</font></em><font o="1990">，并且必须以</font><em><font o="1990">处理器</font></em><font o="1990">或</font><em><font o="1990">接收器</font></em><font o="1990">结束</font><font o="1990">。</font></p>
</div>
<div class="paragraph">
<p><font o="1991">根据起始和结束元素的性质，序列可以具有一个或多个可绑定的信道，如下所示：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="1992">如果序列从源头开始并以sink结束，则应用程序之间的所有通信都是直接的，并且不会绑定任何通道</font></p>
</li>
<li>
<p><font o="1993">如果序列以处理器开始，则其输入通道将成为聚合的<code i="1118">input</code>通道，并将相应地进行绑定</font></p>
</li>
<li>
<p><font o="1994">如果序列以处理器结束，则其输出通道将成为聚合的<code i="1119">output</code>通道，并将相应地进行绑定</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="1995">使用<code i="1120">AggregateApplicationBuilder</code>实用程序类执行聚合，如以下示例所示。</font><font o="1996">我们考虑一个项目，我们有源，处理器和汇点，可以在项目中定义，或者可以包含在项目的依赖之一中。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="1997">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="1998">如果配置类使用<code i="1121">@SpringBootApplication</code>，聚合应用程序中的每个组件（源，宿或处理器）必须在单独的包中提供。</font><font o="1999">这是为了避免应用程序之间的串扰，由于在同一个包内的配置类上由<code i="1122">@SpringBootApplication</code>执行的类路径扫描。</font><font o="2000">在下面的示例中，可以看到，Source，Processor和Sink应用程序类分组在单独的包中。</font><font o="2001">一个可能的替代方法是在单独的<code i="1123">@Configuration</code>类中提供源，宿或处理器配置，避免使用<code i="1124">@SpringBootApplication</code> / <code i="1125">@ComponentScan</code>并使用它们进行聚合。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.app.mysink;

@SpringBootApplication
@EnableBinding(Sink.class)
public class SinkApplication {

	private static Logger logger = LoggerFactory.getLogger(SinkApplication.class);

	@ServiceActivator(inputChannel=Sink.INPUT)
	public void loggerSink(Object payload) {
		logger.info("Received: " + payload);
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.app.myprocessor;

@SpringBootApplication
@EnableBinding(Processor.class)
public class ProcessorApplication {

	@Transformer
	public String loggerSink(String payload) {
		return payload.toUpperCase();
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.app.mysource;

@SpringBootApplication
@EnableBinding(Source.class)
public class SourceApplication {

	@Bean
	@InboundChannelAdapter(value = Source.OUTPUT)
	public String timerMessageSource() {
		return new SimpleDateFormat().format(new Date());
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2002">每个配置可以用于运行一个单独的组件，但在这种情况下，它们可以聚合在一起，如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.app;

@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).args("--fixedDelay=5000")
			.via(ProcessorApplication.class)
			.to(SinkApplication.class).args("--debug=true").run(args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2003">该序列的起始组件作为<code i="1126">from()</code>方法的参数提供。</font><font o="2004">序列的结尾部分作为<code i="1127">to()</code>方法的参数提供。</font><font o="2005">中间处理器作为<code i="1128">via()</code>方法的参数提供。</font><font o="2006">同一类型的多个处理器可以一起链接（例如，用于具有不同配置的流水线转换）。</font><font o="2007">对于每个组件，构建器可以为Spring Boot配置提供运行时参数。</font></p>
</div>
<div class="sect4">
<h5 id="_configuring_aggregate_application"><font o="2008">配置聚合应用程序</font></h5>
<div class="paragraph">
<p><font o="2009">Spring Cloud Stream支持使用'namespace'作为前缀向聚合应用程序内的各个应用程序传递属性。</font></p>
</div>
<div class="paragraph">
<p><font o="2010">命名空间可以为应用程序设置如下：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).namespace("source").args("--fixedDelay=5000")
			.via(ProcessorApplication.class).namespace("processor1")
			.to(SinkApplication.class).namespace("sink").args("--debug=true").run(args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2011">一旦为单个应用程序设置了“命名空间”，则可以使用任何支持的属性源（命令行，环境属性等）将具有<code i="1129">namespace</code>作为前缀的应用程序属性传递到聚合应用程序，</font></p>
</div>
<div class="paragraph">
<p><font o="2012">例如，要覆盖“source”和“sink”应用程序的默认<code i="1130">fixedDelay</code>和<code i="1131">debug</code>属性：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>java -jar target/MyAggregateApplication-0.0.1-SNAPSHOT.jar --source.fixedDelay=10000 --sink.debug=false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_binding_service_properties_for_non_self_contained_aggregate_application"><font o="2013">为非自包含聚合应用程序配置绑定服务属性</font></h5>
<div class="paragraph">
<p><font o="2014">非自包含聚合应用程序通过聚合应用程序的入站/出站组件（通常为消息通道）中的一个或两者绑定到外部代理，而聚合应用程序内的应用程序是直接绑定的。</font><font o="2015">例如：源应用程序的输出和处理器应用程序的输入是直接绑定的，而处理器的输出通道绑定到代理的外部目的地。</font><font o="2016">当传递非自包含聚合应用程序的绑定服务属性时，需要将绑定服务属性传递给聚合应用程序，而不是将它们设置为单个子应用程序的“args”。</font><font o="2017">例如，</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class SampleAggregateApplication {

	public static void main(String[] args) {
		new AggregateApplicationBuilder()
			.from(SourceApplication.class).namespace("source").args("--fixedDelay=5000")
			.via(ProcessorApplication.class).namespace("processor1").args("--debug=true").run(args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2018">需要将绑定属性<code i="1132">--spring.cloud.stream.bindings.output.destination=processor-output</code>指定为外部配置属性（cmdline arg等）之一。</font></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_binders">Binders</h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2020">Spring Cloud Stream提供了一个Binder抽象，用于连接到外部中间件的物理目标。</font><font o="2021">本节提供有关Binder SPI，其主要组件和实现特定详细信息背后的主要概念的信息。</font></p>
</div>
<div class="sect2">
<h3 id="_producers_and_consumers"><font o="2022">生产者和消费者</font></h3>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/producers-consumers.png" alt="生产者消费者" width="300">
</div>
<div class="title"><font o="2023">图9.生产者和消费者</font></div>
</div>
<div class="paragraph">
<p><font o="2024">甲</font><em><font o="2024">生产者</font></em><font o="2024">是将消息发送到信道的任何组分。</font><font o="2025">该通道可以通过该代理的Binder实现绑定到外部消息代理。</font><font o="2026">当调用<code i="1133">bindProducer()</code>方法时，第一个参数是代理中目标的名称，第二个参数是生成器将发送消息的本地通道实例，第三个参数包含属性（如分区键表达式）在为该通道创建的适配器中使用。</font></p>
</div>
<div class="paragraph">
<p><font o="2027">甲</font><em><font o="2027">消费者</font></em><font o="2027">的是，从一个信道接收的消息的任何组分。</font><font o="2028">与生产者一样，消费者的频道可以绑定到外部消息代理。</font><font o="2029">当调用<code i="1134">bindConsumer()</code>方法时，第一个参数是目标名称，第二个参数提供消费者逻辑组的名称。</font><font o="2030">由给定目的地的消费者绑定表示的每个组接收生产者发送到该目的地的每个消息的副本（即，发布 - 订阅语义）。</font><font o="2031">如果有多个使用相同组名称的消费者实例绑定，那么消息将在这些消费者实例之间进行负载平衡，以便生产者发送的每个消息仅由每个组中的单个消费者实例消耗（即排队语义）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_binder_spi">Binder SPI</h3>
<div class="paragraph">
<p><font o="2033">Binder SPI包括许多接口，即插即用实用程序类和发现策略，提供可插拔机制连接到外部中间件。</font></p>
</div>
<div class="paragraph">
<p><font o="2034">SPI的关键点是<code i="1135">Binder</code>接口，它是将输入和输出连接到外部中间件的策略。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Binder&lt;T, C extends ConsumerProperties, P extends ProducerProperties&gt; {
	Binding&lt;T&gt; bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

	Binding&lt;T&gt; bindProducer(String name, T outboundBindTarget, P producerProperties);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2035">界面参数化，提供多个扩展点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2036">输入和输出绑定目标 - 从版本1.0开始，只支持<code i="1136">MessageChannel</code>，但是这个目标是将来用作扩展点;</font></p>
</li>
<li>
<p><font o="2037">扩展的消费者和生产者属性 - 允许特定的Binder实现来添加可以以类型安全的方式支持的补充属性。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="2038">典型的绑定实现包括以下内容</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2039">一个实现<code i="1137">Binder</code>接口的类;</font></p>
</li>
<li>
<p><font o="2040">一个Spring <code i="1138">@Configuration</code>类，与中间件连接基础架构一起创建上述类型的bean;</font></p>
</li>
<li>
<p><font o="2041">在类路径中找到的包含一个或多个绑定器定义的<code i="1139">META-INF/spring.binders</code>文件，例如</font></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>kafka:\
org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_binder_detection"><font o="2042">Binder检测</font></h3>
<div class="paragraph">
<p><font o="2043">Spring Cloud Stream依赖于Binder SPI的实现来执行将通道连接到消息代理的任务。</font><font o="2044">每个Binder实现通常连接到一种类型的消息系统。</font></p>
</div>
<div class="sect3">
<h4 id="_classpath_detection"><font o="2045">类路径检测</font></h4>
<div class="paragraph">
<p><font o="2046">默认情况下，Spring Cloud Stream依赖于Spring Boot的自动配置来配置绑定过程。</font><font o="2047">如果在类路径中找到单个Binder实现，则Spring Cloud Stream将自动使用。</font><font o="2048">例如，一个旨在绑定到RabbitMQ的Spring Cloud Stream项目可以简单地添加以下依赖项：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2049">对于其他绑定依赖关系的特定maven坐标，请参阅该binder实现的文档。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multiple-binders"><font o="2050">Classpath上有多个Binders</font></h3>
<div class="paragraph">
<p><font o="2051">当类路径中存在多个绑定器时，应用程序必须指明每个通道绑定将使用哪个绑定器。</font><font o="2052">每个binder配置都包含一个<code i="1140">META-INF/spring.binders</code>，它是一个简单的属性文件：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>rabbit:\
org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2053">对于其他提供的绑定实现（例如Kafka），存在类似的文件，并且预期自定义绑定实现也可以提供它们。</font><font o="2054">键代表binder实现的标识名称，而该值是以逗号分隔的配置类列表，每个配置类都包含唯一的一个类型为<code i="1141">org.springframework.cloud.stream.binder.Binder</code>的bean定义。</font></p>
</div>
<div class="paragraph">
<p><font o="2055">可以使用<code i="1142">spring.cloud.stream.defaultBinder</code>属性（例如<code i="1143">spring.cloud.stream.defaultBinder=rabbit</code>）全局执行Binder选择，或通过在每个通道绑定上配置binder来单独执行。</font><font o="2056">例如，从Kafka读取并写入RabbitMQ的处理器应用程序（分别具有用于读/写的名称为<code i="1144">input</code>和<code i="1145">output</code>的通道）可以指定以下配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multiple-systems"><font o="2057">连接到多个系统</font></h3>
<div class="paragraph">
<p><font o="2058">默认情况下，绑定器共享应用程序的Spring Boot自动配置，以便在类路径中找到每个绑定器的一个实例。</font><font o="2059">如果您的应用程序连接到同一类型的多个代理，则可以指定多个绑定器配置，每个具有不同的环境设置。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2060">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2061">打开显式绑定器配置将完全禁用默认绑定器配置过程。</font><font o="2062">如果这样做，所有使用的绑定器都必须包含在配置中。</font><font o="2063">打算透明使用Spring Cloud Stream的框架可能会创建可以通过名称引用的binder配置，但不会影响默认的绑定器配置。</font><font o="2064">为此，绑定器配置可能将其<code i="1146">defaultCandidate</code>标志设置为false，例如<code i="1147">spring.cloud.stream.binders.&lt;configurationName&gt;.defaultCandidate=false</code>。</font><font o="2065">这表示将独立于默认binder配置过程存在的配置。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="2066">例如，这是连接到两个RabbitMQ代理实例的处理器应用程序的典型配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yml" data-lang="yml">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: foo
          binder: rabbit1
        output:
          destination: bar
          binder: rabbit2
      binders:
        rabbit1:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host1&gt;
        rabbit2:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host2&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_binder_configuration_properties"><font o="2067">Binder配置属性</font></h3>
<div class="paragraph">
<p><font o="2068">创建自定义绑定器配置时，以下属性可用。</font><font o="2069">它们必须以<code i="1148">spring.cloud.stream.binders.&lt;configurationName&gt;</code>为前缀。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2070">类型</font></dt>
<dd>
<p><font o="2071">粘合剂类型。</font><font o="2072">它通常引用在类路径中找到的绑定器之一，特别是<code i="1149">META-INF/spring.binders</code>文件中的键。</font></p>
<div class="paragraph">
<p><font o="2073">默认情况下，它具有与配置名称相同的值。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2074">inheritEnvironment</font></dt>
<dd>
<p><font o="2075">配置是否会继承应用程序本身的环境。</font></p>
<div class="paragraph">
<p><font o="2076">默认<code i="1150">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2077">环境</font></dt>
<dd>
<p><font o="2078">一组可用于自定义绑定环境的属性的根。</font><font o="2079">配置此配置后，创建绑定器的上下文不是应用程序上下文的子级。</font><font o="2080">这允许粘合剂组分和应用组分之间的完全分离。</font></p>
<div class="paragraph">
<p><font o="2081">默认<code i="1151">empty</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2082">defaultCandidate</font></dt>
<dd>
<p><font o="2083">粘合剂配置是否被认为是默认的粘合剂的候选者，或者仅在明确引用时才能使用。</font><font o="2084">这允许添加binder配置，而不会干扰默认处理。</font></p>
<div class="paragraph">
<p><font o="2085">默认<code i="1152">true</code>。</font></p>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration_options"><font o="2086">配置选项</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2087">Spring Cloud Stream支持常规配置选项以及绑定和绑定器的配置。</font><font o="2088">一些绑定器允许额外的绑定属性来支持中间件特定的功能。</font></p>
</div>
<div class="paragraph">
<p><font o="2089">可以通过Spring Boot支持的任何机制将配置选项提供给Spring Cloud Stream应用程序。</font><font o="2090">这包括应用程序参数，环境变量和YAML或.properties文件。</font></p>
</div>
<div class="sect2">
<h3 id="_spring_cloud_stream_properties"><font o="2091">Spring Cloud Stream Properties</font></h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2092">spring.cloud.stream.instanceCount</font></dt>
<dd>
<p><font o="2093">应用程序部署实例的数量。</font><font o="2094">必须设置分区，如果使用Kafka。</font></p>
<div class="paragraph">
<p><font o="2095">默认值：<code i="1153">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2096">spring.cloud.stream.instanceIndex</font></dt>
<dd>
<p><font o="2097">应用程序的实例索引：从<code i="1154">0</code>到<code i="1155">instanceCount</code>  -  1的数字。</font><font o="2098">用于分区和使用Kafka。</font><font o="2099">在Cloud Foundry中自动设置以匹配应用程序的实例索引。</font></p>
</dd>
<dt class="hdlist1"><font o="2100">spring.cloud.stream.dynamicDestinations</font></dt>
<dd>
<p><font o="2101">可以动态绑定的目标列表（例如，在动态路由方案中）。</font><font o="2102">如果设置，只能列出目的地。</font></p>
<div class="paragraph">
<p><font o="2103">默认值：空（允许任何目的地绑定）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2104">spring.cloud.stream.defaultBinder</font></dt>
<dd>
<p><font o="2105">如果配置了多个绑定器，则使用默认的binder。</font><font o="2106">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-binders"><font o="2106">Classpath上的Multiple Binders</font></a><font o="2106">。</font></p>
<div class="paragraph">
<p><font o="2107">默认值：空。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2108">spring.cloud.stream.overrideCloudConnectors</font></dt>
<dd>
<p><font o="2109">此属性仅适用于<code i="1156">cloud</code>配置文件激活且Spring Cloud连接器随应用程序一起提供。</font><font o="2110">如果属性为false（默认值），绑定器将检测适合的绑定服务（例如，在Cloud Foundry中为RabbitMQ绑定器绑定的RabbitMQ服务），并将使用它来创建连接（通常通过Spring Cloud连接器）。</font><font o="2111">当设置为true时，此属性指示绑定器完全忽略绑定的服务，并依赖Spring Boot属性（例如，依赖于RabbitMQ绑定器环境中提供的<code i="1157">spring.rabbitmq.*</code>属性）。</font><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-systems"><font o="2112">当连接到多个系统时</font></a><font o="2112">，此属性的典型用法将嵌套在定制环境</font><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-systems"><font o="2112">中</font></a><font o="2112">。</font></p>
<div class="paragraph">
<p><font o="2113">默认值：false。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="binding-properties"><font o="2114">绑定Properties</font></h3>
<div class="paragraph">
<p><font o="2115">绑定属性使用格式<code i="1158">spring.cloud.stream.bindings.&lt;channelName&gt;.&lt;property&gt;=&lt;value&gt;</code>提供。</font><font o="2116"><code i="1159">&lt;channelName&gt;</code>表示正在配置的通道的名称（例如<code i="1161">Source</code>的<code i="1160">output</code>）。</font></p>
</div>
<div class="paragraph">
<p><font o="2117">为了避免重复，Spring Cloud Stream支持所有通道的设置值，格式为<code i="1162">spring.cloud.stream.default.&lt;property&gt;=&lt;value&gt;</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2118">在下面的内容中，我们指出我们在哪里省略了<code i="1163">spring.cloud.stream.bindings.&lt;channelName&gt;.</code>前缀，并且只关注属性名称，但有一个理解，前缀将被包含在运行时。</font></p>
</div>
<div class="sect3">
<h4 id="_properties_for_use_of_spring_cloud_stream"><font o="2119">Properties使用Spring Cloud Stream</font></h4>
<div class="paragraph">
<p><font o="2120">以下绑定属性可用于输入和输出绑定，并且必须以<code i="1164">spring.cloud.stream.bindings.&lt;channelName&gt;.</code>为前缀，例如<code i="1165">spring.cloud.stream.bindings.input.destination=ticktock</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2121">可以使用前缀<code i="1166">spring.cloud.stream.default</code>设置默认值，例如<code i="1167">spring.cloud.stream.default.contentType=application/json</code>。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2122">目的地</font></dt>
<dd>
<p><font o="2123">绑定中间件上的通道的目标目标（例如，RabbitMQ交换或Kafka主题）。</font><font o="2124">如果通道绑定为消费者，则可以将其绑定到多个目标，并且目标名称可以指定为逗号分隔的字符串值。</font><font o="2125">如果未设置，则使用通道名称。</font><font o="2126">此属性的默认值不能被覆盖。</font></p>
</dd>
<dt class="hdlist1"><font o="2127">组</font></dt>
<dd>
<p><font o="2128">渠道的消费群体。</font><font o="2129">仅适用于入站绑定。</font><font o="2130">参见</font><a href="https://springcloud.cc/spring-cloud-dalston.html#consumer-groups"><font o="2130">消费者群体</font></a><font o="2130">。</font></p>
<div class="paragraph">
<p><font o="2131">默认值：null（表示匿名消费者）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2132">内容类型</font></dt>
<dd>
<p><font o="2133">频道的内容类型。</font></p>
<div class="paragraph">
<p><font o="2134">默认值：null（以便不执行类型强制）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2135">粘合剂</font></dt>
<dd>
<p><font o="2136">这种绑定使用的粘合剂。</font><font o="2137">有关详细信息，请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#multiple-binders"><font o="2137">Classpath上的Multiple Binders</font></a><font o="2137">。</font></p>
<div class="paragraph">
<p><font o="2138">默认值：null（默认的binder将被使用，如果存在）。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_properties"><font o="2139">消费者物业</font></h4>
<div class="paragraph">
<p><font o="2140">以下绑定属性仅适用于输入绑定，并且必须以<code i="1168">spring.cloud.stream.bindings.&lt;channelName&gt;.consumer.</code>为前缀，例如<code i="1169">spring.cloud.stream.bindings.input.consumer.concurrency=3</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2141">默认值可以使用前缀<code i="1170">spring.cloud.stream.default.consumer</code>设置，例如<code i="1171">spring.cloud.stream.default.consumer.headerMode=raw</code>。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2142">并发</font></dt>
<dd>
<p><font o="2143">入站消费者的并发性。</font></p>
<div class="paragraph">
<p><font o="2144">默认值：<code i="1172">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2145">分区</font></dt>
<dd>
<p><font o="2146">消费者是否从分区生产者接收数据。</font></p>
<div class="paragraph">
<p><font o="2147">默认值：<code i="1173">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2148">headerMode</font></dt>
<dd>
<p><font o="2149">设置为<code i="1174">raw</code>时，禁用输入头文件解析。</font><font o="2150">仅适用于不支持消息头的消息中间件，并且需要头部嵌入。</font><font o="2151">入站数据来自外部Spring Cloud Stream应用程序时很有用。</font></p>
<div class="paragraph">
<p><font o="2152">默认值：<code i="1175">embeddedHeaders</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2153">maxAttempts</font></dt>
<dd>
<p><font o="2154">如果处理失败，则尝试处理消息的次数（包括第一个）。</font><font o="2155">设置为1以禁用重试。</font></p>
<div class="paragraph">
<p><font o="2156">默认值：<code i="1176">3</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2157">backOffInitialInterval</font></dt>
<dd>
<p><font o="2158">退避初始间隔重试。</font></p>
<div class="paragraph">
<p><font o="2159">默认值：<code i="1177">1000</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2160">backOffMaxInterval</font></dt>
<dd>
<p><font o="2161">最大回退间隔。</font></p>
<div class="paragraph">
<p><font o="2162">默认值：<code i="1178">10000</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2163">backOffMultiplier</font></dt>
<dd>
<p><font o="2164">退避倍数。</font></p>
<div class="paragraph">
<p><font o="2165">默认值：<code i="1179">2.0</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2166">instanceIndex</font></dt>
<dd>
<p><font o="2167">当设置为大于等于零的值时，允许自定义此消费者的实例索引（如果与<code i="1180">spring.cloud.stream.instanceIndex</code>不同）。</font><font o="2168">设置为负值时，它将默认为<code i="1181">spring.cloud.stream.instanceIndex</code>。</font></p>
<div class="paragraph">
<p><font o="2169">默认值：<code i="1182">-1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2170">instanceCount</font></dt>
<dd>
<p><font o="2171">当设置为大于等于零的值时，允许自定义此消费者的实例计数（如果与<code i="1183">spring.cloud.stream.instanceCount</code>不同）。</font><font o="2172">当设置为负值时，它将默认为<code i="1184">spring.cloud.stream.instanceCount</code>。</font></p>
<div class="paragraph">
<p><font o="2173">默认值：<code i="1185">-1</code>。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_producer_properties"><font o="2174">制作人Properties</font></h4>
<div class="paragraph">
<p><font o="2175">以下绑定属性仅可用于输出绑定，并且必须以<code i="1186">spring.cloud.stream.bindings.&lt;channelName&gt;.producer.</code>为前缀，例如<code i="1187">spring.cloud.stream.bindings.input.producer.partitionKeyExpression=payload.id</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2176">默认值可以使用前缀<code i="1188">spring.cloud.stream.default.producer</code>设置，例如<code i="1189">spring.cloud.stream.default.producer.partitionKeyExpression=payload.id</code>。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2177">partitionKeyExpression</font></dt>
<dd>
<p><font o="2178">一个确定如何分配出站数据的SpEL表达式。</font><font o="2179">如果设置，或者如果设置了<code i="1190">partitionKeyExtractorClass</code>，则该通道上的出站数据将被分区，并且<code i="1191">partitionCount</code>必须设置为大于1的值才能生效。</font><font o="2180">这两个选项是相互排斥的。</font><font o="2181">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#partitioning"><font o="2181">分区支持</font></a><font o="2181">。</font></p>
<div class="paragraph">
<p><font o="2182">默认值：null。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2183">partitionKeyExtractorClass</font></dt>
<dd>
<p><font o="2184">一个<code i="1192">PartitionKeyExtractorStrategy</code>实现。</font><font o="2185">如果设置，或者如果设置了<code i="1193">partitionKeyExpression</code>，则该通道上的出站数据将被分区，并且<code i="1194">partitionCount</code>必须设置为大于1的值才能生效。</font><font o="2186">这两个选项是相互排斥的。</font><font o="2187">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#partitioning"><font o="2187">分区支持</font></a><font o="2187">。</font></p>
<div class="paragraph">
<p><font o="2188">默认值：null。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2189">partitionSelectorClass</font></dt>
<dd>
<p><font o="2190">一个<code i="1195">PartitionSelectorStrategy</code>实现。</font><font o="2191">与<code i="1196">partitionSelectorExpression</code>相互排斥。</font><font o="2192">如果没有设置，则分区将被选为<code i="1197">hashCode(key) % partitionCount</code>，其中<code i="1198">key</code>通过<code i="1199">partitionKeyExpression</code>或<code i="1200">partitionKeyExtractorClass</code>计算。</font></p>
<div class="paragraph">
<p><font o="2193">默认值：null。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2194">partitionSelectorExpression</font></dt>
<dd>
<p><font o="2195">用于自定义分区选择的SpEL表达式。</font><font o="2196">与<code i="1201">partitionSelectorClass</code>相互排斥。</font><font o="2197">如果没有设置，则分区将被选为<code i="1202">hashCode(key) % partitionCount</code>，其中<code i="1203">key</code>通过<code i="1204">partitionKeyExpression</code>或<code i="1205">partitionKeyExtractorClass</code>计算。</font></p>
<div class="paragraph">
<p><font o="2198">默认值：null。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2199">partitionCount</font></dt>
<dd>
<p><font o="2200">如果启用分区，则数据的目标分区数。</font><font o="2201">如果生产者被分区，则必须设置为大于1的值。</font><font o="2202">在Kafka，解释为提示; </font><font o="2203">而是使用更大的和目标主题的分区计数。</font></p>
<div class="paragraph">
<p><font o="2204">默认值：<code i="1206">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2205">requiredGroups</font></dt>
<dd>
<p><font o="2206">生成者必须确保消息传递的组合的逗号分隔列表，即使它们在创建之后启动（例如，通过在RabbitMQ中预先创建持久队列）。</font></p>
</dd>
<dt class="hdlist1"><font o="2207">headerMode</font></dt>
<dd>
<p><font o="2208">设置为<code i="1207">raw</code>时，禁用输出上的标题嵌入。</font><font o="2209">仅适用于不支持消息头的消息中间件，并且需要头部嵌入。</font><font o="2210">生成非Spring Cloud Stream应用程序的数据时很有用。</font></p>
<div class="paragraph">
<p><font o="2211">默认值：<code i="1208">embeddedHeaders</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2212">useNativeEncoding</font></dt>
<dd>
<p><font o="2213">当设置为<code i="1209">true</code>时，出站消息由客户端库直接序列化，必须相应配置（例如设置适当的Kafka生产者值序列化程序）。</font><font o="2214">当使用此配置时，出站消息编组不是基于绑定的<code i="1210">contentType</code>。</font><font o="2215">当使用本地编码时，消费者有责任使用适当的解码器（例如：Kafka消费者价值解串器）来对入站消息进行反序列化。</font><font o="2216">此外，当使用本机编码/解码时，<code i="1211">headerMode</code>属性将被忽略，标题不会嵌入到消息中。</font></p>
<div class="paragraph">
<p><font o="2217">默认值：<code i="1212">false</code>。</font></p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamicdestination"><font o="2218">使用动态绑定目的地</font></h3>
<div class="paragraph">
<p><font o="2219">除了通过<code i="1213">@EnableBinding</code>定义的通道之外，Spring Cloud Stream允许应用程序将消息发送到动态绑定的目的地。</font><font o="2220">这是有用的，例如，当目标目标需要在运行时确定。</font><font o="2221">应用程序可以使用<code i="1215">@EnableBinding</code>注册自动注册的<code i="1214">BinderAwareChannelResolver</code> bean。</font></p>
</div>
<div class="paragraph">
<p><font o="2222">属性“spring.cloud.stream.dynamicDestinations”可用于将动态目标名称限制为预先已知的集合（白名单）。</font><font o="2223">如果属性未设置，任何目的地都可以动态绑定。</font></p>
</div>
<div class="paragraph">
<p><font o="2224">可以直接使用<code i="1216">BinderAwareChannelResolver</code>，如以下示例所示，其中REST控制器使用路径变量来确定目标通道。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

	@Autowired
	private BinderAwareChannelResolver resolver;

	@RequestMapping(path = "/{target}", method = POST, consumes = "*/*")
	@ResponseStatus(HttpStatus.ACCEPTED)
	public void handleRequest(@RequestBody String body, @PathVariable("target") target,
	       @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
		sendMessage(body, target, contentType);
	}

	private void sendMessage(String body, String target, Object contentType) {
		resolver.resolveDestination(target).send(MessageBuilder.createMessage(body,
				new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2225">在默认端口8080上启动应用程序后，发送以下数据时：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">curl -H "Content-Type: application/json" -X POST -d "customer-1" http://localhost:8080/customers

curl -H "Content-Type: application/json" -X POST -d "order-1" http://localhost:8080/orders</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2226">目的地的客户和“订单”是在经纪人中创建的（例如：在Rabbit的情况下进行交换，或者在Kafka的情况下为主题），其名称为“客户”和“订单”，数据被发布到适当的目的地。</font></p>
</div>
<div class="paragraph">
<p><font o="2227"><code i="1217">BinderAwareChannelResolver</code>是通用的Spring Integration <code i="1218">DestinationResolver</code>，可以注入其他组件。</font><font o="2228">例如，在使用基于传入JSON消息的<code i="1219">target</code>字段的SpEL表达式的路由器中。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

	@Autowired
	private BinderAwareChannelResolver resolver;


	@RequestMapping(path = "/", method = POST, consumes = "application/json")
	@ResponseStatus(HttpStatus.ACCEPTED)
	public void handleRequest(@RequestBody String body, @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
		sendMessage(body, contentType);
	}

	private void sendMessage(Object body, Object contentType) {
		routerChannel().send(MessageBuilder.createMessage(body,
				new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
	}

	@Bean(name = "routerChannel")
	public MessageChannel routerChannel() {
		return new DirectChannel();
	}

	@Bean
	@ServiceActivator(inputChannel = "routerChannel")
	public ExpressionEvaluatingRouter router() {
        ExpressionEvaluatingRouter router =
            new ExpressionEvaluatingRouter(new SpelExpressionParser().parseExpression("payload.target"));
		router.setDefaultOutputChannelName("default-output");
		router.setChannelResolver(resolver);
		return router;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contenttypemanagement"><font o="2229">内容类型和转换</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2230">要允许您传播关于已生成消息的内容类型的信息，默认情况下，Spring Cloud Stream附加<code i="1220">contentType</code>标头到出站消息。</font><font o="2231">对于不直接支持头文件的中间件，Spring Cloud Stream提供了自己的自动将邮件包裹在自己的信封中的机制。</font><font o="2232">对于支持头文件的中间件，Spring Cloud Stream应用程序可以从非Spring Cloud Stream应用程序接收具有给定内容类型的消息。</font></p>
</div>
<div class="paragraph">
<p><font o="2233">Spring Cloud Stream可以通过两种方式处理基于此信息的消息：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2234">通过其入站和出站渠道的<code i="1221">contentType</code>设置</font></p>
</li>
<li>
<p><font o="2235">通过对<code i="1222">@StreamListener</code>注释的方法执行的参数映射</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="2236">Spring Cloud Stream允许您使用绑定的<code i="1223">spring.cloud.stream.bindings.&lt;channelName&gt;.content-type</code>属性声明性地配置输入和输出的类型转换。</font><font o="2237">请注意，一般类型转换也可以通过在应用程序中使用变压器轻松实现。</font><font o="2238">目前，Spring Cloud Stream本机支持流中常用的以下类型转换：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font></font></strong><font o="2239">来自/从</font><strong><font o="2239">POJO的</font></strong><strong><font o="2239">JSON</font></strong><strong><font></font></strong></p>
</li>
<li>
<p><strong><font o="2240">JSON</font></strong><font o="2240"> /从</font><a href="https://github.com/spring-projects/spring-tuple/blob/master/spring-tuple/src/main/java/org/springframework/tuple/Tuple.java"><font o="2240">org.springframework.tuple.Tuple</font></a></p>
</li>
<li>
<p><strong><font o="2241">对象</font></strong><font o="2241">到/来自</font><strong><font o="2241">byte []</font></strong><font o="2241">：用于远程传输的原始字节序列化，应用程序发出的字节，或使用Java序列化转换为字节（要求对象为Serializable）</font></p>
</li>
<li>
<p><strong><font o="2242">字符串</font></strong><font o="2242">到/来自</font><strong><font o="2242">byte []</font></strong></p>
</li>
<li>
<p><strong><font o="2243">对象</font></strong><font o="2243">到</font><strong><font o="2243">纯文本</font></strong><font o="2243">（调用对象的</font><em><font o="2243">toString（）</font></em><font o="2243">方法）</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="2244">其中</font><em><font o="2244">JSON</font></em><font o="2244">表示包含</font><em><font o="2244">JSON</font></em><font o="2244">的字节数组或字符串有效负载。</font><font o="2245">目前，对象可以从JSON字节数组或字符串转换。</font><font o="2246">转换为JSON总是产生一个String。</font></p>
</div>
<div class="paragraph">
<p><font o="2247">如果在出站通道上没有设置<code i="1224">content-type</code>属性，则Spring Cloud Stream将使用基于</font><a href="https://github.com/EsotericSoftware/kryo"><font o="2247">Kryo</font></a><font o="2247">序列化框架</font><font o="2247">的序列化程序对有效负载进行</font><font o="2247">序列化。</font><font o="2248">在目的地反序列化消息需要在接收者的类路径上存在有效载荷类。</font></p>
</div>
<div class="sect2">
<h3 id="mime-types"><font o="2249">MIME类型</font></h3>
<div class="paragraph">
<p><font o="2250"><code i="1225">content-type</code>值被解析为媒体类型，例如<code i="1226">application/json</code>或<code i="1227">text/plain;charset=UTF-8</code>。</font><font o="2251">MIME类型对于指示如何转换为String或byte []内容特别有用。</font><font o="2252">Spring Cloud Stream还使用MIME类型格式来表示Java类型，使用具有<code i="1229">type</code>参数的一般类型<code i="1228">application/x-java-object</code>。</font><font o="2253">例如，<code i="1230">application/x-java-object;type=java.util.Map</code>或<code i="1231">application/x-java-object;type=com.bar.Foo</code>可以设置为输入绑定的<code i="1232">content-type</code>属性。</font><font o="2254">此外，Spring Cloud Stream提供自定义MIME类型，特别是<code i="1233">application/x-spring-tuple</code>来指定元组。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="mime-types-and-java-types"><font o="2255">MIME类型和Java类型</font></h3>
<div class="paragraph">
<p><font o="2256">类型转换Spring Cloud Stream提供的开箱即用如下表所示：“源有效载荷”是指转换前的有效载荷，“目标有效载荷”是指转换后的“有效载荷”。</font><font o="2257">类型转换可以在“生产者”一侧（输出）或“消费者”一侧（输入）上进行。</font></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><font o="2258">来源有效载荷</font></th>
<th class="tableblock halign-left valign-top"><font o="2259">目标有效载荷</font></th>
<th class="tableblock halign-left valign-top"><font o="2260"><code i="1234">content-type</code>标题（来源讯息）</font></th>
<th class="tableblock halign-left valign-top"><font o="2261"><code i="1235">content-type</code>标题（转换后）</font></th>
<th class="tableblock halign-left valign-top"><font o="2262">注释</font></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">POJO</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">JSON String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">ignored</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/json</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">Tuple</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">JSON String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">ignored</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/json</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="2263">JSON是为Tuple量身定制的</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">POJO</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">String (toString())</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">ignored</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">text/plain, java.lang.String</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">POJO</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">byte[] (java.io serialized)</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">ignored</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/x-java-serialized-object</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">JSON byte[] or String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">POJO</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/json (or none)</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/x-java-object</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">byte[] or String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">Serializable</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/x-java-serialized-object</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/x-java-object</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">JSON byte[] or String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">Tuple</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/json (or none)</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/x-spring-tuple</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">byte[]</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">any</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">text/plain, java.lang.String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="2264">将应用在content-type头中指定的任何Charset</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">byte[]</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">any</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application/octet-stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="2265">将应用在content-type头中指定的任何Charset</font></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2266">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2267">转换适用于需要类型转换的有效内容。</font><font o="2268">例如，如果应用程序生成带有outputType = application / json的XML字符串，则该有效载荷将不会从XML转换为JSON。</font><font o="2269">这是因为发送到出站通道的有效载荷已经是一个String，所以在运行时不会应用转换。</font><font o="2270">同样重要的是要注意，当使用默认的序列化机制时，必须在发送和接收应用程序之间共享有效负载类，并且与二进制内容兼容。</font><font o="2271">当应用程序代码在两个应用程序中独立更改时，这可能会产生问题，因为二进制格式和代码可能会变得不兼容。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2272">提示</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2273">虽然入站和出站渠道都支持转换，但特别推荐将其用于转发出站邮件。</font><font o="2274">对于入站邮件的转换，特别是当目标是POJO时，<code i="1236">@StreamListener</code>支持将自动执行转换。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_message_conversion"><font o="2275">自定义邮件转换</font></h3>
<div class="paragraph">
<p><font o="2276">除了支持开箱即用的转换，Spring Cloud Stream还支持注册您自己的邮件转换实现。</font><font o="2277">这允许您以各种自定义格式（包括二进制）发送和接收数据，并将其与特定的<code i="1237">contentTypes</code>关联。</font><font o="2278">Spring Cloud Stream将所有类型为<code i="1238">org.springframework.messaging.converter.MessageConverter</code>的bean注册为自定义消息转换器以及开箱即用消息转换器。</font></p>
</div>
<div class="paragraph">
<p><font o="2279">如果您的消息转换器需要使用特定的<code i="1239">content-type</code>和目标类（用于输入和输出），则消息转换器需要扩展<code i="1240">org.springframework.messaging.converter.AbstractMessageConverter</code>。</font><font o="2280">对于使用<code i="1241">@StreamListener</code>的转换，实现<code i="1242">org.springframework.messaging.converter.MessageConverter</code>的消息转换器就足够了。</font></p>
</div>
<div class="paragraph">
<p><font o="2281">以下是在Spring Cloud Stream应用程序中创建消息转换器bean（内容类型为<code i="1243">application/bar</code>）的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter customMessageConverter() {
    return new MyCustomMessageConverter();
  }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class MyCustomMessageConverter extends AbstractMessageConverter {

	public MyCustomMessageConverter() {
		super(new MimeType("application", "bar"));
	}

	@Override
  protected boolean supports(Class&lt;?&gt; clazz) {
    return (Bar.class == clazz);
  }

	@Override
	protected Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
		Object payload = message.getPayload();
		return (payload instanceof Bar ? payload : new Bar((byte[]) payload));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2282">Spring Cloud Stream还为基于Avro的转换器和模式演进提供支持。</font><font o="2283">详情请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#schema-evolution"><font o="2283">具体章节</font></a><font o="2283">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="__code_streamlistener_code_and_message_conversion"><font o="2284"><code i="1244">@StreamListener</code>和讯息转换</font></h3>
<div class="paragraph">
<p><font o="2285"><code i="1245">@StreamListener</code>注释提供了一种方便的方式来转换传入的消息，而不需要指定输入通道的内容类型。</font><font o="2286">在使用<code i="1246">@StreamListener</code>注释的方法的调度过程中，如果参数需要转换，将自动应用转换。</font></p>
</div>
<div class="paragraph">
<p><font o="2287">例如，让我们考虑一个带有<code i="1247">{"greeting":"Hello, world"}</code>的String内容的消息，并且在输入通道上收到<code i="1249">application/json</code>的<code i="1249">application/json</code>标题。</font><font o="2288">让我们考虑接收它的以下应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public class GreetingMessage {

  String greeting;

  public String getGreeting() {
    return greeting;
  }

  public void setGreeting(String greeting) {
    this.greeting = greeting;
  }
}

@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class GreetingSink {

		@StreamListener(Sink.INPUT)
		public void receive(Greeting greeting) {
			// handle Greeting
		}
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2289">该方法的参数将自动填充包含JSON字符串的未编组形式的POJO。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="schema-evolution"><font o="2290">Schema进化支持</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2291">Spring Cloud Stream通过其<code i="1250">spring-cloud-stream-schema</code>模块为基于模式的消息转换器提供支持。</font><font o="2292">目前，基于模式的消息转换器开箱即用的唯一序列化格式是Apache Avro，在将来的版本中可以添加更多的格式。</font></p>
</div>
<div class="sect2">
<h3 id="_apache_avro_message_converters"><font o="2293">Apache Avro讯息转换器</font></h3>
<div class="paragraph">
<p><font o="2294"><code i="1251">spring-cloud-stream-schema</code>模块包含可用于Apache Avro序列化的两种类型的消息转换器：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2295">使用序列化/反序列化对象的类信息的转换器，或者启动时已知位置的模式;</font></p>
</li>
<li>
<p><font o="2296">转换器使用模式注册表 - 他们在运行时定位模式，以及随着域对象的发展动态注册新模式。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_converters_with_schema_support"><font o="2297">具有模式支持的转换器</font></h3>
<div class="paragraph">
<p><font o="2298"><code i="1252">AvroSchemaMessageConverter</code>支持使用预定义模式或使用类中可用的模式信息（反射或包含在<code i="1253">SpecificRecord</code>）中的序列化和反序列化消息。</font><font o="2299">如果转换的目标类型是<code i="1254">GenericRecord</code>，则必须设置模式。</font></p>
</div>
<div class="paragraph">
<p><font o="2300">对于使用它，您可以简单地将其添加到应用程序上下文中，可选地指定一个或多个<code i="1255">MimeTypes</code>将其关联。</font><font o="2301">默认<code i="1256">MimeType</code>为<code i="1257">application/avro</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2302">以下是在注册Apache Avro <code i="1258">MessageConverter</code>的宿应用程序中进行配置的示例，而不需要预定义的模式：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      return new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2303">相反，这里是一个应用程序，注册一个具有预定义模式的转换器，可以在类路径中找到：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
      converter.setSchemaLocation(new ClassPathResource("schemas/User.avro"));
      return converter;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2304">为了了解模式注册表客户端转换器，我们将首先描述模式注册表支持。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registry_support"><font o="2305">Schema注册表支持</font></h3>
<div class="paragraph">
<p><font o="2306">大多数序列化模型，特别是旨在跨不同平台和语言进行可移植性的序列化模型，依赖于描述数据如何在二进制有效载荷中被序列化的模式。</font><font o="2307">为了序列化数据然后解释它，发送方和接收方都必须访问描述二进制格式的模式。</font><font o="2308">在某些情况下，可以从序列化的有效载荷类型或从反序列化时的目标类型中推断出模式，但是在许多情况下，应用程序可以从访问描述二进制数据格式的显式模式中受益。</font><font o="2309">模式注册表允许您以文本格式（通常为JSON）存储模式信息，并使该信息可访问需要它的各种应用程序以二进制格式接收和发送数据。</font><font o="2310">一个模式可以作为一个元组引用，它由</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2311">作为</font><font o="2311">模式的逻辑名称的</font><em><font o="2311">主题</font></em><font o="2311"> ;</font></p>
</li>
<li>
<p><font o="2312">模式</font><em><font o="2312">版本</font></em><font o="2312"> ;</font></p>
</li>
<li>
<p><font o="2313">描述</font><em><font o="2313">数据</font></em><font o="2313">   的二进制格式</font><font o="2313">的模式</font><em><font o="2313">格式</font></em><font o="2313">。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registry_server"><font o="2314">Schema注册服务器</font></h3>
<div class="paragraph">
<p><font o="2315">Spring Cloud Stream提供了模式注册表服务器实现。</font><font o="2316">为了使用它，您可以简单地将<code i="1259">spring-cloud-stream-schema-server</code>工件添加到项目中，并使用<code i="1260">@EnableSchemaRegistryServer</code>注释，将模式注册表服务器REST控制器添加到应用程序中。</font><font o="2317">此注释旨在与Spring Boot Web应用程序一起使用，服务器的监听端口由<code i="1261">server.port</code>设置控制。</font><font o="2318"><code i="1262">spring.cloud.stream.schema.server.path</code>设置可用于控制模式服务器的根路径（特别是嵌入其他应用程序时）。</font><font o="2319"><code i="1263">spring.cloud.stream.schema.server.allowSchemaDeletion</code>布尔设置可以删除模式。</font><font o="2320">默认情况下，这是禁用的。</font></p>
</div>
<div class="paragraph">
<p><font o="2321">模式注册表服务器使用关系数据库来存储模式。</font><font o="2322">默认情况下，它使用一个嵌入式数据库。</font><font o="2323">您可以使用</font><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql"><font o="2323">Spring Boot SQL数据库和JDBC配置选项</font></a><font o="2323">自定义模式存储</font><font o="2323">。</font></p>
</div>
<div class="paragraph">
<p><font o="2324">启用模式注册表的Spring Boot应用程序如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableSchemaRegistryServer
public class SchemaRegistryServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SchemaRegistryServerApplication.class, args);
	}
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_schema_registry_server_api"><font o="2325">Schema注册服务器API</font></h4>
<div class="paragraph">
<p><font o="2326">Schema注册服务器API由以下操作组成：</font></p>
</div>
<div class="sect4">
<h5 id="__code_post_code"><code>POST /</code></h5>
<div class="paragraph">
<p><font o="2327">注册一个新的架构</font></p>
</div>
<div class="paragraph">
<p><font o="2328">接受具有以下字段的JSON有效载荷：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2329"><code i="1264">subject</code>模式主题;</font></p>
</li>
<li>
<p><font o="2330"><code i="1265">format</code>模式格式;</font></p>
</li>
<li>
<p><font o="2331"><code i="1266">definition</code>模式定义。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="2332">响应是JSON格式的模式对象，包含以下字段：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2333"><code i="1267">id</code>模式标识;</font></p>
</li>
<li>
<p><font o="2334"><code i="1268">subject</code>模式主题;</font></p>
</li>
<li>
<p><font o="2335"><code i="1269">format</code>模式格式;</font></p>
</li>
<li>
<p><font o="2336"><code i="1270">version</code>模式版本;</font></p>
</li>
<li>
<p><font o="2337"><code i="1271">definition</code>模式定义。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="__code_get_subject_format_version_code"><code>GET /{subject}/{format}/{version}</code></h5>
<div class="paragraph">
<p><font o="2338">根据其主题，格式和版本检索现有模式。</font></p>
</div>
<div class="paragraph">
<p><font o="2339">响应是JSON格式的模式对象，包含以下字段：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2340"><code i="1272">id</code>模式标识;</font></p>
</li>
<li>
<p><font o="2341"><code i="1273">subject</code>模式主题;</font></p>
</li>
<li>
<p><font o="2342"><code i="1274">format</code>模式格式;</font></p>
</li>
<li>
<p><font o="2343"><code i="1275">version</code>模式版本;</font></p>
</li>
<li>
<p><font o="2344"><code i="1276">definition</code>模式定义。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="__code_get_subject_format_code"><code>GET /{subject}/{format}</code></h5>
<div class="paragraph">
<p><font o="2345">根据其主题和格式检索现有模式的列表。</font></p>
</div>
<div class="paragraph">
<p><font o="2346">响应是JSON格式的每个模式对象的模式列表，包含以下字段：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2347"><code i="1277">id</code>模式标识;</font></p>
</li>
<li>
<p><font o="2348"><code i="1278">subject</code>模式主题;</font></p>
</li>
<li>
<p><font o="2349"><code i="1279">format</code>模式格式;</font></p>
</li>
<li>
<p><font o="2350"><code i="1280">version</code>模式版本;</font></p>
</li>
<li>
<p><font o="2351"><code i="1281">definition</code>模式定义。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="__code_get_schemas_id_code"><code>GET /schemas/{id}</code></h5>
<div class="paragraph">
<p><font o="2352">通过其id来检索现有的模式。</font></p>
</div>
<div class="paragraph">
<p><font o="2353">响应是JSON格式的模式对象，包含以下字段：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2354"><code i="1282">id</code>模式标识;</font></p>
</li>
<li>
<p><font o="2355"><code i="1283">subject</code>模式主题;</font></p>
</li>
<li>
<p><font o="2356"><code i="1284">format</code>模式格式;</font></p>
</li>
<li>
<p><font o="2357"><code i="1285">version</code>模式版本;</font></p>
</li>
<li>
<p><font o="2358"><code i="1286">definition</code>模式定义。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="__code_delete_subject_format_version_code"><code>DELETE /{subject}/{format}/{version}</code></h5>
<div class="paragraph">
<p><font o="2359">按其主题，格式和版本删除现有模式。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="__code_delete_schemas_id_code"><code>DELETE /schemas/{id}</code></h5>
<div class="paragraph">
<p><font o="2360">按其ID删除现有模式。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="__code_delete_subject_code"><code>DELETE /{subject}</code></h5>
<div class="paragraph">
<p><font o="2361">按其主题删除现有模式。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2362">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2363">本说明仅适用于Spring Cloud Stream 1.1.0.RELEASE的用户。</font><font o="2364">Spring Cloud Stream 1.1.0.RELEASE使用表名<code i="1287">schema</code>存储<code i="1288">Schema</code>对象，这是一些数据库实现中的关键字。</font><font o="2365">为了避免将来发生任何冲突，从1.1.1.RELEASE开始，我们选择了存储表的名称<code i="1289">SCHEMA_REPOSITORY</code>。</font><font o="2366">建议任何正在升级的Spring Cloud Stream 1.1.0.RELEASE用户在升级之前将其现有模式迁移到新表。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registry_client"><font o="2367">Schema注册表客户端</font></h3>
<div class="paragraph">
<p><font o="2368">与模式注册表服务器交互的客户端抽象是<code i="1290">SchemaRegistryClient</code>接口，具有以下结构：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface SchemaRegistryClient {

	SchemaRegistrationResponse register(String subject, String format, String schema);

	String fetch(SchemaReference schemaReference);

	String fetch(Integer id);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2369">Spring Cloud Stream提供了开箱即用的实现，用于与其自己的模式服务器交互，以及与Confluent Schema注册表进行交互。</font></p>
</div>
<div class="paragraph">
<p><font o="2370">可以使用<code i="1291">@EnableSchemaRegistryClient</code>配置Spring Cloud Stream模式注册表的客户端，如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">  @EnableBinding(Sink.class)
  @SpringBootApplication
  @EnableSchemaRegistryClient
  public static class AvroSinkApplication {
    ...
  }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2371">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2372">优化了默认转换器，以缓存来自远程服务器的模式，而且还会非常昂贵的<code i="1292">parse()</code>和<code i="1293">toString()</code>方法。</font><font o="2373">因此，它使用不缓存响应的<code i="1294">DefaultSchemaRegistryClient</code>。</font><font o="2374">如果您打算直接在代码上使用客户端，您可以请求一个也缓存要创建的响应的bean。</font><font o="2375">为此，只需将属性<code i="1295">spring.cloud.stream.schemaRegistryClient.cached=true</code>添加到应用程序属性中即可。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_schema_registry_client_properties"><font o="2376">Schema注册表客户端属性</font></h4>
<div class="paragraph">
<p><font o="2377">Schema注册表客户端支持以下属性：</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2378">spring.cloud.stream.schemaRegistryClient.endpoint</font></dt>
<dd>
<p><font o="2379">模式服务器的位置。</font><font o="2380">在设置时使用完整的URL，包括协议（<code i="1296">http</code>或<code i="1297">https</code>），端口和上下文路径。</font></p>
</dd>
<dt class="hdlist1"><font o="2381">默认</font></dt>
<dd>
<p><code><a href="http://localhost:8990/" class="bare">http://localhost:8990/</a></code></p>
</dd>
<dt class="hdlist1"><font o="2382">spring.cloud.stream.schemaRegistryClient.cached</font></dt>
<dd>
<p><font o="2383">客户端是否应缓存模式服务器响应。</font><font o="2384">通常设置为<code i="1298">false</code>，因为缓存发生在消息转换器中。</font><font o="2385">使用模式注册表客户端的客户端应将其设置为<code i="1299">true</code>。</font></p>
</dd>
<dt class="hdlist1"><font o="2386">默认</font></dt>
<dd>
<p><code>true</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_avro_schema_registry_client_message_converters"><font o="2387">Avro Schema注册表客户端消息转换器</font></h3>
<div class="paragraph">
<p><font o="2388">对于在应用程序上下文中注册了<code i="1300">SchemaRegistryClient</code> bean的Spring Boot应用程序，Spring Cloud Stream将自动配置使用模式注册表客户端进行模式管理的Apache Avro消息转换器。</font><font o="2389">这简化了模式演进，因为接收消息的应用程序可以轻松访问可与自己的读取器模式进行协调的写入器模式。</font></p>
</div>
<div class="paragraph">
<p><font o="2390">对于出站邮件，如果频道的内容类型设置为<code i="1302">application/*+avro</code>，<code i="1301">MessageConverter</code>将被激活，例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-properties" data-lang="properties">spring.cloud.stream.bindings.output.contentType=application/*+avro</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2391">在出站转换期间，消息转换器将尝试基于其类型推断出站消息的模式，并使用<code i="1303">SchemaRegistryClient</code>根据有效载荷类型将其注册到主题。</font><font o="2392">如果已经找到相同的模式，那么将会检索对它的引用。</font><font o="2393">如果没有，则将注册模式并提供新的版本号。</font><font o="2394">该消息将使用<code i="1305">application/[prefix].[subject].v[version]+avro</code>的方案<code i="1304">contentType</code>头发送，其中<code i="1306">prefix</code>是可配置的，并且从有效载荷类型推导出<code i="1307">subject</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2395">例如，类型为<code i="1308">User</code>的消息可以作为内容类型为<code i="1309">application/vnd.user.v2+avro</code>的二进制有效载荷发送，其中<code i="1310">user</code>是主题，<code i="1311">2</code>是版本号。</font></p>
</div>
<div class="paragraph">
<p><font o="2396">当接收到消息时，转换器将从传入消息的头部推断出模式引用，并尝试检索它。</font><font o="2397">该模式将在反序列化过程中用作写入器模式。</font></p>
</div>
<div class="sect3">
<h4 id="_avro_schema_registry_message_converter_properties"><font o="2398">Avro Schema注册表消息转换器属性</font></h4>
<div class="paragraph">
<p><font o="2399">如果您已通过设置<code i="1312">spring.cloud.stream.bindings.output.contentType=application/*+avro</code>启用基于Avro的模式注册表客户端，则可以使用以下属性自定义注册的行为。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2400">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</font></dt>
<dd>
<p><font o="2401">如果您希望转换器使用反射从POJO推断Schema，则启用。</font></p>
</dd>
<dt class="hdlist1"><font o="2402">默认</font></dt>
<dd>
<p><code>false</code></p>
</dd>
<dt class="hdlist1"><font o="2403">spring.cloud.stream.schema.avro.readerSchema</font></dt>
<dd>
<p><font o="2404">Avro通过查看编写器模式（源有效载荷）和读取器模式（应用程序有效负载）来比较模式版本，查看</font><a href="https://avro.apache.org/docs/1.7.6/spec.html"><font o="2404">Avro</font></a><font o="2404">文档以获取更多信息。</font><font o="2405">如果设置，这将覆盖模式服务器上的任何查找，并将本地模式用作读取器模式。</font></p>
</dd>
<dt class="hdlist1"><font o="2406">默认</font></dt>
<dd>
<p><code>null</code></p>
</dd>
<dt class="hdlist1"><font o="2407">spring.cloud.stream.schema.avro.schemaLocations</font></dt>
<dd>
<p><font o="2408">使用Schema服务器注册此属性中列出的任何<code i="1313">.avsc</code>文件。</font></p>
</dd>
<dt class="hdlist1"><font o="2409">默认</font></dt>
<dd>
<p><code>empty</code></p>
</dd>
<dt class="hdlist1"><font o="2410">spring.cloud.stream.schema.avro.prefix</font></dt>
<dd>
<p><font o="2411">要在Content-Type头上使用的前缀。</font></p>
</dd>
<dt class="hdlist1"><font o="2412">默认</font></dt>
<dd>
<p><code>vnd</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_schema_registration_and_resolution"><font o="2413">Schema注册和解决</font></h3>
<div class="paragraph">
<p><font o="2414">为了更好地了解Spring Cloud Stream注册和解决新模式以及其使用Avro模式比较功能，我们将提供两个单独的子部分：一个用于注册，一个用于解析模式。</font></p>
</div>
<div class="sect3">
<h4 id="_schema_registration_process_serialization"><font o="2415">Schema注册流程（序列化）</font></h4>
<div class="paragraph">
<p><font o="2416">注册过程的第一部分是从通过信道发送的有效载荷中提取模式。</font><font o="2417">Avro类型，如<code i="1314">SpecificRecord</code>或<code i="1315">GenericRecord</code>已经包含一个模式，可以从实例中立即检索。</font><font o="2418">在POJO的情况下，如果属性<code i="1316">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</code>设置为<code i="1317">true</code>（默认），则会推断出一个模式。</font></p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/schema_resolution.png" alt="模式解析" width="300">
</div>
<div class="title"><font o="2419">图10. Schema Writer Resolution Process</font></div>
</div>
<div class="paragraph">
<p><font o="2420">一旦获得了架构，转换器就会从远程服务器加载其元数据（版本）。</font><font o="2421">首先，它查询本地缓存，如果没有找到它，则将数据提交到将使用版本控制信息回复的服务器。</font><font o="2422">转换器将始终缓存结果，以避免为每个需要序列化的新消息查询Schema服务器的开销。</font></p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/registration.png" alt="注册" width="300">
</div>
<div class="title"><font o="2423">图11. Schema注册流程</font></div>
</div>
<div class="paragraph">
<p><font o="2424">使用模式版本信息，转换器设置消息的<code i="1318">contentType</code>头，以携带版本信息，如<code i="1319">application/vnd.user.v1+avro</code></font></p>
</div>
</div>
<div class="sect3">
<h4 id="_schema_resolution_process_deserialization"><font o="2425">Schema解析过程（反序列化）</font></h4>
<div class="paragraph">
<p><font o="2426">当读取包含版本信息的消息（即，具有上述方案的<code i="1320">contentType</code>标头）时，转换器将查询Schema服务器以获取</font><font o="2426">消息</font><font o="2426">的</font><strong><font o="2426">写入器</font></strong><font o="2426">架构。</font><font o="2427">一旦找到传入消息的正确架构，它就会检索读取器架构，并使用Avro的架构解析支持将其读入读取器定义（设置默认值和缺少的属性）。</font></p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/schema_reading.png" alt="模式阅读" width="300">
</div>
<div class="title"><font o="2428">图12. Schema阅读决议程序</font></div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2429">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2430">了解编写器架构（写入消息的应用程序）和读取器架构（接收应用程序）之间的区别很重要。</font><font o="2431">请花点时间阅读</font><a href="https://avro.apache.org/docs/1.7.6/spec.html"><font o="2431">Avro术语</font></a><font o="2431">并了解此过程。</font><font o="2432">Spring Cloud Stream将始终提取writer模式以确定如何读取消息。</font><font o="2433">如果您想要Avro的架构演进支持工作，您需要确保为您的应用程序正确设置了readerSchema。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inter_application_communication"><font o="2434">应用间通信</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_connecting_multiple_application_instances"><font o="2435">连接多个应用程序实例</font></h3>
<div class="paragraph">
<p><font o="2436">虽然Spring Cloud Stream使个人Spring Boot应用程序轻松连接到消息传递系统，但是Spring Cloud Stream的典型场景是创建多应用程序管道，其中微服务应用程序将数据发送给彼此。</font><font o="2437">您可以通过将相邻应用程序的输入和输出目标相关联来实现此场景。</font></p>
</div>
<div class="paragraph">
<p><font o="2438">假设设计要求时间源应用程序将数据发送到日志接收应用程序，则可以在两个应用程序中使用名为<code i="1321">ticktock</code>的公共目标进行绑定。</font></p>
</div>
<div class="paragraph">
<p><font o="2439">时间来源（具有频道名称<code i="1322">output</code>）将设置以下属性：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.output.destination=ticktock</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2440">日志接收器（通道名称为<code i="1323">input</code>）将设置以下属性：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.input.destination=ticktock</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instance_index_and_instance_count"><font o="2441">实例索引和实例计数</font></h3>
<div class="paragraph">
<p><font o="2442">当扩展Spring Cloud Stream应用程序时，每个实例都可以接收有关同一个应用程序的其他实例数量以及自己的实例索引的信息。</font><font o="2443">Spring Cloud Stream通过<code i="1324">spring.cloud.stream.instanceCount</code>和<code i="1325">spring.cloud.stream.instanceIndex</code>属性执行此操作。</font><font o="2444">例如，如果HDFS宿应用程序有三个实例，则所有三个实例将<code i="1326">spring.cloud.stream.instanceCount</code>设置为<code i="1327">3</code>，并且各个应用程序将<code i="1328">spring.cloud.stream.instanceIndex</code>设置为<code i="1329">0</code>，<code i="1330">1</code>和<code i="1331">2</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2445">当通过Spring Cloud数据流部署Spring Cloud Stream应用程序时，这些属性将自动配置; </font><font o="2446">当Spring Cloud Stream应用程序独立启动时，必须正确设置这些属性。</font><font o="2447">默认情况下，<code i="1332">spring.cloud.stream.instanceCount</code>为<code i="1333">1</code>，<code i="1334">spring.cloud.stream.instanceIndex</code>为<code i="1335">0</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2448">在放大的情况下，这两个属性的正确配置对于解决分区行为（见下文）一般很重要，并且某些绑定器（例如，Kafka binder）总是需要这两个属性，以确保该数据在多个消费者实例之间正确分割。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_partitioning"><font o="2449">分区</font></h3>
<div class="sect3">
<h4 id="_configuring_output_bindings_for_partitioning"><font o="2450">配置输出绑定进行分区</font></h4>
<div class="paragraph">
<p><font o="2451">输出绑定被配置为通过设置其唯一的一个<code i="1336">partitionKeyExpression</code>或<code i="1337">partitionKeyExtractorClass</code>属性以及其<code i="1338">partitionCount</code>属性来发送分区数据。</font><font o="2452">例如，以下是一个有效和典型的配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2453">基于上述示例配置，使用以下逻辑将数据发送到目标分区。</font></p>
</div>
<div class="paragraph">
<p><font o="2454">基于<code i="1339">partitionKeyExpression</code>，为发送到分区输出通道的每个消息计算分区密钥的值。</font><font o="2455"><code i="1340">partitionKeyExpression</code>是一个Spel表达式，它根据出站消息进行评估，以提取分区键。</font></p>
</div>
<div class="paragraph">
<p><font o="2456">如果SpEL表达式不足以满足您的需要，您可以通过将属性<code i="1341">partitionKeyExtractorClass</code>设置为实现<code i="1342">org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>接口的类来计算分区键值。</font><font o="2457">虽然Spel表达式通常足够，但更复杂的情况可能会使用自定义实现策略。</font><font o="2458">在这种情况下，属性“partitionKeyExtractorClass”可以设置如下：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.output.producer.partitionKeyExtractorClass=com.example.MyKeyExtractor
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2459">一旦计算了消息密钥，分区选择过程将确定目标分区为<code i="1343">0</code>和<code i="1344">partitionCount - 1</code>之间的值。</font><font o="2460">在大多数情况下，默认计算基于公式<code i="1345">key.hashCode() % partitionCount</code>。</font><font o="2461">这可以通过设置要针对'key'（通过<code i="1346">partitionSelectorExpression</code>属性）进行评估的Spel表达式或通过设置<code i="1347">org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code>实现（通过<code i="1348">partitionSelectorClass</code>属性））进行自定义。</font></p>
</div>
<div class="paragraph">
<p><font o="2462">“partitionSelectorExpression”和“partitionSelectorClass”的绑定级属性可以类似于上述示例中指定的“partitionKeyExpression”和“partitionKeyExtractorClass”属性的类型。</font><font o="2463">可以为更高级的场景配置其他属性，如以下部分所述。</font></p>
</div>
<div class="sect4">
<h5 id="_spring_managed_custom_code_partitionkeyextractorclass_code_implementations"><font o="2464">Spring  - 管理的自定义<code i="1349">PartitionKeyExtractorClass</code>实现</font></h5>
<div class="paragraph">
<p><font o="2465">在上面的示例中，<code i="1350">MyKeyExtractor</code>之类的自定义策略由Spring Cloud Stream直接实例化。</font><font o="2466">在某些情况下，必须将这样的自定义策略实现创建为Spring bean，以便能够由Spring管理，以便它可以执行依赖注入，属性绑定等。可以通过将其配置为应用程序上下文中的@Bean，并使用完全限定类名作为bean的名称，如以下示例所示。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@Bean(name="com.example.MyKeyExtractor")
public MyKeyExtractor extractor() {
    return new MyKeyExtractor();
}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2467">作为Spring bean，自定义策略从Spring bean的完整生命周期中受益。</font><font o="2468">例如，如果实现需要直接访问应用程序上下文，则可以实现“ApplicationContextAware”。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_input_bindings_for_partitioning"><font o="2469">配置输入绑定进行分区</font></h5>
<div class="paragraph">
<p><font o="2470">输入绑定（通道名称为<code i="1351">input</code>）被配置为通过在应用程序本身设置其<code i="1352">partitioned</code>属性以及<code i="1353">instanceIndex</code>和<code i="1354">instanceCount</code>属性来接收分区数据，如以下示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2471"><code i="1355">instanceCount</code>值表示数据需要分区的应用程序实例的总数，<code i="1356">instanceIndex</code>必须是<code i="1357">0</code>和<code i="1358">instanceCount - 1</code>之间的多个实例的唯一值。</font><font o="2472">实例索引帮助每个应用程序实例识别从其接收数据的唯一分区（或者在Kafka的分区集合的情况下）。</font><font o="2473">重要的是正确设置两个值，以确保所有数据都被使用，并且应用程序实例接收到互斥数据集。</font></p>
</div>
<div class="paragraph">
<p><font o="2474">虽然使用多个实例进行分区数据处理的场景可能会在独立情况下进行复杂化，但是通过将输入和输出值正确填充并依赖于运行时基础架构，Spring Cloud数据流可以显着简化流程。提供有关实例索引和实例计数的信息。</font></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing"><font o="2475">测试</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2476">Spring Cloud Stream支持测试您的微服务应用程序，而无需连接到消息系统。</font><font o="2477">您可以使用<code i="1360">spring-cloud-stream-test-support</code>库提供的<code i="1359">TestSupportBinder</code>，可以将其作为测试依赖项添加到应用程序中：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">   &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
       &lt;scope&gt;test&lt;/scope&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2478">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2479"><code i="1361">TestSupportBinder</code>使用Spring Boot自动配置机制取代类路径中找到的其他绑定。</font><font o="2480">因此，添加binder作为依赖关系时，请确保正在使用<code i="1362">test</code>范围。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="2481"><code i="1363">TestSupportBinder</code>允许用户与绑定的频道进行交互，并检查应用程序发送和接收的消息</font></p>
</div>
<div class="paragraph">
<p><font o="2482">对于出站消息通道，<code i="1364">TestSupportBinder</code>注册单个订户，并将应用程序发送的消息保留在<code i="1365">MessageCollector</code>中。</font><font o="2483">它们可以在测试过程中被检索，并对它们做出断言。</font></p>
</div>
<div class="paragraph">
<p><font o="2484">用户还可以将消息发送到入站消息通道，以便消费者应用程序可以使用消息。</font><font o="2485">以下示例显示了如何在处理器上测试输入和输出通道。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message&lt;String&gt; message = new GenericMessage&lt;&gt;("hello");
    processor.input().send(message);
    Message&lt;String&gt; received = (Message&lt;String&gt;) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2486">在上面的示例中，我们正在创建一个具有输入和输出通道的应用程序，通过<code i="1366">Processor</code>接口绑定。</font><font o="2487">绑定的接口被注入测试，所以我们可以访问这两个通道。</font><font o="2488">我们正在输入频道发送消息，我们使用Spring Cloud Stream测试支持提供的<code i="1367">MessageCollector</code>来捕获消息已经被发​​送到输出通道。</font><font o="2489">收到消息后，我们可以验证组件是否正常工作。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_health_indicator_4"><font o="2490">健康指标</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2491">Spring Cloud Stream为粘合剂提供健康指标。</font><font o="2492">它以<code i="1368">binders</code>的名义注册，可以通过设置<code i="1369">management.health.binders.enabled</code>属性启用或禁用。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metrics_emitter"><font o="2493">指标发射器</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2494">Spring Cloud Stream提供了一个名为<code i="1370">spring-cloud-stream-metrics</code>的模块，可以用来从</font><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html"><font o="2494">Spring Boot度量端点</font></a><font o="2494">到命名通道</font><font o="2494">发出任何可用度量</font><font o="2494">。</font><font o="2495">该模块允许运营商从流应用收集指标，而不依赖轮询其端点。</font></p>
</div>
<div class="paragraph">
<p><font o="2496">当您设置度量绑定的目标名称（例如<code i="1371">spring.cloud.stream.bindings.applicationMetrics.destination=&lt;DESTINATION_NAME&gt;</code>）时，该模块将被激活。</font><font o="2497">可以以与任何其他生成器绑定相似的方式配置<code i="1372">applicationMetrics</code>。</font><font o="2498"><code i="1374">applicationMetrics</code>的<code i="1373">contentType</code>默认设置为<code i="1375">application/json</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2499">以下属性可用于自定义度量标准的排放：</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2500">spring.cloud.stream.metrics.key</font></dt>
<dd>
<p><font o="2501">要发射的度量的名称。</font><font o="2502">应该是每个应用程序的唯一值。</font></p>
</dd>
<dt class="hdlist1"><font o="2503">默认</font></dt>
<dd>
<p><code>${spring.application.name:${vcap.application.name:${spring.config.name:application}}}</code></p>
</dd>
<dt class="hdlist1"><font o="2504">spring.cloud.stream.metrics.prefix</font></dt>
<dd>
<p><font o="2505">前缀字符串，以前缀到度量键。</font></p>
<div class="paragraph">
<p><font o="2506">默认值：``</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2507">spring.cloud.stream.metrics.properties</font></dt>
<dd>
<p><font o="2508">就像<code i="1376">includes</code>选项一样，它允许将白名单应用程序属性添加到度量有效负载</font></p>
<div class="paragraph">
<p><font o="2509">默认值：null。</font></p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><font o="2510">有关度量导出过程的详细概述，请参见</font><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-metric-writers"><font o="2510">Spring Boot参考文档</font></a><font o="2510">。</font><font o="2511">Spring Cloud Stream提供了一个名为<code i="1377">application</code>的指标导出器，可以通过常规</font><a href="https://github.com/spring-projects/spring-boot/blob/1.5.x/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/metrics/export/TriggerProperties.java"><font o="2511">Spring Boot指标配置属性进行配置</font></a><font o="2511">。</font></p>
</div>
<div class="paragraph">
<p><font o="2512">可以通过使用出口商的全局Spring Boot配置设置或使用特定于导出器的属性来配置导出器。</font><font o="2513">要使用全局配置设置，属性应以<code i="1378">spring.metric.export</code>为前缀（例如<code i="1379">spring.metric.export.includes=integration**</code>）。</font><font o="2514">这些配置选项将适用于所有出口商（除非它们的配置不同）。</font><font o="2515">或者，如果要使用与其他出口商不同的配置设置（例如，限制发布的度量数量），则可以使用前缀<code i="1380">spring.metrics.export.triggers.application</code>配置Spring Cloud Stream提供的度量导出器（例如<code i="1381">spring.metrics.export.triggers.application.includes=integration**</code>）。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2516">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2517">由于Spring Boot的</font><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-relaxed-binding"><font o="2517">轻松约束</font></a><font o="2517">，所包含的属性的值可能与原始值稍有不同。</font></p>
</div>
<div class="paragraph">
<p><font o="2518">作为经验法则，度量导出器将尝试使用点符号（例如<code i="1382">JAVA_HOME</code>成为<code i="1383">java.home</code>）以一致的格式标准化所有属性。</font></p>
</div>
<div class="paragraph">
<p><font o="2519">规范化的目标是使下游用户能够始终如一地接收属性名称，无论它们如何设置在受监视的应用程序上（<code i="1384">--spring.application.name</code>或<code i="1385">SPRING_APPLICATION_NAME</code>始终会生成<code i="1386">spring.application.name</code>）。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="2520">以下是通过以下命令以JSON格式发布到频道的数据的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>java -jar time-source.jar \
    --spring.cloud.stream.bindings.applicationMetrics.destination=someMetrics \
    --spring.cloud.stream.metrics.properties=spring.application** \
    --spring.metrics.export.includes=integration.channel.input**,integration.channel.output**</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2521">得到的JSON是：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-javascript" data-lang="javascript">{
   "name":"time-source",
   "metrics":[
      {
         "name":"integration.channel.output.errorRate.mean",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.max",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.min",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.stdev",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.errorRate.count",
         "value":0.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendCount",
         "value":6.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.mean",
         "value":0.994885872292989,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.max",
         "value":1.006247080013156,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.min",
         "value":1.0012035220116378,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.stdev",
         "value":6.505181111084848E-4,
         "timestamp":"2017-04-11T16:56:35.790Z"
      },
      {
         "name":"integration.channel.output.sendRate.count",
         "value":6.0,
         "timestamp":"2017-04-11T16:56:35.790Z"
      }
   ],
   "createdTime":"2017-04-11T20:56:35.790Z",
   "properties":{
      "spring.application.name":"time-source",
      "spring.application.index":"0"
   }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_samples"><font o="2522">样品</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2523">对于Spring Cloud Stream示例，请参阅</font><font o="2523">GitHub上</font><font o="2523">的</font><a href="https://github.com/spring-cloud/spring-cloud-stream-samples"><font o="2523">spring-cloud-stream样本</font></a><font o="2523">存储库。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started"><font o="2524">入门</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="2525">要开始创建Spring Cloud Stream应用程序，请访问</font><a href="https://start.spring.io/"><font o="2525">Spring Initializr</font></a><font o="2525">并创建一个名为“GreetingSource”的新Maven项目。</font><font o="2526">在下拉菜单中选择Spring Boot {supported-spring-boot-version}。</font><font o="2527">在“ </font><em><font o="2527">搜索依赖关系”</font></em><font o="2527">文本框中键入<code i="1387">Stream Rabbit</code>或<code i="1388">Stream Kafka</code>，具体取决于您要使用的binder。</font></p>
</div>
<div class="paragraph">
<p><font o="2528">接下来，在与<code i="1390">GreetingSourceApplication</code>类相同的包中创建一个新类<code i="1389">GreetingSource</code>。</font><font o="2529">给它以下代码：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.annotation.InboundChannelAdapter;

@EnableBinding(Source.class)
public class GreetingSource {

    @InboundChannelAdapter(Source.OUTPUT)
    public String greet() {
        return "hello world " + System.currentTimeMillis();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2530"><code i="1391">@EnableBinding</code>注释是触发Spring Integration基础架构组件的创建。</font><font o="2531">具体来说，它将创建一个Kafka连接工厂，一个Kafka出站通道适配器，并在Source界面中定义消息通道：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2532">自动配置还创建一个默认轮询器，以便每秒调用<code i="1392">greet()</code>方法一次。</font><font o="2533">标准的Spring Integration <code i="1393">@InboundChannelAdapter</code>注释使用返回值作为消息的有效内容向源的输出通道发送消息。</font></p>
</div>
<div class="paragraph">
<p><font o="2534">要测试驱动此设置，请运行Kafka消息代理。</font><font o="2535">一个简单的方法是使用Docker镜像：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code># On OS X
$ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=`docker-machine ip \`docker-machine active\`` --env ADVERTISED_PORT=9092 spotify/kafka

# On Linux
$ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=localhost --env ADVERTISED_PORT=9092 spotify/kafka</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2536">构建应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">./mvnw clean package</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2537">消费者应用程序以类似的方式进行编码。</font><font o="2538">返回Initializr并创建另一个名为LoggingSink的项目。</font><font o="2539">然后在与类<code i="1395">LoggingSinkApplication</code>相同的包中创建一个新类<code i="1394">LoggingSink</code>，并使用以下代码：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.cloud.stream.messaging.Sink;

@EnableBinding(Sink.class)
public class LoggingSink {

    @StreamListener(Sink.INPUT)
    public void log(String message) {
        System.out.println(message);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2540">构建应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">./mvnw clean package</pre>
</div>
</div>
<div class="paragraph">
<p><font o="2541">要将GreetingSource应用程序连接到LoggingSink应用程序，每个应用程序必须共享相同的目标名称。</font><font o="2542">启动这两个应用程序如下所示，您将看到消费者应用程序打印“hello world”和时间戳到控制台：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>cd GreetingSource
java -jar target/GreetingSource-0.0.1-SNAPSHOT.jar --spring.cloud.stream.bindings.output.destination=mydest

cd LoggingSink
java -jar target/LoggingSink-0.0.1-SNAPSHOT.jar --server.port=8090 --spring.cloud.stream.bindings.input.destination=mydest</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2543">（不同的服务器端口可以防止两个应用程序中用于维护Spring Boot执行器端点的HTTP端口的冲突。）</font></p>
</div>
<div class="paragraph">
<p><font o="2544">LoggingSink应用程序的输出将如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>[           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8090 (http)
[           main] com.example.LoggingSinkApplication       : Started LoggingSinkApplication in 6.828 seconds (JVM running for 7.371)
hello world 1458595076731
hello world 1458595077732
hello world 1458595078733
hello world 1458595079734
hello world 1458595080735</code></pre>
</div>
</div>
</div>
</div>
<h1 id="_binder_implementations" class="sect0"><font o="2545">Binder实施</font></h1>
<div class="sect1">
<h2 id="_apache_kafka_binder"><font o="2546">Apache Kafka Binder</font></h2>
<div class="sectionbody">

<div class="sect2">
<h3 id="_usage"><font o="2547">用法</font></h3>
<div class="paragraph">
<p><font o="2548">对于使用Apache Kafka绑定器，您只需要使用以下Maven坐标将其添加到您的Spring Cloud Stream应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2549">或者，您也可以使用Spring Cloud Stream Kafka Starter。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apache_kafka_binder_overview"><font o="2550">Apache Kafka Binder概述</font></h3>
<div class="paragraph">
<p><font o="2551">以下可以看到Apache Kafka绑定器操作的简化图。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/kafka-binder.png" alt="卡夫卡粘合剂" width="300">
</div>
<div class="title"><font o="2552">图13. Kafka Binder</font></div>
</div>
<div class="paragraph">
<p><font o="2553">Apache Kafka Binder实现将每个目标映射到Apache Kafka主题。</font><font o="2554">消费者组织直接映射到相同的Apache Kafka概念。</font><font o="2555">分区也直接映射到Apache Kafka分区。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_options_2"><font o="2556">配置选项</font></h3>
<div class="paragraph">
<p><font o="2557">本节包含Apache Kafka绑定器使用的配置选项。</font></p>
</div>
<div class="paragraph">
<p><font o="2558">有关binder的常见配置选项和属性，请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#binding-properties"><font o="2558">核心文档</font></a><font o="2558">。</font></p>
</div>
<div class="sect3">
<h4 id="_kafka_binder_properties">Kafka Binder Properties</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2560">spring.cloud.stream.kafka.binder.brokers</font></dt>
<dd>
<p><font o="2561">Kafka活页夹将连接的经纪人列表。</font></p>
<div class="paragraph">
<p><font o="2562">默认值：<code i="1396">localhost</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2563">spring.cloud.stream.kafka.binder.defaultBrokerPort</font></dt>
<dd>
<p><font o="2564">  <code i="1397">brokers</code>允许使用或不使用端口信息指定的主机（例如，<code i="1398">host1,host2:port2</code>）。</font><font o="2565">当在代理列表中没有配置端口时，这将设置默认端口。</font></p>
<div class="paragraph">
<p><font o="2566">默认值：<code i="1399">9092</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2567">spring.cloud.stream.kafka.binder.zkNodes</font></dt>
<dd>
<p><font o="2568">Kafka绑定器可以连接的ZooKeeper节点列表。</font></p>
<div class="paragraph">
<p><font o="2569">默认值：<code i="1400">localhost</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2570">spring.cloud.stream.kafka.binder.defaultZkPort</font></dt>
<dd>
<p><font o="2571">  <code i="1401">zkNodes</code>允许使用或不使用端口信息指定的主机（例如，<code i="1402">host1,host2:port2</code>）。</font><font o="2572">当在节点列表中没有配置端口时，这将设置默认端口。</font></p>
<div class="paragraph">
<p><font o="2573">默认值：<code i="1403">2181</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2574">spring.cloud.stream.kafka.binder.configuration</font></dt>
<dd>
<p><font o="2575">  客户端属性（生产者和消费者）的密钥/值映射传递给由绑定器创建的所有客户端。</font><font o="2576">由于这些属性将被生产者和消费者使用，所以使用应该限于常见的属性，特别是安全设置。</font></p>
<div class="paragraph">
<p><font o="2577">默认值：空地图。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2578">spring.cloud.stream.kafka.binder.headers</font></dt>
<dd>
<p><font o="2579">将由活页夹传送的自定义标题列表。</font></p>
<div class="paragraph">
<p><font o="2580">默认值：空。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2581">spring.cloud.stream.kafka.binder.offsetUpdateTimeWindow</font></dt>
<dd>
<p><font o="2582">  以毫秒为单位的频率（以毫秒为单位）保存偏移量。</font><font o="2583"><code i="1404">0</code>忽略。</font></p>
<div class="paragraph">
<p><font o="2584">默认值：<code i="1405">10000</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2585">spring.cloud.stream.kafka.binder.offsetUpdateCount</font></dt>
<dd>
<p><font o="2586">  频率，更新次数，哪些消耗的偏移量会持续存在。</font><font o="2587"><code i="1406">0</code>忽略。</font><font o="2588">与<code i="1407">offsetUpdateTimeWindow</code>相互排斥。</font></p>
<div class="paragraph">
<p><font o="2589">默认值：<code i="1408">0</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2590">spring.cloud.stream.kafka.binder.requiredAcks</font></dt>
<dd>
<p><font o="2591">经纪人所需的acks数量。</font></p>
<div class="paragraph">
<p><font o="2592">默认值：<code i="1409">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2593">spring.cloud.stream.kafka.binder.minPartitionCount</font></dt>
<dd>
<p><font o="2594">  只有设置<code i="1410">autoCreateTopics</code>或<code i="1411">autoAddPartitions</code>才有效。</font><font o="2595">绑定器在其生成/消耗数据的主题上配置的全局最小分区数。</font><font o="2596">它可以由生产者的<code i="1412">partitionCount</code>设置或生产者的<code i="1413">instanceCount</code> * <code i="1414">concurrency</code>设置的值替代（如果更大）。</font></p>
<div class="paragraph">
<p><font o="2597">默认值：<code i="1415">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2598">spring.cloud.stream.kafka.binder.replicationFactor</font></dt>
<dd>
<p><font o="2599">如果<code i="1416">autoCreateTopics</code>处于活动状态，则自动创建主题的复制因子。</font></p>
<div class="paragraph">
<p><font o="2600">默认值：<code i="1417">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2601">spring.cloud.stream.kafka.binder.autoCreateTopics</font></dt>
<dd>
<p><font o="2602">  如果设置为<code i="1418">true</code>，绑定器将自动创建新主题。</font><font o="2603">如果设置为<code i="1419">false</code>，则绑定器将依赖于已配置的主题。</font><font o="2604">在后一种情况下，如果主题不存在，则绑定器将无法启动。</font><font o="2605">值得注意的是，此设置与代理的<code i="1420">auto.topic.create.enable</code>设置无关，并不影响它：如果服务器设置为自动创建主题，则可以将其创建为元数据检索请求的一部分，并使用默认代理设置。</font></p>
<div class="paragraph">
<p><font o="2606">默认值：<code i="1421">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2607">spring.cloud.stream.kafka.binder.autoAddPartitions</font></dt>
<dd>
<p><font o="2608">  如果设置为<code i="1422">true</code>，则绑定器将根据需要创建新的分区。</font><font o="2609">如果设置为<code i="1423">false</code>，则绑定器将依赖于已配置的主题的分区大小。</font><font o="2610">如果目标主题的分区计数小于预期值，则绑定器将无法启动。</font></p>
<div class="paragraph">
<p><font o="2611">默认值：<code i="1424">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2612">spring.cloud.stream.kafka.binder.socketBufferSize</font></dt>
<dd>
<p><font o="2613">Kafka消费者使用的套接字缓冲区的大小（以字节为单位）。</font></p>
<div class="paragraph">
<p><font o="2614">默认值：<code i="1425">2097152</code>。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_kafka_consumer_properties"><font o="2615">Kafka消费者Properties</font></h4>
<div class="paragraph">
<p><font o="2616">以下属性仅适用于Kafka消费者，必须以<code i="1426">spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.consumer.</code>为前缀。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2617">autoRebalanceEnabled</font></dt>
<dd>
<p><font o="2618">当<code i="1427">true</code>，主题分区将在消费者组的成员之间自动重新平衡。</font><font o="2619">当<code i="1428">false</code>根据<code i="1429">spring.cloud.stream.instanceCount</code>和<code i="1430">spring.cloud.stream.instanceIndex</code>为每个消费者分配一组固定的分区。</font><font o="2620">这需要在每个启动的实例上适当地设置<code i="1431">spring.cloud.stream.instanceCount</code>和<code i="1432">spring.cloud.stream.instanceIndex</code>属性。</font><font o="2621">在这种情况下，属性<code i="1433">spring.cloud.stream.instanceCount</code>通常必须大于1。</font></p>
<div class="paragraph">
<p><font o="2622">默认值：<code i="1434">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2623">autoCommitOffset</font></dt>
<dd>
<p><font o="2624">  是否在处理邮件时自动提交偏移量。</font><font o="2625">如果设置为<code i="1435">false</code>，则入站消息中将显示带有<code i="1437">org.springframework.kafka.support.Acknowledgment</code>类型的密钥<code i="1436">kafka_acknowledgment</code>的报头。</font><font o="2626">应用程序可以使用此标头来确认消息。</font><font o="2627">有关详细信息，请参阅示例部分。</font><font o="2628">当此属性设置为<code i="1438">false</code>时，Kafka binder将ack模式设置为<code i="1439">org.springframework.kafka.listener.AbstractMessageListenerContainer.AckMode.MANUAL</code>。</font></p>
<div class="paragraph">
<p><font o="2629">默认值：<code i="1440">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2630">autoCommitOnError</font></dt>
<dd>
<p><font o="2631">  只有<code i="1441">autoCommitOffset</code>设置为<code i="1442">true</code>才有效。</font><font o="2632">如果设置为<code i="1443">false</code>，它会禁止导致错误的邮件的自动提交，并且只会为成功的邮件执行提交，允许流在上次成功处理的邮件中自动重播，以防持续发生故障。</font><font o="2633">如果设置为<code i="1444">true</code>，它将始终自动提交（如果启用了自动提交）。</font><font o="2634">如果没有设置（默认），它实际上具有与<code i="1445">enableDlq</code>相同的值，如果它们被发送到DLQ，则自动提交错误的消息，否则不提交它们。</font></p>
<div class="paragraph">
<p><font o="2635">默认值：未设置。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2636">recoveryInterval</font></dt>
<dd>
<p><font o="2637">连接恢复尝试之间的间隔，以毫秒为单位。</font></p>
<div class="paragraph">
<p><font o="2638">默认值：<code i="1446">5000</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2639">resetOffsets</font></dt>
<dd>
<p><font o="2640">是否将消费者的偏移量重置为<code i="1447">startOffset</code>提供的值。</font></p>
<div class="paragraph">
<p><font o="2641">默认值：<code i="1448">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2642">开始偏移</font></dt>
<dd>
<p><font o="2643">  新组的起始偏移量，或<code i="1449">resetOffsets</code>为<code i="1450">true</code>时的起始偏移量。</font><font o="2644">允许的值：<code i="1451">earliest</code>，<code i="1452">latest</code>。</font><font o="2645">如果消费者组被明确设置为消费者'绑定'（通过<code i="1453">spring.cloud.stream.bindings.&lt;channelName&gt;.group</code>），那么'startOffset'设置为<code i="1454">earliest</code>; </font><font o="2646">否则对于<code i="1456">anonymous</code>消费者组，设置为<code i="1455">latest</code>。</font></p>
<div class="paragraph">
<p><font o="2647">默认值：null（相当于<code i="1457">earliest</code>）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2648">enableDlq</font></dt>
<dd>
<p><font o="2649">当设置为true时，它将为消费者发送启用DLQ行为。</font><font o="2650">默认情况下，导致错误的邮件将转发到名为<code i="1458">error.&lt;destination&gt;.&lt;group&gt;</code>的主题。</font><font o="2651">DLQ主题名称可以通过属性<code i="1459">dlqName</code>配置。</font><font o="2652">对于错误数量相对较少并且重播整个原始主题可能太麻烦的情况，这为更常见的Kafka重播场景提供了另一种选择。</font></p>
<div class="paragraph">
<p><font o="2653">默认值：<code i="1460">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2654">组态</font></dt>
<dd>
<p><font o="2655">使用包含通用Kafka消费者属性的键/值对映射。</font></p>
<div class="paragraph">
<p><font o="2656">默认值：空地图。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2657">dlqName</font></dt>
<dd>
<p><font o="2658">接收错误消息的DLQ主题的名称。</font></p>
<div class="paragraph">
<p><font o="2659">默认值：null（如果未指定，将导致错误的消息将转发到名为<code i="1461">error.&lt;destination&gt;.&lt;group&gt;</code>的主题）。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_kafka_producer_properties"><font o="2660">Kafka生产者Properties</font></h4>
<div class="paragraph">
<p><font o="2661">以下属性仅适用于Kafka生产者，必须以<code i="1462">spring.cloud.stream.kafka.bindings.&lt;channelName&gt;.producer.</code>为前缀。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2662">缓冲区大小</font></dt>
<dd>
<p><font o="2663">上限（以字节为单位），Kafka生产者将在发送之前尝试批量的数据量。</font></p>
<div class="paragraph">
<p><font o="2664">默认值：<code i="1463">16384</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2665">同步</font></dt>
<dd>
<p><font o="2666">生产者是否是同步的</font></p>
<div class="paragraph">
<p><font o="2667">默认值：<code i="1464">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2668">batchTimeout</font></dt>
<dd>
<p><font o="2669">  生产者在发送之前等待多长时间，以便允许更多消息在同一批次中累积。</font><font o="2670">（通常，生产者根本不等待，并且简单地发送在先前发送进行中累积的所有消息。）非零值可能会以延迟为代价增加吞吐量。</font></p>
<div class="paragraph">
<p><font o="2671">默认值：<code i="1465">0</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2672">组态</font></dt>
<dd>
<p><font o="2673">使用包含通用Kafka生产者属性的键/值对映射。</font></p>
<div class="paragraph">
<p><font o="2674">默认值：空地图。</font></p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2675">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2676">Kafka绑定器将使用生产者的<code i="1466">partitionCount</code>设置作为提示，以创建具有给定分区计数的主题（与<code i="1467">minPartitionCount</code>一起使用，最多两个为正在使用的值） 。</font><font o="2677">配置绑定器的<code i="1468">minPartitionCount</code>和应用程序的<code i="1469">partitionCount</code>时要小心，因为将使用较大的值。</font><font o="2678">如果一个主题已经存在较小的分区计数，并且<code i="1470">autoAddPartitions</code>被禁用（默认值），则绑定器将无法启动。</font><font o="2679">如果一个主题已经存在较小的分区计数，并且启用了<code i="1471">autoAddPartitions</code>，则会添加新的分区。</font><font o="2680">如果一个主题已经存在的分区数量大于（<code i="1472">minPartitionCount</code>和<code i="1473">partitionCount</code>）的最大值，则将使用现有的分区计数。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_usage_examples"><font o="2681">用法示例</font></h4>
<div class="paragraph">
<p><font o="2682">在本节中，我们举例说明了上述属性在具体情况下的使用。</font></p>
</div>
<div class="sect4">
<h5 id="_example_setting_code_autocommitoffset_code_false_and_relying_on_manual_acking"><font o="2683">示例：设置<code i="1474">autoCommitOffset</code> false并依赖手动确认。</font></h5>
<div class="paragraph">
<p><font o="2684">该示例说明了如何在消费者应用程序中手动确认偏移量。</font></p>
</div>
<div class="paragraph">
<p><font o="2685">此示例要求<code i="1475">spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</code>设置为false。</font><font o="2686">使用相应的输入通道名称作为示例。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>@SpringBootApplication
@EnableBinding(Sink.class)
public class ManuallyAcknowdledgingConsumer {

 public static void main(String[] args) {
     SpringApplication.run(ManuallyAcknowdledgingConsumer.class, args);
 }

 @StreamListener(Sink.INPUT)
 public void process(Message&lt;?&gt; message) {
     Acknowledgment acknowledgment = message.getHeaders().get(KafkaHeaders.ACKNOWLEDGMENT, Acknowledgment.class);
     if (acknowledgment != null) {
         System.out.println("Acknowledgment provided");
         acknowledgment.acknowledge();
     }
 }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_security_configuration"><font o="2687">示例：安全配置</font></h5>
<div class="paragraph">
<p><font o="2688">Apache Kafka 0.9支持客户端和代理商之间的安全连接。</font><font o="2689">要充分利用此功能，请遵循汇编文档中的</font><a href="https://kafka.apache.org/090/documentation.html#security_configclients"><font o="2689">Apache Kafka文档</font></a><font o="2689">以及Kafka 0.9 </font><a href="http://docs.confluent.io/2.0.0/kafka/security.html"><font o="2689">安全性指导原则</font></a><font o="2689">。</font><font o="2690">使用<code i="1476">spring.cloud.stream.kafka.binder.configuration</code>选项为绑定器创建的所有客户端设置安全属性。</font></p>
</div>
<div class="paragraph">
<p><font o="2691">例如，要将<code i="1477">security.protocol</code>设置为<code i="1478">SASL_SSL</code>，请设置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_SSL</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2692">所有其他安全属性可以以类似的方式设置。</font></p>
</div>
<div class="paragraph">
<p><font o="2693">使用Kerberos时，请按照参考文档中的</font><a href="https://kafka.apache.org/090/documentation.html#security_sasl_clientconfig"><font o="2693">说明</font></a><font o="2693">创建和引用JAAS配置。</font></p>
</div>
<div class="paragraph">
<p><font o="2694">Spring Cloud Stream支持使用JAAS配置文件并使用Spring Boot属性将JAAS配置信息传递到应用程序。</font></p>
</div>
<div class="sect5">
<h6 id="_using_jaas_configuration_files"><font o="2695">使用JAAS配置文件</font></h6>
<div class="paragraph">
<p><font o="2696">可以通过使用系统属性为Spring Cloud Stream应用程序设置JAAS和（可选）krb5文件位置。</font><font o="2697">以下是使用JAAS配置文件启动带有SASL和Kerberos的Spring Cloud Stream应用程序的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code> java -Djava.security.auth.login.config=/path.to/kafka_client_jaas.conf -jar log.jar \
   --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.kafka.binder.zkNodes=secure.zookeeper:2181 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_using_spring_boot_properties"><font o="2698">使用Spring Boot属性</font></h6>
<div class="paragraph">
<p><font o="2699">作为使用JAAS配置文件的替代方案，Spring Cloud Stream提供了一种使用Spring Boot属性为Spring Cloud Stream应用程序设置JAAS配置的机制。</font></p>
</div>
<div class="paragraph">
<p><font o="2700">以下属性可用于配置Kafka客户端的登录上下文。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2701">spring.cloud.stream.kafka.binder.jaas.loginModule</font></dt>
<dd>
<p><font o="2702">登录模块名称。</font><font o="2703">在正常情况下不需要设置。</font></p>
<div class="paragraph">
<p><font o="2704">默认值：<code i="1479">com.sun.security.auth.module.Krb5LoginModule</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2705">spring.cloud.stream.kafka.binder.jaas.controlFlag</font></dt>
<dd>
<p><font o="2706">登录模块的控制标志。</font></p>
<div class="paragraph">
<p><font o="2707">默认值：<code i="1480">required</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2708">spring.cloud.stream.kafka.binder.jaas.options</font></dt>
<dd>
<p><font o="2709">使用包含登录模块选项的键/值对映射。</font></p>
<div class="paragraph">
<p><font o="2710">默认值：空地图。</font></p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><font o="2711">以下是使用Spring Boot配置属性启动带有SASL和Kerberos的Spring Cloud Stream应用程序的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code> java --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.kafka.binder.zkNodes=secure.zookeeper:2181 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.autoCreateTopics=false \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT \
   --spring.cloud.stream.kafka.binder.jaas.options.useKeyTab=true \
   --spring.cloud.stream.kafka.binder.jaas.options.storeKey=true \
   --spring.cloud.stream.kafka.binder.jaas.options.keyTab=/etc/security/keytabs/kafka_client.keytab \
   --spring.cloud.stream.kafka.binder.jaas.options.principal=kafka-client-1@EXAMPLE.COM</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2712">这相当于以下JAAS文件：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>KafkaClient {
    com.sun.security.auth.module.Krb5LoginModule required
    useKeyTab=true
    storeKey=true
    keyTab="/etc/security/keytabs/kafka_client.keytab"
    principal="kafka-client-1@EXAMPLE.COM";
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2713">如果所需的主题已经存在于代理上，或将由管理员创建，则自动创建可以被关闭，并且仅需要发送客户端JAAS属性。</font><font o="2714">作为设置<code i="1481">spring.cloud.stream.kafka.binder.autoCreateTopics</code>的替代方法，您可以简单地从应用程序中删除代理依赖关系。</font><font o="2715">有关详细信息，请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#exclude-admin-utils"><font o="2715">基于绑定器的应用程序的类路径中排除Kafka代理jar</font></a><font o="2715">。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2716">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2717">不要在同一应用程序中混合JAAS配置文件和Spring Boot属性。</font><font o="2718">如果<code i="1482">-Djava.security.auth.login.config</code>系统属性已存在，则Spring Cloud Stream将忽略Spring Boot属性。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2719">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2720">使用<code i="1483">autoCreateTopics</code>和<code i="1484">autoAddPartitions</code>如果使用Kerberos，请务必小心。</font><font o="2721">通常应用程序可能使用Kafka和Zookeeper中没有管理权限的主体，并且依赖Spring Cloud Stream创建/修改主题可能会失败。</font><font o="2722">在安全环境中，我们强烈建议您使用Kafka工具管理性地创建主题并管理ACL。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_the_binder_with_apache_kafka_0_10"><font o="2723">使用绑定器与Apache Kafka 0.10</font></h5>
<div class="paragraph">
<p><font o="2724">Spring Cloud Stream Kafka binder中的默认Kafka支持是针对Kafka版本0.10.1.1的。</font><font o="2725">粘合剂还支持连接到其他0.10版本和0.9客户端。</font><font o="2726">为了做到这一点，当你创建包含你的应用程序的项目时，包括<code i="1485">spring-cloud-starter-stream-kafka</code>，你通常会对默认的绑定器做。</font><font o="2727">然后将这些依赖项添加到pom.xml文件中的<code i="1486">&lt;dependencies&gt;</code>部分的顶部以覆盖依赖关系。</font></p>
</div>
<div class="paragraph">
<p><font o="2728">以下是将应用程序降级到0.10.0.1的示例。</font><font o="2729">由于它仍在0.10行，因此可以保留默认的<code i="1487">spring-kafka</code>和<code i="1488">spring-integration-kafka</code>版本。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
  &lt;version&gt;0.10.0.1&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
  &lt;version&gt;0.10.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2730">这是使用0.9.0.1版本的另一个例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
  &lt;version&gt;1.0.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
  &lt;artifactId&gt;spring-integration-kafka&lt;/artifactId&gt;
  &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
  &lt;version&gt;0.9.0.1&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
  &lt;version&gt;0.9.0.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2731">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2732">以上版本仅为了举例而提供。</font><font o="2733">为获得最佳效果，我们建议您使用最新的0.10兼容版本的项目。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="exclude-admin-utils"><font o="2734">从基于绑定器的应用程序的类路径中排除Kafka代理jar</font></h5>
<div class="paragraph">
<p><font o="2735">Apache Kafka Binder使用作为Apache Kafka服务器库一部分的管理实用程序来创建和重新配置主题。</font><font o="2736">如果在运行时不需要包含Apache Kafka服务器库及其依赖关系，因为应用程序将依赖于管理中配置的主题，Kafka binder允许排除Apache Kafka服务器依赖关系从应用程序。</font></p>
</div>
<div class="paragraph">
<p><font o="2737">如果您使用上述建议的Kafka依赖关系的非默认版本，则只需要包含kafka代理依赖项。</font><font o="2738">如果您使用默认的Kafka版本，请确保从<code i="1489">spring-cloud-starter-stream-kafka</code>依赖关系中排除kafka broker jar，如下所示。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-kafka&lt;/artifactId&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
      &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2739">如果您排除Apache Kafka服务器依赖关系，并且该主题不在服务器上，那么如果在服务器上启用了自动主题创建，则Apache Kafka代理将创建该主题。</font><font o="2740">请注意，如果您依赖此，则Kafka服务器将使用默认数量的分区和复制因子。</font><font o="2741">另一方面，如果在服务器上禁用自动主题创建，则在运行应用程序之前必须注意创建具有所需数量分区的主题。</font></p>
</div>
<div class="paragraph">
<p><font o="2742">如果要完全控制分区的分配方式，请保留默认设置，即不要排除kafka代理程序jar，并确保将<code i="1490">spring.cloud.stream.kafka.binder.autoCreateTopics</code>设置为<code i="1491">true</code>，这是默认设置。</font></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kafka-dlq-processing"><font o="2743">Dead-Letter主题处理</font></h3>
<div class="paragraph">
<p><font o="2744">因为不可能预料到用户如何处理死信消息，所以框架不提供任何标准的机制来处理它们。</font><font o="2745">如果死刑的原因是短暂的，您可能希望将邮件路由到原始主题。</font><font o="2746">但是，如果问题是一个永久性的问题，那可能会导致无限循环。</font><font o="2747">以下<code i="1492">spring-boot</code>应用程序是如何将这些消息路由到原始主题的示例，但在三次尝试后将其移动到第三个“停车场”主题。</font><font o="2748">该应用程序只是从死信主题中读取的另一个spring-cloud-stream应用程序。</font><font o="2749">5秒内没有收到消息时终止。</font></p>
</div>
<div class="paragraph">
<p><font o="2750">这些示例假定原始目的地是<code i="1493">so8400out</code>，而消费者组是<code i="1494">so8400</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="2751">有几个注意事项</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="2752">当主应用程序未运行时，请考虑仅运行重新路由。</font><font o="2753">否则，瞬态错误的重试将很快用尽。</font></p>
</li>
<li>
<p><font o="2754">或者，使用两阶段方法 - 使用此应用程序路由到第三个主题，另一个则从那里路由到主题。</font></p>
</li>
<li>
<p><font o="2755">由于这种技术使用消息标头来跟踪重试，所以它不会与<code i="1495">headerMode=raw</code>一起使用。</font><font o="2756">在这种情况下，请考虑将一些数据添加到有效载荷（主应用程序可以忽略）。</font></p>
</li>
<li>
<p><font o="2757">必须将<code i="1496">x-retries</code>添加到<code i="1497">headers</code>属性<code i="1498">spring.cloud.stream.kafka.binder.headers=x-retries</code>和主应用程序，以便标头在应用程序之间传输。</font></p>
</li>
<li>
<p><font o="2758">由于kafka是发布/订阅，所以重播的消息将被发送给每个消费者组，即使是那些首次成功处理消息的消费者组。</font></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title"><font o="2759">application.properties</font></div>
<div class="content">
<pre class="highlight notranslate"><code>spring.cloud.stream.bindings.input.group=so8400replay
spring.cloud.stream.bindings.input.destination=error.so8400out.so8400

spring.cloud.stream.bindings.output.destination=so8400out
spring.cloud.stream.bindings.output.producer.partitioned=true

spring.cloud.stream.bindings.parkingLot.destination=so8400in.parkingLot
spring.cloud.stream.bindings.parkingLot.producer.partitioned=true

spring.cloud.stream.kafka.binder.configuration.auto.offset.reset=earliest

spring.cloud.stream.kafka.binder.headers=x-retries</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><font o="2760">应用</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(TwoOutputProcessor.class)
public class ReRouteDlqKApplication implements CommandLineRunner {

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) {
        SpringApplication.run(ReRouteDlqKApplication.class, args).close();
    }

    private final AtomicInteger processed = new AtomicInteger();

    @Autowired
    private MessageChannel parkingLot;

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public Message&lt;?&gt; reRoute(Message&lt;?&gt; failed) {
        processed.incrementAndGet();
        Integer retries = failed.getHeaders().get(X_RETRIES_HEADER, Integer.class);
        if (retries == null) {
            System.out.println("First retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else if (retries.intValue() &lt; 3) {
            System.out.println("Another retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(retries.intValue() + 1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else {
            System.out.println("Retries exhausted for " + failed);
            parkingLot.send(MessageBuilder.fromMessage(failed)
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build());
        }
        return null;
    }

    @Override
    public void run(String... args) throws Exception {
        while (true) {
            int count = this.processed.get();
            Thread.sleep(5000);
            if (count == this.processed.get()) {
                System.out.println("Idle, terminating");
                return;
            }
        }
    }

    public interface TwoOutputProcessor extends Processor {

        @Output("parkingLot")
        MessageChannel parkingLot();

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rabbitmq_binder">RabbitMQ Binder</h2>
<div class="sectionbody">

<div class="sect2">
<h3 id="_usage_2"><font o="2762">用法</font></h3>
<div class="paragraph">
<p><font o="2763">对于使用RabbitMQ绑定器，您只需要使用以下Maven坐标将其添加到您的Spring Cloud Stream应用程序：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="2764">或者，您也可以使用Spring Cloud Stream RabbitMQ入门。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rabbitmq_binder_overview"><font o="2765">RabbitMQ Binder概述</font></h3>
<div class="paragraph">
<p><font o="2766">以下可以看到RabbitMQ活页夹的操作简化图。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/rabbit-binder.png" alt="兔粘合剂" width="300">
</div>
<div class="title"><font o="2767">图14. RabbitMQ Binder</font></div>
</div>
<div class="paragraph">
<p><font o="2768">RabbitMQ Binder实现将每个目的地映射到<code i="1499">TopicExchange</code>。</font><font o="2769">对于每个消费者组，<code i="1500">Queue</code>将绑定到该<code i="1501">TopicExchange</code>。</font><font o="2770">每个消费者实例对其组的<code i="1503">Queue</code>具有相应的RabbitMQ <code i="1502">Consumer</code>实例。</font><font o="2771">对于分区生成器/消费者，队列后缀为分区索引，并使用分区索引作为路由密钥。</font></p>
</div>
<div class="paragraph">
<p><font o="2772">使用<code i="1504">autoBindDlq</code>选项，您可以选择配置绑定器来创建和配置死信队列（DLQ）（以及死信交换<code i="1505">DLX</code>）。</font><font o="2773">死信队列具有目标名称，附有<code i="1506">.dlq</code>。</font><font o="2774">如果重试启用（<code i="1507">maxAttempts &gt; 1</code>），则会将失败的消息传递到DLQ。</font><font o="2775">如果禁用重试（<code i="1508">maxAttempts = 1</code>），则应将<code i="1509">requeueRejected</code>设置为<code i="1510">false</code>（默认），以使失败的消息将路由到DLQ，而不是重新排队。</font><font o="2776">此外，<code i="1511">republishToDlq</code>导致绑定器向DLQ发布失败的消息（而不是拒绝它）; </font><font o="2777">这使得能够将标题中的附加信息添加到消息中，例如<code i="1512">x-exception-stacktrace</code>头中的堆栈跟踪。</font><font o="2778">此选项不需要重试启用; </font><font o="2779">一次尝试后，您可以重新发布失败的消息。</font><font o="2780">从</font><em><font o="2780">版本1.2</font></em><font o="2780">开始</font><font o="2780">，您可以配置重新发布的消息传递模式; </font><font o="2781">见财产<code i="1513">republishDeliveryMode</code>。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2782">重要</font></div>
</td>
<td class="content"><font o="2783">
将<code i="1514">requeueRejected</code>设置为<code i="1515">true</code>将导致消息被重新排序并重新发送，这可能不是您想要的，除非故障问题是短暂的。</font><font o="2784">一般来说，最好通过将<code i="1516">maxAttempts</code>设置为大于1，或将<code i="1517">republishToDlq</code>设置为<code i="1518">true</code>来启用binder内的重试。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="2785">有关这些属性的更多信息，</font><font o="2785">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#rabbit-binder-properties"><font o="2785">RabbitMQ Binder Properties</font></a><font o="2785">。</font></p>
</div>
<div class="paragraph">
<p><font o="2786">框架不提供消耗死信消息（或重新路由到主队列）的任何标准机制。</font><a href="https://springcloud.cc/spring-cloud-dalston.html#rabbit-dlq-processing"><font o="2787">Dead-Letter队列处理</font></a><font o="2787">中描述了一些选项</font><font o="2787">。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="2788">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="2789">在</font><font o="2789">Spring Cloud Stream应用程序中使用</font><strong><font o="2789">多个</font></strong><font o="2789"> RabbitMQ绑定器时，禁用“RabbitAutoConfiguration”以避免将RabbitAutoConfiguration应用于两个绑定器的相同配置很重要。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_options_3"><font o="2790">配置选项</font></h3>
<div class="paragraph">
<p><font o="2791">本节包含特定于RabbitMQ Binder和绑定频道的设置。</font></p>
</div>
<div class="paragraph">
<p><font o="2792">有关通用绑定配置选项和属性，请参阅</font><a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-docs/src/main/asciidoc/spring-cloud-stream-overview.adoc#configuration-options"><font o="2792">Spring Cloud Stream核心文档</font></a><font o="2792">。</font></p>
</div>
<div class="sect3">
<h4 id="rabbit-binder-properties">RabbitMQ Binder Properties</h4>
<div class="paragraph">
<p><font o="2794">默认情况下，RabbitMQ binder使用Spring Boot的<code i="1519">ConnectionFactory</code>，因此它支持RabbitMQ的所有Spring Boot配置选项。</font><font o="2795">（有关参考，请参阅</font><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties"><font o="2795">Spring Boot文档</font></a><font o="2795">。）RabbitMQ配置选项使用<code i="1520">spring.rabbitmq</code>前缀。</font></p>
</div>
<div class="paragraph">
<p><font o="2796">除Spring Boot选项之外，RabbitMQ binder还支持以下属性：</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2797">spring.cloud.stream.rabbit.binder.adminAddresses</font></dt>
<dd>
<p><font o="2798">  RabbitMQ管理插件网址的逗号分隔列表。</font><font o="2799">仅在<code i="1521">nodes</code>包含多个条目时使用。</font><font o="2800">此列表中的每个条目必须在<code i="1522">spring.rabbitmq.addresses</code>中具有相应的条目。</font></p>
<div class="paragraph">
<p><font o="2801">默认值：空。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2802">spring.cloud.stream.rabbit.binder.nodes</font></dt>
<dd>
<p><font o="2803">  RabbitMQ节点名称的逗号分隔列表。</font><font o="2804">当多个条目用于查找队列所在的服务器地址时。</font><font o="2805">此列表中的每个条目必须在<code i="1523">spring.rabbitmq.addresses</code>中具有相应的条目。</font></p>
<div class="paragraph">
<p><font o="2806">默认值：空。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2807">spring.cloud.stream.rabbit.binder.compressionLevel</font></dt>
<dd>
<p><font o="2808">  压缩绑定的压缩级别。</font><font o="2809">见<code i="1524">java.util.zip.Deflater</code>。</font></p>
<div class="paragraph">
<p><font o="2810">默认值：<code i="1525">1</code>（BEST_LEVEL）。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_rabbitmq_consumer_properties"><font o="2811">RabbitMQ消费者Properties</font></h4>
<div class="paragraph">
<p><font o="2812">以下属性仅适用于Rabbit消费者，并且必须以<code i="1526">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.</code>为前缀。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2813">acknowledgeMode</font></dt>
<dd>
<p><font o="2814">确认模式。</font></p>
<div class="paragraph">
<p><font o="2815">默认值：<code i="1527">AUTO</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2816">autoBindDlq</font></dt>
<dd>
<p><font o="2817">是否自动声明DLQ并将其绑定到绑定器DLX。</font></p>
<div class="paragraph">
<p><font o="2818">默认值：<code i="1528">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2819">bindingRoutingKey</font></dt>
<dd>
<p><font o="2820">将队列绑定到交换机的路由密钥（如果<code i="1529">bindQueue</code>为<code i="1530">true</code>）。</font><font o="2821">将附加分区目的地<code i="1531">-&lt;instanceIndex&gt;</code>。</font></p>
<div class="paragraph">
<p><font o="2822">默认值：<code i="1532">#</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2823">bindQueue</font></dt>
<dd>
<p><font o="2824">是否将队列绑定到目的地交换机？</font><font o="2825">如果您已经设置了自己的基础设施并且先前已经创建/绑定了队列，请设置为<code i="1533">false</code>。</font></p>
<div class="paragraph">
<p><font o="2826">默认值：<code i="1534">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2827">deadLetterQueueName</font></dt>
<dd>
<p><font o="2828">DLQ的名称</font></p>
<div class="paragraph">
<p><font o="2829">默认值：<code i="1535">prefix+destination.dlq</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2830">deadLetterExchange</font></dt>
<dd>
<p><font o="2831">分配给队列的DLX; </font><font o="2832">如果autoBindDlq为true</font></p>
<div class="paragraph">
<p><font o="2833">默认值：'prefix + DLX'</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2834">deadLetterRoutingKey</font></dt>
<dd>
<p><font o="2835">一个死信路由密钥分配给队列; </font><font o="2836">如果autoBindDlq为true</font></p>
<div class="paragraph">
<p><font o="2837">默认值：<code i="1536">destination</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2838">declareExchange</font></dt>
<dd>
<p><font o="2839">是否为目的地申报交换。</font></p>
<div class="paragraph">
<p><font o="2840">默认值：<code i="1537">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2841">delayedExchange</font></dt>
<dd>
<p><font o="2842">是否将交换声明为<code i="1538">Delayed Message Exchange</code>  - 需要在代理上延迟的消息交换插件。</font><font o="2843"><code i="1539">x-delayed-type</code>参数设置为<code i="1540">exchangeType</code>。</font></p>
<div class="paragraph">
<p><font o="2844">默认值：<code i="1541">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2845">dlqDeadLetterExchange</font></dt>
<dd>
<p><font o="2846">如果DLQ被声明，则将DLX分配给该队列</font></p>
<div class="paragraph">
<p><font o="2847">默认值：<code i="1542">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2848">dlqDeadLetterRoutingKey</font></dt>
<dd>
<p><font o="2849">如果DLQ被声明，则会将一个死信路由密钥分配给该队列; </font><font o="2850">默认无</font></p>
<div class="paragraph">
<p><font o="2851">默认值：<code i="1543">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2852">dlqExpires</font></dt>
<dd>
<p><font o="2853">未使用的死信队列被删除多久（ms）</font></p>
<div class="paragraph">
<p><font o="2854">默认值：<code i="1544">no expiration</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2855">dlqMaxLength</font></dt>
<dd>
<p><font o="2856">死信队列中的最大消息数</font></p>
<div class="paragraph">
<p><font o="2857">默认值：<code i="1545">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2858">dlqMaxLengthBytes</font></dt>
<dd>
<p><font o="2859">来自所有消息的死信队列中的最大字节数</font></p>
<div class="paragraph">
<p><font o="2860">默认值：<code i="1546">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2861">dlqMaxPriority</font></dt>
<dd>
<p><font o="2862">死信队列中消息的最大优先级（0-255）</font></p>
<div class="paragraph">
<p><font o="2863">默认值：<code i="1547">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2864">dlqTtl</font></dt>
<dd>
<p><font o="2865">声明（ms）时默认适用于死信队列的时间</font></p>
<div class="paragraph">
<p><font o="2866">默认值：<code i="1548">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2867">durableSubscription</font></dt>
<dd>
<p><font o="2868">  订阅是否应该耐用。</font><font o="2869">仅当<code i="1549">group</code>也被设置时才有效。</font></p>
<div class="paragraph">
<p><font o="2870">默认值：<code i="1550">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2871">exchangeAutoDelete</font></dt>
<dd>
<p><font o="2872">如果<code i="1551">declareExchange</code>为真，则交换机是否应该自动删除（删除最后一个队列后删除）。</font></p>
<div class="paragraph">
<p><font o="2873">默认值：<code i="1552">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2874">exchangeDurable</font></dt>
<dd>
<p><font o="2875">如果<code i="1553">declareExchange</code>为真，则交换应该是否持久（经纪人重新启动）。</font></p>
<div class="paragraph">
<p><font o="2876">默认值：<code i="1554">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2877">exchangeType</font></dt>
<dd>
<p><font o="2878">交换类型; </font><font o="2879">非分区目的地的<code i="1555">direct</code>，<code i="1556">fanout</code>或<code i="1557">topic</code> </font><font o="2880"><code i="1558">direct</code>或<code i="1559">topic</code>分区目的地。</font></p>
<div class="paragraph">
<p><font o="2881">默认值：<code i="1560">topic</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2882">到期</font></dt>
<dd>
<p><font o="2883">未使用的队列被删除多久（ms）</font></p>
<div class="paragraph">
<p><font o="2884">默认值：<code i="1561">no expiration</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2885">headerPatterns</font></dt>
<dd>
<p><font o="2886">要从入站邮件映射的头文件。</font></p>
<div class="paragraph">
<p><font o="2887">默认值：<code i="1562">['*']</code>（所有标题）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2888">maxConcurrency</font></dt>
<dd>
<p><font o="2889">最大消费者人数</font></p>
<div class="paragraph">
<p><font o="2890">默认值：<code i="1563">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2891">最长长度</font></dt>
<dd>
<p><font o="2892">队列中最大消息数</font></p>
<div class="paragraph">
<p><font o="2893">默认值：<code i="1564">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2894">maxLengthBytes</font></dt>
<dd>
<p><font o="2895">来自所有消息的队列中最大字节数</font></p>
<div class="paragraph">
<p><font o="2896">默认：<code i="1565">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2897">maxPriority</font></dt>
<dd>
<p><font o="2898">队列中消息的最大优先级（0-255）</font></p>
</dd>
<dt class="hdlist1"><font o="2899">默认</font></dt>
<dd>
<p><code>none</code></p>
</dd>
<dt class="hdlist1"><font o="2900">预取</font></dt>
<dd>
<p><font o="2901">预取计数。</font></p>
<div class="paragraph">
<p><font o="2902">默认值：<code i="1566">1</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2903">字首</font></dt>
<dd>
<p><font o="2904">要添加到<code i="1567">destination</code>和队列名称的前缀。</font></p>
<div class="paragraph">
<p><font o="2905">默认值：“”。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2906">recoveryInterval</font></dt>
<dd>
<p><font o="2907">连接恢复尝试之间的间隔，以毫秒为单位。</font></p>
<div class="paragraph">
<p><font o="2908">默认值：<code i="1568">5000</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2909">requeueRejected</font></dt>
<dd>
<p><font o="2910">在重试禁用或重新发布ToDlq是否为false时，是否应重新发送传递失败。</font></p>
<div class="paragraph">
<p><font o="2911">默认值：<code i="1569">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2912">republishDeliveryMode</font></dt>
<dd>
<p><font o="2913">当<code i="1570">republishToDlq</code>为<code i="1571">true</code>时，指定重新发布的邮件的传递模式。</font></p>
<div class="paragraph">
<p><font o="2914">默认值：<code i="1572">DeliveryMode.PERSISTENT</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2915">republishToDlq</font></dt>
<dd>
<p><font o="2916">  默认情况下，尝试重试后失败的消息将被拒绝。</font><font o="2917">如果配置了死信队列（DLQ），则RabbitMQ将将失败的消息（未更改）路由到DLQ。</font><font o="2918">如果设置为<code i="1573">true</code>，则绑定器将重新发布具有附加头的DLQ的失败消息，包括最终失败的原因的异常消息和堆栈跟踪。</font></p>
<div class="paragraph">
<p><font o="2919">默认值：false</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2920">交易</font></dt>
<dd>
<p><font o="2921">是否使用交易渠道。</font></p>
<div class="paragraph">
<p><font o="2922">默认值：<code i="1574">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2923">TTL</font></dt>
<dd>
<p><font o="2924">声明（ms）时默认适用于队列的时间</font></p>
<div class="paragraph">
<p><font o="2925">默认值：<code i="1575">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2926">txSize</font></dt>
<dd>
<p><font o="2927">阿克斯之间的交付次数。</font></p>
<div class="paragraph">
<p><font o="2928">默认值：<code i="1576">1</code>。</font></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_rabbit_producer_properties"><font o="2929">兔子生产者Properties</font></h4>
<div class="paragraph">
<p><font o="2930">以下属性仅适用于Rabbit生产者，必须以<code i="1577">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.producer.</code>为前缀。</font></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><font o="2931">autoBindDlq</font></dt>
<dd>
<p><font o="2932">是否自动声明DLQ并将其绑定到绑定器DLX。</font></p>
<div class="paragraph">
<p><font o="2933">默认值：<code i="1578">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2934">batchingEnabled</font></dt>
<dd>
<p><font o="2935">是否启用生产者的消息批处理。</font></p>
<div class="paragraph">
<p><font o="2936">默认值：<code i="1579">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2937">BATCHSIZE</font></dt>
<dd>
<p><font o="2938">批量启动时要缓冲的消息数。</font></p>
<div class="paragraph">
<p><font o="2939">默认值：<code i="1580">100</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2940">batchBufferLimit</font></dt>
<dd>
<p><font o="2941">默认值：<code i="1581">10000</code>。</font></p>
</dd>
<dt class="hdlist1"><font o="2942">batchTimeout</font></dt>
<dd>
<p><font o="2943">默认值：<code i="1582">5000</code>。</font></p>
</dd>
<dt class="hdlist1"><font o="2944">bindingRoutingKey</font></dt>
<dd>
<p><font o="2945">将队列绑定到交换机的路由密钥（如果<code i="1583">bindQueue</code>为<code i="1584">true</code>）。</font><font o="2946">仅适用于非分区目的地。</font><font o="2947">仅适用于<code i="1585">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2948">默认值：<code i="1586">#</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2949">bindQueue</font></dt>
<dd>
<p><font o="2950">是否将队列绑定到目的地交换机？</font><font o="2951">如果您已经设置了自己的基础架构并且先前已经创建/绑定了队列，请设置为<code i="1587">false</code>。</font><font o="2952">仅适用于<code i="1588">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2953">默认值：<code i="1589">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2954">压缩</font></dt>
<dd>
<p><font o="2955">发送时是否应压缩数据。</font></p>
<div class="paragraph">
<p><font o="2956">默认值：<code i="1590">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2957">deadLetterQueueName</font></dt>
<dd>
<p><font o="2958">DLQ的名称仅适用于<code i="1591">requiredGroups</code>，仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="2959">默认值：<code i="1592">prefix+destination.dlq</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2960">deadLetterExchange</font></dt>
<dd>
<p><font o="2961">分配给队列的DLX; </font><font o="2962">如果autoBindDlq为true只适用于<code i="1593">requiredGroups</code>，然后只提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2963">默认值：'prefix + DLX'</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2964">deadLetterRoutingKey</font></dt>
<dd>
<p><font o="2965">一个死信路由密钥分配给队列; </font><font o="2966">如果autoBindDlq为true只适用于<code i="1594">requiredGroups</code>，然后只提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2967">默认值：<code i="1595">destination</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2968">declareExchange</font></dt>
<dd>
<p><font o="2969">是否为目的地申报交换。</font></p>
<div class="paragraph">
<p><font o="2970">默认值：<code i="1596">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2971">延迟</font></dt>
<dd>
<p><font o="2972">评估应用于消息（<code i="1597">x-delay</code>头）的延迟的Spel表达式 - 如果交换不是延迟的消息交换，则不起作用。</font></p>
<div class="paragraph">
<p><font o="2973">默认值：No <code i="1598">x-delay</code>头设置。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2974">delayedExchange</font></dt>
<dd>
<p><font o="2975">是否将交换声明为<code i="1599">Delayed Message Exchange</code>  - 需要经纪人上的延迟消息交换插件。</font><font o="2976"><code i="1600">x-delayed-type</code>参数设置为<code i="1601">exchangeType</code>。</font></p>
<div class="paragraph">
<p><font o="2977">默认值：<code i="1602">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2978">deliveryMode</font></dt>
<dd>
<p><font o="2979">交货方式。</font></p>
<div class="paragraph">
<p><font o="2980">默认值：<code i="1603">PERSISTENT</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2981">dlqDeadLetterExchange</font></dt>
<dd>
<p><font o="2982">如果DLQ被声明，则分配给该队列的DLX只适用于<code i="1604">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2983">默认值：<code i="1605">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2984">dlqDeadLetterRoutingKey</font></dt>
<dd>
<p><font o="2985">如果DLQ被声明，则会将一个死信路由密钥分配给该队列; </font><font o="2986">默认值none仅在提供<code i="1606">requiredGroups</code>时才适用，然后仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="2987">默认值：<code i="1607">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2988">dlqExpires</font></dt>
<dd>
<p><font o="2989">未使用的死信队列被删除之前多久（ms）仅适用于<code i="1608">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2990">默认值：<code i="1609">no expiration</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2991">dlqMaxLength</font></dt>
<dd>
<p><font o="2992">死信队列中的最大消息数仅适用于<code i="1610">requiredGroups</code>，仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="2993">默认值：<code i="1611">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2994">dlqMaxLengthBytes</font></dt>
<dd>
<p><font o="2995">来自所有消息的死信队列中的最大字节数仅适用于<code i="1612">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2996">默认值：<code i="1613">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="2997">dlqMaxPriority</font></dt>
<dd>
<p><font o="2998">死信队列中消息的最大优先级（0-255）仅适用于<code i="1614">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="2999">默认值：<code i="1615">none</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3000">dlqTtl</font></dt>
<dd>
<p><font o="3001">声明（ms）的默认时间适用于死信队列仅适用于<code i="1616">requiredGroups</code>，然后仅提供给这些组。</font></p>
<div class="paragraph">
<p><font o="3002">默认值：<code i="1617">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3003">exchangeAutoDelete</font></dt>
<dd>
<p><font o="3004">如果<code i="1618">declareExchange</code>为真，则交换机是否应该自动删除（删除最后一个队列后删除）。</font></p>
<div class="paragraph">
<p><font o="3005">默认值：<code i="1619">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3006">exchangeDurable</font></dt>
<dd>
<p><font o="3007">如果<code i="1620">declareExchange</code>为真，则交换应该是持久的（经纪人重新启动）。</font></p>
<div class="paragraph">
<p><font o="3008">默认值：<code i="1621">true</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3009">exchangeType</font></dt>
<dd>
<p><font o="3010">交换类型; </font><font o="3011"><code i="1622">direct</code>，<code i="1623">fanout</code>或<code i="1624">topic</code>; </font><font o="3012"><code i="1625">direct</code>或<code i="1626">topic</code>。</font></p>
<div class="paragraph">
<p><font o="3013">默认值：<code i="1627">topic</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3014">到期</font></dt>
<dd>
<p><font o="3015">在未使用的队列被删除之前多久（ms）仅适用于<code i="1628">requiredGroups</code>，然后只提供给这些组。</font></p>
<div class="paragraph">
<p><font o="3016">默认值：<code i="1629">no expiration</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3017">headerPatterns</font></dt>
<dd>
<p><font o="3018">要将标头映射到出站邮件的模式。</font></p>
<div class="paragraph">
<p><font o="3019">默认值：<code i="1630">['*']</code>（所有标题）。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3020">最长长度</font></dt>
<dd>
<p><font o="3021">队列中最大消息数仅适用于<code i="1631">requiredGroups</code>，仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="3022">默认值：<code i="1632">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3023">maxLengthBytes</font></dt>
<dd>
<p><font o="3024">来自所有消息的队列中最大字节数仅适用于<code i="1633">requiredGroups</code>，仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="3025">默认值：<code i="1634">no limit</code></font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3026">maxPriority</font></dt>
<dd>
<p><font o="3027">队列中消息的最大优先级（0-255）仅适用于<code i="1635">requiredGroups</code>，仅适用于这些组。</font></p>
</dd>
<dt class="hdlist1"><font o="3028">默认</font></dt>
<dd>
<p><code>none</code></p>
</dd>
<dt class="hdlist1"><font o="3029">字首</font></dt>
<dd>
<p><font o="3030">要添加到<code i="1636">destination</code>交换机名称的前缀。</font></p>
<div class="paragraph">
<p><font o="3031">默认值：“”。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3032">routingKeyExpression</font></dt>
<dd>
<p><font o="3033">一个SpEL表达式来确定在发布消息时使用的路由密钥。</font></p>
<div class="paragraph">
<p><font o="3034">默认值：<code i="1637">destination</code>或<code i="1638">destination-&lt;partition&gt;</code>分区目的地。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3035">交易</font></dt>
<dd>
<p><font o="3036">是否使用交易渠道。</font></p>
<div class="paragraph">
<p><font o="3037">默认值：<code i="1639">false</code>。</font></p>
</div>
</dd>
<dt class="hdlist1"><font o="3038">TTL</font></dt>
<dd>
<p><font o="3039">声明时默认适用于队列的时间（ms）仅适用于<code i="1640">requiredGroups</code>，然后仅适用于这些组。</font></p>
<div class="paragraph">
<p><font o="3040">默认值：<code i="1641">no limit</code></font></p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3041">注意</font></div>
</td>
<td class="content">
<div class="paragraph">
<p><font o="3042">在RabbitMQ的情况下，内容类型头可以由外部应用程序设置。</font><font o="3043">Spring Cloud Stream支持它们作为用于任何类型传输（包括通常不支持头文件的Kafka）的传输的扩展内部协议的一部分）。</font></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retry_with_the_rabbitmq_binder"><font o="3044">重试RabbitMQ Binder</font></h3>
<div class="sect3">
<h4 id="_overview"><font o="3045">概观</font></h4>
<div class="paragraph">
<p><font o="3046">在绑定器中启用重试时，侦听器容器线程将被挂起，以配置任何后退时段。</font><font o="3047">在单个消费者需要严格排序时，这可能很重要，但是对于其他用例，它可以防止在该线程上处理其他消息。</font><font o="3048">使用绑定器重试的另一种方法是设置死机字符随着时间生活在死信队列（DLQ）上，以及DLQ本身的死信配置。</font><font o="3049">有关</font><font o="3049">这里讨论的属性的更多信息，</font><font o="3049">请参阅</font><a href="https://springcloud.cc/spring-cloud-dalston.html#rabbit-binder-properties"><font o="3049">RabbitMQ Binder Properties</font></a><font o="3049">。</font><font o="3050">启用此功能的示例配置：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3051">将<code i="1642">autoBindDlq</code>设置为<code i="1643">true</code>  - 绑定器将创建一个DLQ; </font><font o="3052">您可以选择在<code i="1644">deadLetterQueueName</code>中指定一个名称</font></p>
</li>
<li>
<p><font o="3053">将<code i="1645">dlqTtl</code>设置为您要在重新投递之间等待的退出时间</font></p>
</li>
<li>
<p><font o="3054">将<code i="1646">dlqDeadLetterExchange</code>设置为默认交换 -  DLQ的过期消息将被路由到原始队列，因为默认<code i="1647">deadLetterRoutingKey</code>是队列名称（<code i="1648">destination.group</code>）</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3055">要强制一个消息被填字，抛出一个<code i="1649">AmqpRejectAndDontRequeueException</code>，或设置<code i="1650">requeueRejected</code>到<code i="1651">true</code>并抛出任何异常。</font></p>
</div>
<div class="paragraph">
<p><font o="3056">循环将继续没有结束，这对于短暂的问题是很好的，但是您可能想在一些尝试后放弃。</font><font o="3057">幸运的是，RabbitMQ提供了<code i="1652">x-death</code>标题，允许您确定发生了多少个周期。</font></p>
</div>
<div class="paragraph">
<p><font o="3058">在放弃之后确认一则消息，抛出一个<code i="1653">ImmediateAcknowledgeAmqpException</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_putting_it_all_together"><font o="3059">把它放在一起</font></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>---
spring.cloud.stream.bindings.input.destination=myDestination
spring.cloud.stream.bindings.input.group=consumerGroup
#disable binder retries
spring.cloud.stream.bindings.input.consumer.max-attempts=1
#dlx/dlq setup
spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-ttl=5000
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-dead-letter-exchange=
---</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3060">此配置创建一个与通配符路由密钥<code i="1656">#</code>交换主题的队列<code i="1655">myDestination.consumerGroup</code>的交换<code i="1654">myDestination</code>。</font><font o="3061">它创建一个绑定到具有路由密钥<code i="1658">myDestination.consumerGroup</code>的直接交换<code i="1657">DLX</code>的DLQ。</font><font o="3062">当消息被拒绝时，它们被路由到DLQ。</font><font o="3063">5秒钟后，消息过期，并使用队列名称作为路由密钥路由到原始队列。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3064">Spring Boot申请</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class XDeathApplication {

    public static void main(String[] args) {
        SpringApplication.run(XDeathApplication.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(String in, @Header(name = "x-death", required = false) Map&lt;?,?&gt; death) {
        if (death != null &amp;&amp; death.get("count").equals(3L)) {
            // giving up - don't send to DLX
            throw new ImmediateAcknowledgeAmqpException("Failed after 4 attempts");
        }
        throw new AmqpRejectAndDontRequeueException("failed");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3065">请注意，<code i="1659">x-death</code>标题中的count属性是<code i="1660">Long</code>。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rabbit-dlq-processing"><font o="3066">Dead-Letter队列处理</font></h3>
<div class="paragraph">
<p><font o="3067">因为不可能预料到用户如何处理死信消息，所以框架不提供任何标准的机制来处理它们。</font><font o="3068">如果死刑的原因是暂时的，您可能希望将邮件路由到原始队列。</font><font o="3069">但是，如果问题是一个永久性的问题，那可能会导致无限循环。</font><font o="3070">以下<code i="1661">spring-boot</code>应用程序是如何将这些消息路由到原始队列的示例，但是在三次尝试之后将其移动到第三个“停车场”队列。</font><font o="3071">第二个例子使用</font><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/"><font o="3071">RabbitMQ延迟消息交换</font></a><font o="3071">来向被重新排序的</font><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/"><font o="3071">消息</font></a><font o="3071">引入延迟。</font><font o="3072">在这个例子中，每次尝试的延迟都会增加。</font><font o="3073">这些示例使用<code i="1662">@RabbitListener</code>从DLQ接收消息，您也可以在批处理过程中使用<code i="1663">RabbitTemplate.receive()</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="3074">这些示例假定原始目的地是<code i="1664">so8400in</code>，消费者组是<code i="1665">so8400</code>。</font></p>
</div>
<div class="sect3">
<h4 id="_non_partitioned_destinations"><font o="3075">非分区目的地</font></h4>
<div class="paragraph">
<p><font o="3076">前两个示例是目的地</font><strong><font o="3076">未</font></strong><font o="3076">分区。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Integer retriesHeader = (Integer) failedMessage.getMessageProperties().getHeaders().get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            failedMessage.getMessageProperties().getHeaders().put(X_RETRIES_HEADER, retriesHeader + 1);
            this.rabbitTemplate.send(ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    private static final String DELAY_EXCHANGE = "dlqReRouter";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader &lt; 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            headers.put("x-delay", 5000 * retriesHeader);
            this.rabbitTemplate.send(DELAY_EXCHANGE, ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public DirectExchange delayExchange() {
        DirectExchange exchange = new DirectExchange(DELAY_EXCHANGE);
        exchange.setDelayed(true);
        return exchange;
    }

    @Bean
    public Binding bindOriginalToDelay() {
        return BindingBuilder.bind(new Queue(ORIGINAL_QUEUE)).to(delayExchange()).with(ORIGINAL_QUEUE);
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_partitioned_destinations"><font o="3077">分区目的地</font></h4>
<div class="paragraph">
<p><font o="3078">对于分区目的地，所有分区都有一个DLQ，我们从头部确定原始队列。</font></p>
</div>
<div class="sect4">
<h5 id="_republishtodlq_false"><font o="3079">republishToDlq = FALSE</font></h5>
<div class="paragraph">
<p><font o="3080">当<code i="1666">republishToDlq</code>为<code i="1667">false</code>时，RabbitMQ将消息发布到DLX / DLQ，其中包含有关原始目的地信息的<code i="1668">x-death</code>标题。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_DEATH_HEADER = "x-death";

	private static final String X_RETRIES_HEADER = "x-retries";

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@SuppressWarnings("unchecked")
	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			List&lt;Map&lt;String, ?&gt;&gt; xDeath = (List&lt;Map&lt;String, ?&gt;&gt;) headers.get(X_DEATH_HEADER);
			String exchange = (String) xDeath.get(0).get("exchange");
			List&lt;String&gt; routingKeys = (List&lt;String&gt;) xDeath.get(0).get("routing-keys");
			this.rabbitTemplate.send(exchange, routingKeys.get(0), failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_republishtodlq_true"><font o="3081">republishToDlq =真</font></h5>
<div class="paragraph">
<p><font o="3082">当<code i="1669">republishToDlq</code>为<code i="1670">true</code>时，重新发布恢复器将原始交换和路由密钥添加到标题。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

	private static final String ORIGINAL_QUEUE = "so8400in.so8400";

	private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

	private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

	private static final String X_RETRIES_HEADER = "x-retries";

	private static final String X_ORIGINAL_EXCHANGE_HEADER = RepublishMessageRecoverer.X_ORIGINAL_EXCHANGE;

	private static final String X_ORIGINAL_ROUTING_KEY_HEADER = RepublishMessageRecoverer.X_ORIGINAL_ROUTING_KEY;

	public static void main(String[] args) throws Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
		System.out.println("Hit enter to terminate");
		System.in.read();
		context.close();
	}

	@Autowired
	private RabbitTemplate rabbitTemplate;

	@RabbitListener(queues = DLQ)
	public void rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		if (retriesHeader == null) {
			retriesHeader = Integer.valueOf(0);
		}
		if (retriesHeader &lt; 3) {
			headers.put(X_RETRIES_HEADER, retriesHeader + 1);
			String exchange = (String) headers.get(X_ORIGINAL_EXCHANGE_HEADER);
			String originalRoutingKey = (String) headers.get(X_ORIGINAL_ROUTING_KEY_HEADER);
			this.rabbitTemplate.send(exchange, originalRoutingKey, failedMessage);
		}
		else {
			this.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	@Bean
	public Queue parkingLot() {
		return new Queue(PARKING_LOT);
	}

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_bus" class="sect0">Spring Cloud Bus</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><font o="3084">Spring Cloud Bus将分布式系统的节点与轻量级消息代理链接。</font><font o="3085">这可以用于广播状态更改（例如配置更改）或其他管理指令。</font><font o="3086">一个关键的想法是，总线就像一个分布式执行器，用于扩展的Spring Boot应用程序，但也可以用作应用程序之间的通信通道。</font><font o="3087">目前唯一的实现是使用AMQP代理作为传输，但是相同的基本功能集（还有一些取决于传输）在其他传输的路线图上。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3088">注意</font></div>
</td>
<td class="content"><font o="3089">
Spring Cloud根据非限制性Apache 2.0许可证发布。</font><font o="3090">如果您想为文档的这一部分做出贡献，或者发现错误，请在</font><a href="https://github.com/spring-cloud/spring-cloud-config/tree/master/docs/src/main/asciidoc"><font o="3090">github</font></a><font o="3090">中找到项目中的源代码和问题跟踪器</font><font o="3090">。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_quick_start_2"><font o="3091">快速开始</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3092">Spring Cloud Bus的工作原理是添加Spring Boot自动配置，如果它在类路径中检测到自身。</font><font o="3093">所有您需要做的是启用总线是将<code i="1671">spring-cloud-starter-bus-amqp</code>或<code i="1672">spring-cloud-starter-bus-kafka</code>添加到您的依赖关系管理中，并且Spring Cloud负责其余部分。</font><font o="3094">确保代理（RabbitMQ或Kafka）可用和配置：在本地主机上运行，​​您不应该做任何事情，但如果您远程运行使用Spring Cloud连接器或Spring Boot定义经纪人凭据的约定，例如Rabbit</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3095">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  rabbitmq:
    host: mybroker.com
    port: 5672
    username: user
    password: secret</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3096">总线当前支持向所有节点发送消息，用于特定服务的所有节点（由Eureka定义）。</font><font o="3097">未来可能会添加更多的选择器标准（即，仅数据中心Y中的服务X节点等）。</font><font o="3098"><code i="1673">/bus/*</code>执行器命名空间下还有一些http端点。</font><font o="3099">目前有两个实施。</font><font o="3100">第一个<code i="1674">/bus/env</code>发送密钥/值对来更新每个节点的Spring环境。</font><font o="3101">第二个，<code i="1675">/bus/refresh</code>，将重新加载每个应用程序的配置，就好像他们在他们的<code i="1676">/refresh</code>端点上都被ping过。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3102">注意</font></div>
</td>
<td class="content"><font o="3103">
总线起动器覆盖了Rabbit和Kafka，因为这是两种最常用的实现方式，但是Spring Cloud Stream非常灵活，绑定器将与<code i="1677">spring-cloud-bus</code>结合使用。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_addressing_an_instance"><font o="3104">处理实例</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3105">HTTP端点接受“目的地”参数，例如“/ bus / refresh？destination = customers：9000”，其中目的地是<code i="1678">ApplicationContext</code> ID。</font><font o="3106">如果ID由总线上的一个实例拥有，那么它将处理消息，所有其他实例将忽略它。</font><font o="3107">Spring Boot将<code i="1679">ContextIdApplicationContextInitializer</code>中的ID设置为<code i="1680">spring.application.name</code>，活动配置文件和<code i="1681">server.port</code>的组合。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_addressing_all_instances_of_a_service"><font o="3108">寻址服务的所有实例</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3109">“destination”参数用于Spring <code i="1682">PathMatcher</code>（路径分隔符为冒号<code i="1683">:</code>）以确定实例是否处理该消息。</font><font o="3110">使用上述示例，“/ bus / refresh？destination = customers：**”将针对“客户”服务的所有实例，而不管配置文件和端口设置为<code i="1684">ApplicationContext</code> ID。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_context_id_must_be_unique"><font o="3111">应用程序上下文ID必须是唯一的</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3112">总线尝试从原始<code i="1685">ApplicationEvent</code>一次消除处理事件两次，一次从队列中消除。</font><font o="3113">为此，它会检查发送应用程序上下文id，以重新显示当前的应用程序上下文ID。</font><font o="3114">如果服务的多个实例具有相同的应用程序上下文id，则不会处理事件。</font><font o="3115">在本地机器上运行，每个服务将在不同的端口上，这将是应用程序上下文ID的一部分。</font><font o="3116">Cloud Foundry提供了区分的索引。</font><font o="3117">要确保应用程序上下文ID是唯一的，请将<code i="1686">spring.application.index</code>设置为服务的每个实例唯一的值。</font><font o="3118">例如，在lattice中，在application.properties中设置<code i="1687">spring.application.index=${INSTANCE_INDEX}</code>（如果使用configserver，请设置bootstrap.properties）。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_customizing_the_message_broker"><font o="3119">自定义Message Broker</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3120">Spring Cloud Bus使用
 </font><a href="https://cloud.spring.io/spring-cloud-stream"><font o="3120">Spring Cloud Stream</font></a><font o="3120">广播消息，以便获取消息流，只需要在类路径中包含您选择的binder实现。</font><font o="3121">有AMQP（RabbitMQ）和Kafka（<code i="1688">spring-cloud-starter-bus-[amqp,kafka]</code>）的公共汽车专用起动方便。</font><font o="3122">一般来说，Spring Cloud Stream依赖于用于配置中间件的Spring Boot自动配置约定，因此例如AMQP代理地址可以使用<code i="1689">spring.rabbitmq.*</code>配置属性更改。</font><font o="3123">Spring Cloud Bus在<code i="1690">spring.cloud.bus.*</code>中具有少量本地配置属性（例如<code i="1691">spring.cloud.bus.destination</code>是使用外部中间件的主题的名称）。</font><font o="3124">通常，默认值就足够了。</font></p>
</div>
<div class="paragraph">
<p><font o="3125">要更多地了解如何自定义消息代理设置，请参阅Spring Cloud Stream文档。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tracing_bus_events"><font o="3126">跟踪Bus Events</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3127">可以通过设置<code i="1693">spring.cloud.bus.trace.enabled=true</code>来跟踪总线事件（<code i="1692">RemoteApplicationEvent</code>的子类）。</font><font o="3128">如果这样做，那么Spring Boot <code i="1694">TraceRepository</code>（如果存在）将显示每个发送的事件和来自每个服务实例的所有ack。</font><font o="3129">示例（来自<code i="1695">/trace</code>端点）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
  "timestamp": "2015-11-26T10:24:44.411+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "stores:8081",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.864+0000",
  "info": {
    "signal": "spring.cloud.bus.sent",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.862+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3130">该跟踪显示<code i="1696">RefreshRemoteApplicationEvent</code>从<code i="1697">customers:9000</code>发送到所有服务，并且已被<code i="1698">customers:9000</code>和<code i="1699">stores:8081</code>收到（acked）。</font></p>
</div>
<div class="paragraph">
<p><font o="3131">为了处理信号，您可以向您的应用添加<code i="1701">AckRemoteApplicationEvent</code>和<code i="1702">SentApplicationEvent</code>类型的<code i="1700">@EventListener</code>（并启用跟踪）。</font><font o="3132">或者您可以利用<code i="1703">TraceRepository</code>并从中挖掘数据。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3133">注意</font></div>
</td>
<td class="content"><font o="3134">
任何总线应用程序都可以跟踪ack，但有时在一个可以对数据进行更复杂查询的中央服务器中执行此操作是有用的。</font><font o="3135">或者将其转发到专门的跟踪服务。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_broadcasting_your_own_events"><font o="3136">广播自己的Events</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3137">总线可以携带任何类型为<code i="1704">RemoteApplicationEvent</code>的事件，但默认传输是JSON，并且解串器需要知道哪些类型将提前使用。</font><font o="3138">要注册一个新类型，它需要在<code i="1705">org.springframework.cloud.bus.event</code>的子包中。</font></p>
</div>
<div class="paragraph">
<p><font o="3139">要自定义事件名称，您可以在自定义类上使用<code i="1706">@JsonTypeName</code>，或者依赖默认策略来使用类的简单名称。</font><font o="3140">请注意，生产者和消费者都需要访问类定义。</font></p>
</div>
<div class="sect2">
<h3 id="_registering_events_in_custom_packages"><font o="3141">在自定义包中注册事件</font></h3>
<div class="paragraph">
<p><font o="3142">如果您不能或不想为自定义事件使用<code i="1707">org.springframework.cloud.bus.event</code>的子包，则必须使用<code i="1709">@RemoteApplicationEventScan</code>指定要扫描类型为<code i="1708">RemoteApplicationEvent</code>的事件的包。</font><font o="3143">使用<code i="1710">@RemoteApplicationEventScan</code>指定的软件包包括子包。</font></p>
</div>
<div class="paragraph">
<p><font o="3144">例如，如果您有一个名为<code i="1711">FooEvent</code>的自定义事件：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.acme;

public class FooEvent extends RemoteApplicationEvent {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3145">您可以通过以下方式与解串器注册此事件：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.acme;

@Configuration
@RemoteApplicationEventScan
public class BusConfiguration {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3146">没有指定一个值，使用<code i="1712">@RemoteApplicationEventScan</code>的类的包将被注册。</font><font o="3147">在这个例子中，<code i="1713">com.acme</code>将使用<code i="1714">BusConfiguration</code>的包进行注册。</font></p>
</div>
<div class="paragraph">
<p><font o="3148">您还可以使用<code i="1718">@RemoteApplicationEventScan</code>上的<code i="1715">value</code>，<code i="1716">basePackages</code>或<code i="1717">basePackageClasses</code>属性明确指定要扫描的软件包。</font><font o="3149">例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.acme;

@Configuration
//@RemoteApplicationEventScan({"com.acme", "foo.bar"})
//@RemoteApplicationEventScan(basePackages = {"com.acme", "foo.bar", "fizz.buzz"})
@RemoteApplicationEventScan(basePackageClasses = BusConfiguration.class)
public class BusConfiguration {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3150">以上<code i="1719">@RemoteApplicationEventScan</code>的所有示例都是等效的，因为<code i="1720">com.acme</code>程序包将通过在<code i="1721">@RemoteApplicationEventScan</code>上明确指定程序包来注册。</font><font o="3151">请注意，您可以指定要扫描的多个基本软件包。</font></p>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_sleuth" class="sect0"><font o="3152">Spring Cloud Sleuth</font></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><font o="3153">Adrian Cole，Spencer Gibb，Marcin Grzejszczak，Dave Syer</font></p>
</div>
<div class="paragraph">
<p><strong><font o="3154">Dalston.RELEASE</font></strong></p>
</div>
<div class="paragraph">
<p><font o="3155">Spring Cloud Sleuth为</font><a href="http://cloud.spring.io/"><font o="3155">Spring Cloud</font></a><font o="3155">实现分布式跟踪解决方案</font><font o="3155">。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_terminology"><font o="3156">术语</font></h3>
<div class="paragraph">
<p><font o="3157">Spring Cloud Sleuth借用了</font><a href="http://research.google.com/pubs/pub36356.html"><font o="3157">Dapper的</font></a><font o="3157">术语。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="3158">Span：</font></strong><font o="3158">工作的基本单位 </font><font o="3159">例如，发送RPC是一个新的跨度，以及向RPC发送响应。</font><font o="3160">Span由跨度的唯一64位ID标识，跨度是其中一部分的跟踪的另一个64位ID。</font><font o="3161">跨度还具有其他数据，例如描述，时间戳记事件，键值注释（标签），导致它们的跨度的ID以及进程ID（通常是IP地址）。</font></p>
</div>
<div class="paragraph">
<p><font o="3162">跨距开始和停止，他们跟踪他们的时间信息。</font><font o="3163">创建跨度后，必须在将来的某个时刻停止。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3164">提示</font></div>
</td>
<td class="content"><font o="3165">
启动跟踪的初始范围称为<code i="1722">root span</code>。</font><font o="3166">该跨度的跨度id的值等于跟踪ID。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong><font o="3167">跟踪：</font></strong><font o="3167">一组spans形成树状结构。</font><font o="3168">例如，如果您正在运行分布式大数据存储，则可能会由put请求形成跟踪。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="3169">注释：</font></strong><font o="3169">   用于及时记录事件的存在。</font><font o="3170">用于定义请求的开始和停止的一些核心注释是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font o="3171">cs</font></strong><font o="3171"> - 客户端发送 - 客户端已经发出请求。</font><font o="3172">此注释描绘了跨度的开始。</font></p>
</li>
<li>
<p><strong><font o="3173">sr</font></strong><font o="3173"> - 服务器接收 - 服务器端得到请求，并将开始处理它。</font><font o="3174">如果从此时间戳中减去cs时间戳，则会收到网络延迟。</font></p>
</li>
<li>
<p><strong><font o="3175">ss</font></strong><font o="3175"> - 服务器发送 - 在完成请求处理后（响应发送回客户端时）注释。</font><font o="3176">如果从此时间戳中减去sr时间戳，则会收到服务器端处理请求所需的时间。</font></p>
</li>
<li>
<p><strong><font o="3177">cr</font></strong><font o="3177"> - 客户端接收 - 表示跨度的结束。</font><font o="3178">客户端已成功接收到服务器端的响应。</font><font o="3179">如果从此时间戳中减去cs时间戳，则会收到客户端从服务器接收响应所需的整个时间。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3180">可视化</font><strong><font o="3180">Span</font></strong><font o="3180">和</font><strong><font o="3180">Trace</font></strong><font o="3180">将与Zipkin注释一起查看系统：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/trace-id.png" alt="跟踪信息传播">
</div>
</div>
<div class="paragraph">
<p><font o="3181">一个音符的每个颜色表示跨度（7 spans  - 从</font><strong><font o="3181">A</font></strong><font o="3181">到</font><strong><font o="3181">G</font></strong><font o="3181">）。</font><font o="3182">如果您在笔记中有这样的信息：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>Trace Id = X
Span Id = D
Client Sent</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3183">这意味着，当前的跨度</font><strong><font o="3183">痕量-ID</font></strong><font o="3183">设置为</font><strong><font o="3183">X</font></strong><font o="3183">，</font><strong><font o="3183">Span -编号</font></strong><font o="3183">设置为</font><strong><font o="3183">ð</font></strong><font o="3183">。</font><font o="3184">它也发出了
  </font><strong><font o="3184">客户端发送的</font></strong><font o="3184">事件。</font></p>
</div>
<div class="paragraph">
<p><font o="3185">这样，spans的父/子关系的可视化将如下所示：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/parents.png" alt="父子关系">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_purpose"><font o="3186">目的</font></h3>
<div class="paragraph">
<p><font o="3187">在以下部分中，将考虑上述图像中的示例。</font></p>
</div>
<div class="sect3">
<h4 id="_distributed_tracing_with_zipkin"><font o="3188">分布式跟踪与Zipkin</font></h4>
<div class="paragraph">
<p><font o="3189">共有</font><strong><font o="3189">7个spans</font></strong><font o="3189">。</font><font o="3190">如果您在Zipkin中查看痕迹，您将在第二个曲目中看到这个数字：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/zipkin-traces.png" alt="痕迹">
</div>
</div>
<div class="paragraph">
<p><font o="3191">但是，如果您选择特定的跟踪，那么您将看到</font><strong><font o="3191">4 spans</font></strong><font o="3191">：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/zipkin-ui.png" alt="跟踪信息传播">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3192">注意</font></div>
</td>
<td class="content"><font o="3193">
当选择特定的跟踪时，您将看到合并的spans。</font><font o="3194">这意味着如果发送到服务器接收和服务器发送/接收客户端和客户端发送注释的Zipkin有2个spans，那么它们将被显示为一个跨度。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3195">为什么在这种情况下，7和4 spans之间有区别？</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3196">2 spans来自<code i="1723">http:/start</code>范围。</font><font o="3197">它具有服务器接收（SR）和服务器发送（SS）注释。</font></p>
</li>
<li>
<p><font o="3198">2 spans来自<code i="1724">service1</code>到<code i="1725">service2</code>到<code i="1726">http:/foo</code>端点的RPC呼叫。</font><font o="3199">它在<code i="1727">service1</code>方面具有客户端发送（CS）和客户端接收（CR）注释。</font><font o="3200">它还在<code i="1728">service2</code>方面具有服务器接收（SR）和服务器发送（SS）注释。</font><font o="3201">在物理上有2个spans，但它们形成与RPC调用相关的1个逻辑跨度。</font></p>
</li>
<li>
<p><font o="3202">2 spans来自<code i="1729">service2</code>到<code i="1730">service3</code>到<code i="1731">http:/bar</code>端点的RPC呼叫。</font><font o="3203">它在<code i="1732">service2</code>方面具有客户端发送（CS）和客户接收（CR）注释。</font><font o="3204">它还具有<code i="1733">service3</code>端的服务器接收（SR）和服务器发送（SS）注释。</font><font o="3205">在物理上有2个spans，但它们形成与RPC调用相关的1个逻辑跨度。</font></p>
</li>
<li>
<p><font o="3206">2 spans来自<code i="1734">service2</code>到<code i="1735">service4</code>到<code i="1736">http:/baz</code>端点的RPC呼叫。</font><font o="3207">它在<code i="1737">service2</code>方面具有客户端发送（CS）和客户接收（CR）注释。</font><font o="3208">它还在<code i="1738">service4</code>侧具有服务器接收（SR）和服务器发送（SS）注释。</font><font o="3209">在物理上有2个spans，但它们形成与RPC调用相关的1个逻辑跨度。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3210">因此，如果我们计算spans </font><font o="3210">，<code i="1739">http:/start</code>中</font><font o="3210">有</font><strong><font o="3210">1 </font></strong><font></font><strong><font o="3210">个</font></strong><font o="3210">来自<code i="1740">service1</code>的呼叫<code i="1741">service2</code>，</font><strong><font o="3210">2</font></strong><font o="3210">（<code i="1742">service2</code>）呼叫<code i="1743">service3</code>和</font><strong><font o="3210">2</font></strong><font o="3210">（<code i="1744">service2</code>） <code i="1745">service4</code>。</font><font o="3211">共</font><strong><font o="3211">7个</font></strong><font o="3211"> spans。</font></p>
</div>
<div class="paragraph">
<p><font o="3212">逻辑上，我们看到</font><strong><font o="3212">Total Spans的信息：4</font></strong><font o="3212">，因为我们有</font><strong><font o="3212">1个</font></strong><font o="3212">跨度与传入请求相关的<code i="1746">service1</code>和</font><strong><font o="3212">3</font></strong><font o="3212"> spans与RPC调用相关。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_visualizing_errors"><font o="3213">可视化错误</font></h4>
<div class="paragraph">
<p><font o="3214">Zipkin允许您可视化跟踪中的错误。</font><font o="3215">当异常被抛出并且没有被捕获时，我们在Zipkin可以正确着色的跨度上设置适当的标签。</font><font o="3216">您可以在痕迹列表中看到一条是红色的痕迹。</font><font o="3217">这是因为抛出了一个异常。</font></p>
</div>
<div class="paragraph">
<p><font o="3218">如果您点击该轨迹，您将看到类似的图片</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/zipkin-error-traces.png" alt="错误跟踪">
</div>
</div>
<div class="paragraph">
<p><font o="3219">然后，如果您点击其中一个spans，您将看到以下内容</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/zipkin-error-trace-screenshot.png" alt="错误跟踪信息传播">
</div>
</div>
<div class="paragraph">
<p><font o="3220">你可以看到，你可以很容易的看到错误的原因和整个stacktrace相关的。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_live_examples"><font o="3221">实例</font></h4>
<div class="imageblock">
<div class="content">
<a class="image" href="https://docssleuth-zipkin-server.cfapps.io/"><img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/pws.png" alt="Zipkin部署在Pivotal Web Services上" width="150" height="74"></a>
</div>
<div class="title"><font o="3222">点击Pivotal Web Services图标即可实时查看！点击Pivotal Web Services图标直播！</font></div>
</div>
<div class="paragraph">
<p><font o="3223">Zipkin中的依赖图将如下所示：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/dependencies.png" alt="依赖">
</div>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://docssleuth-zipkin-server.cfapps.io/dependency"><img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/pws.png" alt="Zipkin部署在Pivotal Web Services上" width="150" height="74"></a>
</div>
<div class="title"><font o="3224">点击Pivotal Web Services图标即可实时查看！点击Pivotal Web Services图标直播！</font></div>
</div>
</div>
<div class="sect3">
<h4 id="_log_correlation"><font o="3225">对数相关</font></h4>
<div class="paragraph">
<p><font o="3226">当通过跟踪id等于例如<code i="1747">2485ec27856c56f4</code>来对这四个应用程序的日志进行灰名单时，将会得到以下内容：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>service1.log:2016-02-26 11:15:47.561  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Hello from service1. Calling service2
service2.log:2016-02-26 11:15:47.710  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Hello from service2. Calling service3 and then service4
service3.log:2016-02-26 11:15:47.895  INFO [service3,2485ec27856c56f4,1210be13194bfe5,true] 68060 --- [nio-8083-exec-1] i.s.c.sleuth.docs.service3.Application   : Hello from service3
service2.log:2016-02-26 11:15:47.924  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service3 [Hello from service3]
service4.log:2016-02-26 11:15:48.134  INFO [service4,2485ec27856c56f4,1b1845262ffba49d,true] 68061 --- [nio-8084-exec-1] i.s.c.sleuth.docs.service4.Application   : Hello from service4
service2.log:2016-02-26 11:15:48.156  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service4 [Hello from service4]
service1.log:2016-02-26 11:15:48.182  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Got response from service2 [Hello from service2, response from service3 [Hello from service3] and from service4 [Hello from service4]]</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3227">如果你使用像一个日志聚合工具</font><a href="https://www.elastic.co/products/kibana"><font o="3227">Kibana</font></a><font o="3227">，
 </font><a href="http://www.splunk.com/"><font o="3227">Splunk的</font></a><font o="3227">等您可以订购所发生的事件。</font><font o="3228">基巴纳的例子如下所示：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/kibana.png" alt="记录与Kibana的相关性">
</div>
</div>
<div class="paragraph">
<p><font o="3229">如果你想使用</font><a href="https://www.elastic.co/guide/en/logstash/current/index.html"><font o="3229">Logstash，</font></a><font o="3229">这里是</font><a href="https://www.elastic.co/guide/en/logstash/current/index.html"><font o="3229">Logstash</font></a><font o="3229">的Grok模式：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3230">注意</font></div>
</td>
<td class="content"><font o="3231">
如果您想将Grok与Cloud Foundry的日志一起使用，则必须使用此模式：
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "(?m)OUT\s+%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_json_logback_with_logstash"><font o="3232">使用Logstash进行JSON回溯</font></h5>
<div class="paragraph">
<p><font o="3233">通常，您不希望将日志存储在文本文件中，而不是将Logstash可以立即选择的JSON文件中存储。</font><font o="3234">为此，您必须执行以下操作（为了可读性，我们将依赖关系传递给<code i="1748">groupId:artifactId:version</code>符号。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="3235">依赖关系设置</font></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3236">确保Logback位于类路径（<code i="1749">ch.qos.logback:logback-core</code>）</font></p>
</li>
<li>
<p><font o="3237">添加Logstash Logback编码 - 版本<code i="1750">4.6</code>的示例：<code i="1751">net.logstash.logback:logstash-logback-encoder:4.6</code></font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><font o="3238">回读设置</font></strong></p>
</div>
<div class="paragraph">
<p><font o="3239">您可以在下面找到一个Logback配置（名为</font><a href="https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml"><font o="3239">logback-spring.xml</font></a><font o="3239">）</font><a href="https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml"><font o="3239">的示例</font></a><font o="3239">：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3240">将来自应用程序的信息以JSON格式记录到<code i="1752">build/${spring.application.name}.json</code>文件</font></p>
</li>
<li>
<p><font o="3241">已经评论了两个额外的追加者 - 控制台和标准日志文件</font></p>
</li>
<li>
<p><font o="3242">具有与上一节所述相同的记录模式</font></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
	&lt;include resource="org/springframework/boot/logging/logback/defaults.xml"/&gt;
	​
	&lt;springProperty scope="context" name="springAppName" source="spring.application.name"/&gt;
	&lt;!-- Example for logging into the build folder of your project --&gt;
	&lt;property name="LOG_FILE" value="${BUILD_FOLDER:-build}/${springAppName}"/&gt;​

	&lt;!-- You can override this to have a custom pattern --&gt;
	&lt;property name="CONSOLE_LOG_PATTERN"
			  value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"/&gt;

	&lt;!-- Appender to log to console --&gt;
	&lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;
		&lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;
			&lt;!-- Minimum logging level to be presented in the console logs--&gt;
			&lt;level&gt;DEBUG&lt;/level&gt;
		&lt;/filter&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;
			&lt;charset&gt;utf8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;

	&lt;!-- Appender to log to file --&gt;​
	&lt;appender name="flatfile" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;file&gt;${LOG_FILE}&lt;/file&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;${LOG_FILE}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;
			&lt;maxHistory&gt;7&lt;/maxHistory&gt;
		&lt;/rollingPolicy&gt;
		&lt;encoder&gt;
			&lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;
			&lt;charset&gt;utf8&lt;/charset&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
	​
	&lt;!-- Appender to log to file in a JSON format --&gt;
	&lt;appender name="logstash" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
		&lt;file&gt;${LOG_FILE}.json&lt;/file&gt;
		&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
			&lt;fileNamePattern&gt;${LOG_FILE}.json.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;
			&lt;maxHistory&gt;7&lt;/maxHistory&gt;
		&lt;/rollingPolicy&gt;
		&lt;encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"&gt;
			&lt;providers&gt;
				&lt;timestamp&gt;
					&lt;timeZone&gt;UTC&lt;/timeZone&gt;
				&lt;/timestamp&gt;
				&lt;pattern&gt;
					&lt;pattern&gt;
						{
						"severity": "%level",
						"service": "${springAppName:-}",
						"trace": "%X{X-B3-TraceId:-}",
						"span": "%X{X-B3-SpanId:-}",
						"parent": "%X{X-B3-ParentSpanId:-}",
						"exportable": "%X{X-Span-Export:-}",
						"pid": "${PID:-}",
						"thread": "%thread",
						"class": "%logger{40}",
						"rest": "%message"
						}
					&lt;/pattern&gt;
				&lt;/pattern&gt;
			&lt;/providers&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
	​
	&lt;root level="INFO"&gt;
		&lt;appender-ref ref="console"/&gt;
		&lt;!-- uncomment this to have also JSON logs --&gt;
		&lt;!--&lt;appender-ref ref="logstash"/&gt;--&gt;
		&lt;!--&lt;appender-ref ref="flatfile"/&gt;--&gt;
	&lt;/root&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3243">注意</font></div>
</td>
<td class="content"><font o="3244">
如果您使用自定义<code i="1753">logback-spring.xml</code>，则必须通过<code i="1755">bootstrap</code> <code i="1756">application</code>而不是<code i="1756">application</code>属性文件传递<code i="1754">spring.application.name</code>。</font><font o="3245">否则您的自定义logback文件将不会正确读取该属性。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_propagating_span_context"><font o="3246">传播Span上下文</font></h4>
<div class="paragraph">
<p><font o="3247">跨度上下文是必须传播到任何子进程跨越进程边界的状态。</font><font o="3248">Span背景的一部分是行李。</font><font o="3249">跟踪和跨度ID是跨度上下文的必需部分。</font><font o="3250">行李是可选的部分。</font></p>
</div>
<div class="paragraph">
<p><font o="3251">行李是一组密钥：存储在范围上下文中的值对。</font><font o="3252">行李与痕迹一起旅行，并附在每一个跨度上。</font><font o="3253">Spring Cloud如果HTTP标头以<code i="1757">baggage-</code>为前缀，并且以<code i="1758">baggage_</code>开头的消息传递，Sleuth将会明白标题是行李相关的。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3254">重要</font></div>
</td>
<td class="content"><font o="3255">
行李物品的数量或大小目前没有限制。</font><font o="3256">但是，请记住，太多可能会降低系统吞吐量或增加RPC延迟。</font><font o="3257">在极端情况下，由于超出了传输级消息或报头容量，可能会使应用程序崩溃。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3258">在跨度上设置行李的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Span initialSpan = this.tracer.createSpan("span");
initialSpan.setBaggageItem("foo", "bar");</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_baggage_vs_span_tags"><font o="3259">行李与Span标签</font></h5>
<div class="paragraph">
<p><font o="3260">行李随行旅行（即每个孩子跨度都包含其父母的行李）。</font><font o="3261">Zipkin不了解行李，甚至不会收到这些信息。</font></p>
</div>
<div class="paragraph">
<p><font o="3262">标签附加到特定的跨度 - 它们仅针对该特定跨度呈现。</font><font o="3263">但是，您可以通过标签搜索查找跟踪，其中存在具有搜索标签值的跨度。</font></p>
</div>
<div class="paragraph">
<p><font o="3264">如果您希望能够根据行李查找跨度，则应在根跨度中添加相应的条目作为标签。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Autowired Tracer tracer;

Span span = tracer.getCurrentSpan();
String baggageKey = "key";
String baggageValue = "foo";
span.setBaggageItem(baggageKey, baggageValue);
tracer.addTag(baggageKey, baggageValue);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_to_the_project"><font o="3265">添加到项目中</font></h3>
<div class="sect3">
<h4 id="_only_sleuth_log_correlation"><font o="3266">只有Sleuth（对数相关）</font></h4>
<div class="paragraph">
<p><font o="3267">如果您只想从Spring Cloud Sleuth中获利，而没有Zipkin集成，只需将<code i="1759">spring-cloud-starter-sleuth</code>模块添加到您的项目中即可。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="3268">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <b class="conum">(1)</b>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;Camden.RELEASE&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <b class="conum">(2)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3269">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3270">将依赖关系添加到<code i="1760">spring-cloud-starter-sleuth</code></font></p>
</li>
</ol>
</div>
<div class="listingblock secondary">
<div class="title"><font o="3271">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">dependencyManagement { <b class="conum">(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Camden.RELEASE"
    }
}

dependencies { <b class="conum">(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-sleuth"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3272">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3273">将依赖关系添加到<code i="1761">spring-cloud-starter-sleuth</code></font></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_sleuth_with_zipkin_via_http"><font o="3274">通过HTTP访问Zipkin</font></h4>
<div class="paragraph">
<p><font o="3275">如果你想要Sleuth和Zipkin只需添加<code i="1762">spring-cloud-starter-zipkin</code>依赖关系。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="3276">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <b class="conum">(1)</b>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;Camden.RELEASE&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <b class="conum">(2)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3277">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3278">将依赖关系添加到<code i="1763">spring-cloud-starter-zipkin</code></font></p>
</li>
</ol>
</div>
<div class="listingblock secondary">
<div class="title"><font o="3279">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">dependencyManagement { <b class="conum">(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Camden.RELEASE"
    }
}

dependencies { <b class="conum">(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-zipkin"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3280">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3281">将依赖关系添加到<code i="1764">spring-cloud-starter-zipkin</code></font></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_sleuth_with_zipkin_via_spring_cloud_stream"><font o="3282">通过Spring Cloud Stream使用Zipkin的Sleuth</font></h4>
<div class="paragraph">
<p><font o="3283">如果你想要Sleuth和Zipkin只需添加<code i="1765">spring-cloud-sleuth-stream</code>依赖关系。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="3284">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <b class="conum">(1)</b>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;Camden.RELEASE&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <b class="conum">(2)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-sleuth-stream&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt; <b class="conum">(3)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;!-- EXAMPLE FOR RABBIT BINDING --&gt;
   &lt;dependency&gt; <b class="conum">(4)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3285">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3286">将依赖关系添加到<code i="1766">spring-cloud-sleuth-stream</code></font></p>
</li>
<li>
<p><font o="3287">将依赖关系添加到<code i="1767">spring-cloud-starter-sleuth</code>中，这样就可以下载依赖关系</font></p>
</li>
<li>
<p><font o="3288">添加一个粘合剂（例如Rabbit binder）来告诉Spring Cloud Stream应该绑定什么</font></p>
</li>
</ol>
</div>
<div class="listingblock secondary">
<div class="title"><font o="3289">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">dependencyManagement { <b class="conum">(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Camden.RELEASE"
    }
}

dependencies {
    compile "org.springframework.cloud:spring-cloud-sleuth-stream" <b class="conum">(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-sleuth" <b class="conum">(3)</b>
    // Example for Rabbit binding
    compile "org.springframework.cloud:spring-cloud-stream-binder-rabbit" <b class="conum">(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3290">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3291">将依赖关系添加到<code i="1768">spring-cloud-sleuth-stream</code></font></p>
</li>
<li>
<p><font o="3292">将依赖关系添加到<code i="1769">spring-cloud-starter-sleuth</code>中，这样就可以下载所有依赖关系</font></p>
</li>
<li>
<p><font o="3293">添加一个粘合剂（例如Rabbit binder）来告诉Spring Cloud Stream应该绑定什么</font></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_spring_cloud_sleuth_stream_zipkin_collector"><font o="3294">Spring Cloud Sleuth Stream Zipkin收藏家</font></h4>
<div class="paragraph">
<p><font o="3295">如果要启动Spring Cloud Sleuth Stream Zipkin收藏夹，只需添加<code i="1770">spring-cloud-sleuth-zipkin-stream</code>依赖关系即可</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="3296">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <b class="conum">(1)</b>
         &lt;dependencies&gt;
             &lt;dependency&gt;
                 &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                 &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                 &lt;version&gt;Camden.RELEASE&lt;/version&gt;
                 &lt;type&gt;pom&lt;/type&gt;
                 &lt;scope&gt;import&lt;/scope&gt;
             &lt;/dependency&gt;
         &lt;/dependencies&gt;
   &lt;/dependencyManagement&gt;

   &lt;dependency&gt; <b class="conum">(2)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-sleuth-zipkin-stream&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;dependency&gt; <b class="conum">(3)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
   &lt;/dependency&gt;
   &lt;!-- EXAMPLE FOR RABBIT BINDING --&gt;
   &lt;dependency&gt; <b class="conum">(4)</b>
       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
       &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;
   &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3297">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3298">将依赖关系添加到<code i="1771">spring-cloud-sleuth-zipkin-stream</code></font></p>
</li>
<li>
<p><font o="3299">将依赖关系添加到<code i="1772">spring-cloud-starter-sleuth</code>  - 这样一来，所有的依赖依赖将被下载</font></p>
</li>
<li>
<p><font o="3300">添加一个粘合剂（例如Rabbit binder）来告诉Spring Cloud Stream应该绑定什么</font></p>
</li>
</ol>
</div>
<div class="listingblock secondary">
<div class="title"><font o="3301">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">dependencyManagement { <b class="conum">(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Camden.RELEASE"
    }
}

dependencies {
    compile "org.springframework.cloud:spring-cloud-sleuth-zipkin-stream" <b class="conum">(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-sleuth" <b class="conum">(3)</b>
    // Example for Rabbit binding
    compile "org.springframework.cloud:spring-cloud-stream-binder-rabbit" <b class="conum">(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><font o="3302">为了不自己选择版本，如果您通过Spring BOM添加依赖关系管理，会更好</font></p>
</li>
<li>
<p><font o="3303">将依赖关系添加到<code i="1773">spring-cloud-sleuth-zipkin-stream</code></font></p>
</li>
<li>
<p><font o="3304">将依赖关系添加到<code i="1774">spring-cloud-starter-sleuth</code>  - 这样将依赖关系依赖下载</font></p>
</li>
<li>
<p><font o="3305">添加一个粘合剂（例如Rabbit binder）来告诉Spring Cloud Stream应该绑定什么</font></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><font o="3306">然后使用<code i="1775">@EnableZipkinStreamServer</code>注释注释你的主类：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.sleuth.zipkin.stream.EnableZipkinStreamServer;

@SpringBootApplication
@EnableZipkinStreamServer
public class ZipkinStreamServerApplication {

	public static void main(String[] args) throws Exception {
		SpringApplication.run(ZipkinStreamServerApplication.class, args);
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_additional_resources"><font o="3307">额外的资源</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong><font o="3308">Marcin Grzejszczak谈论Spring Cloud Sleuth和Zipkin</font></strong></p>
</div>

<div class="paragraph">
<p><a href="https://www.youtube.com/watch?v=eQV71Mw1u1c"><font o="3309">点击此处查看视频</font></a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_features_2"><font o="3310">特征</font></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><font o="3311">将跟踪和跨度添加到Slf4J MDC，以便您可以从日志聚合器中的给定跟踪或跨度中提取所有日志。</font><font o="3312">示例日志：</font></p>
<div class="listingblock">
<div class="content">
<pre class="notranslate">2016-02-02 15:30:57.902  INFO [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:30:58.372 ERROR [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:31:01.936  INFO [bar,46ab0d418373cbc9,46ab0d418373cbc9,false] 23030 --- [nio-8081-exec-4] ...</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3313">注意MDC中的<code i="1776">[appname,traceId,spanId,exportable]</code>条目：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font o="3314">spanId</font></strong><font o="3314"> - 发生特定操作的ID</font></p>
</li>
<li>
<p><strong><font o="3315">appname</font></strong><font o="3315"> - 记录跨度的应用程序的名称</font></p>
</li>
<li>
<p><strong><font o="3316">traceId</font></strong><font o="3316"> - 包含跨度的延迟图的ID</font></p>
</li>
<li>
<p><strong><font o="3317">导出</font></strong><font o="3317"> -日志是否应该被导出到Zipkin与否。</font><font o="3318">你什么时候希望跨度不能出口？</font><font o="3319">在这种情况下，你想在Span中包装一些操作，并将它写入日志。</font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="3320">提供对共同分布式跟踪数据模型的抽象：trace，spans（形成DAG），注释，键值注释。</font><font o="3321">松散地基于HTrace，但Zipkin（Dapper）兼容。</font></p>
</li>
<li>
<p><font o="3322">Sleuth记录定时信息以辅助延迟分析。</font><font o="3323">使用窃贼，您可以精确定位应用程序中的延迟原因。</font><font o="3324">Sleuth被写入不会记录太多，并且不会导致您的生产应用程序崩溃。</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="3325">传播有关您的呼叫图表带内的结构数据，其余的是带外。</font></p>
</li>
<li>
<p><font o="3326">包括有意见的层次测试，如HTTP</font></p>
</li>
<li>
<p><font o="3327">包括采样策略来管理卷</font></p>
</li>
<li>
<p><font o="3328">可以向Zipkin系统报告查询和可视化</font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="3329">仪器来自Spring应用程序（servlet过滤器，异步终结点，休息模板，调度操作，消息通道，zuul过滤器，假客户端）的通用入口和出口点。</font></p>
</li>
<li>
<p><font o="3330">Sleuth包括在http或消息传递边界上加入跟踪的默认逻辑。</font><font o="3331">例如，http传播通过Zipkin兼容的请求标头工作。</font><font o="3332">该传播逻辑是通过<code i="1777">SpanInjector</code>和<code i="1778">SpanExtractor</code>实现来定义和定制的。</font></p>
</li>
<li>
<p><font o="3333">Sleuth可以在进程之间传播上下文（也称为行李）。</font><font o="3334">这意味着如果您设置了Span行李元素，那么它将通过HTTP或消息传递到其他进程发送到下游。</font></p>
</li>
<li>
<p><font o="3335">提供创建/继续spans并通过注释添加标签和日志的方法。</font></p>
</li>
<li>
<p><font o="3336">提供接受/删除spans的简单指标。</font></p>
</li>
<li>
<p><font o="3337">如果<code i="1779">spring-cloud-sleuth-zipkin</code>，则应用程序将生成并收集Zipkin兼容的跟踪。</font><font o="3338">默认情况下，它通过HTTP将其发送到localhost上的Zipkin服务器（端口9411）。</font><font o="3339">使用<code i="1780">spring.zipkin.baseUrl</code>配置服务的位置。</font></p>
</li>
<li>
<p><font o="3340">如果<code i="1781">spring-cloud-sleuth-stream</code>，则该应用将通过</font><a href="https://github.com/spring-cloud/spring-cloud-stream"><font o="3340">Spring Cloud Stream</font></a><font o="3340">生成和收集跟踪</font><font o="3340">。</font><font o="3341">您的应用程序自动成为通过您的代理商发送的跟踪消息的生产者（例如RabbitMQ，Apache Kafka，Redis））。</font></p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3342">重要</font></div>
</td>
<td class="content"><font o="3343">
如果使用Zipkin或Stream，请使用<code i="1782">spring.sleuth.sampler.percentage</code>（默认0.1，即10％）配置spans的百分比。</font><strong><font o="3344">否则你可能认为Sleuth不工作，因为它省略了一些spans。</font></strong>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3345">注意</font></div>
</td>
<td class="content"><font o="3346">
始终设置SLF4J MDC，并且Logback用户将立即按照上述示例查看日志中的跟踪和跨度ID。</font><font o="3347">其他日志记录系统必须配置自己的格式化程序以获得相同的结果。</font><font o="3348">默认值为<code i="1783">logging.pattern.level</code>设置为<code i="1784">%5p [${spring.zipkin.service.name:${spring.application.name:-}},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}]</code>（这是回访用户的Spring Boot功能）。
 </font><strong><font o="3349">这意味着如果您不使用SLF4J，则不会自动应用此模式</font></strong><font o="3349">。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sampling"><font o="3350">采样</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3351">在分布式跟踪中，数据量可能非常高，因此采样可能很重要（您通常不需要导出所有spans以获得正在发生的情况）。</font><font o="3352">Spring Cloud Sleuth具有<code i="1785">Sampler</code>策略，您可以实现该策略来控制采样算法。</font><font o="3353">采样器不会停止生成跨度（相关）ids，但是它们确实阻止了附加和导出的标签和事件。</font><font o="3354">默认情况下，您将获得一个策略，如果跨度已经处于活动状态，则会继续跟踪，但新策略始终被标记为不可导出。</font><font o="3355">如果您的所有应用程序都使用此采样器运行，您将看到日志中的跟踪，但不会在任何远程存储中。</font><font o="3356">对于测试，默认值通常是足够的，如果您仅使用日志（例如使用ELK聚合器），则可能是您需要的。</font><font o="3357">如果要将span数据导出到Zipkin或Spring Cloud Stream，则还有一个<code i="1786">AlwaysSampler</code>导出所有内容，并且<code i="1787">PercentageBasedSampler</code>对spans的固定分数进行采样。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3358">注意</font></div>
</td>
<td class="content"><font o="3359">
如果您使用<code i="1789">spring-cloud-sleuth-zipkin</code>或<code i="1790">spring-cloud-sleuth-stream</code>，则默认为<code i="1788">PercentageBasedSampler</code>。</font><font o="3360">您可以使用<code i="1791">spring.sleuth.sampler.percentage</code>配置导出。</font><font o="3361">通过的价值需要从<code i="1792">0.0</code>到<code i="1793">1.0</code>的双倍，所以不是百分比。</font><font o="3362">为了向后兼容性原因，我们不会更改属性名称。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3363">可以通过创建一个bean定义来安装采样器，例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
public Sampler defaultSampler() {
	return new AlwaysSampler();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3364">提示</font></div>
</td>
<td class="content"><font o="3365">
您可以将HTTP标头<code i="1794">X-B3-Flags</code>设置为<code i="1795">1</code>，或者在进行消息传递时，您可以将<code i="1796">spanFlags</code>标题设置为<code i="1797">1</code>。</font><font o="3366">然后，无论采样决定如何，当前跨度都将被强制输出。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_instrumentation"><font o="3367">仪表</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3368">Spring Cloud Sleuth自动为您的所有Spring应用程序设备，因此您不必执行任何操作即可激活它。</font><font o="3369">根据可用的堆栈，例如对于我们使用<code i="1798">Filter</code>的servlet web应用程序，以及Spring Integration我们使用<code i="1799">ChannelInterceptors</code>），可以使用各种技术添加仪器。</font></p>
</div>
<div class="paragraph">
<p><font o="3370">您可以自定义span标签中使用的键。</font><font o="3371">为了限制跨度数据量，默认情况下，HTTP请求只会被标记为少量的元数据，如状态码，主机和URL。</font><font o="3372">您可以通过配置<code i="1800">spring.sleuth.keys.http.headers</code>（头名称列表）来添加请求头。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3373">注意</font></div>
</td>
<td class="content"><font o="3374">
记住，如果有一个<code i="1801">Sampler</code>允许它（默认情况下没有，所以没有意外收集太多数据而没有配置东西的危险），那么只会收集和导出标签。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3375">注意</font></div>
</td>
<td class="content"><font o="3376">
目前，Spring Cloud Sleuth中的测试仪器是渴望的 - 这意味着我们正在积极地尝试在线程之间传递跟踪上下文。</font><font o="3377">即使在没有将数据导出到跟踪系统的情况下，也会捕获定时事件。</font><font o="3378">这种做法在将来可能会改变为在这件事上懒惰。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_span_lifecycle"><font o="3379">Span生命周期</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3380">您可以通过org.springframework.cloud.sleuth.Tracer接口在Span上</font><strong><font o="3380">执行</font></strong><font o="3380">以下操作：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://springcloud.cc/spring-cloud-dalston.html#creating-and-closing-spans"><font o="3381">开始</font></a><font o="3381"> - 当您启动一个span时，它的名称被分配，并且记录开始时间戳。</font></p>
</li>
<li>
<p><a href="https://springcloud.cc/spring-cloud-dalston.html#creating-and-closing-spans"><font o="3382">关闭</font></a><font o="3382"> - 跨度完成（记录跨度的结束时间），如果跨度可</font><strong><font o="3382">导出，</font></strong><font o="3382">则它将有资格收集到Zipkin。</font><font o="3383">该跨度也从当前线程中移除。</font></p>
</li>
<li>
<p><a href="https://springcloud.cc/spring-cloud-dalston.html#continuing-spans"><font o="3384">继续</font></a><font o="3384"> - 将创建一个新的跨度实例，而它将是它继续的一个副本。</font></p>
</li>
<li>
<p><a href="https://springcloud.cc/spring-cloud-dalston.html#continuing-spans"><font o="3385">分离</font></a><font o="3385"> - 跨度不会停止或关闭。</font><font o="3386">它只从当前线程中删除。</font></p>
</li>
<li>
<p><a href="https://springcloud.cc/spring-cloud-dalston.html#creating-spans-with-explicit-parent"><font o="3387">使用显式父项创建</font></a><font o="3387"> - 您可以创建一个新的跨度，并为其设置一个显式父级</font></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3388">提示</font></div>
</td>
<td class="content"><font o="3389">
Spring为您创建了一个<code i="1802">Tracer</code>的实例。</font><font o="3390">为了使用它，你需要的只是自动连接它。
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="creating-and-closing-spans"><font o="3391">创建和关闭spans</font></h3>
<div class="paragraph">
<p><font o="3392">您可以使用</font><strong><font o="3392">Tracer</font></strong><font o="3392">界面</font><font o="3392">手动创建spans </font><font o="3392">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// Start a span. If there was a span present in this thread it will become
// the `newSpan`'s parent.
Span newSpan = this.tracer.createSpan("calculateTax");
try {
	// ...
	// You can tag a span
	this.tracer.addTag("taxValue", taxValue);
	// ...
	// You can log an event on a span
	newSpan.logEvent("taxCalculated");
} finally {
	// Once done remember to close the span. This will allow collecting
	// the span to send it to Zipkin
	this.tracer.close(newSpan);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3393">在这个例子中，我们可以看到如何创建一个新的跨度实例。</font><font o="3394">假设这个线程中已经存在跨度，那么它将成为该跨度的父代。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3395">重要</font></div>
</td>
<td class="content"><font o="3396">
创建跨度后始终清洁！</font><font o="3397">如果要将其发送到Zipkin，请不要忘记关闭跨度。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3398">重要</font></div>
</td>
<td class="content"><font o="3399">
如果您的span包含的名称大于50个字符，则该名称将被截断为50个字符。</font><font o="3400">你的名字必须是明确而具体的。</font><font o="3401">大名称导致延迟问题，有时甚至引发异常。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="continuing-spans"><font o="3402">继续spans</font></h3>
<div class="paragraph">
<p><font o="3403">有时你不想创建一个新的跨度，但你想继续。</font><font o="3404">这种情况的例子可能是（当然这取决于用例）：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font o="3405">AOP</font></strong><font o="3405"> - 如果在达到方面之前已经创建了一个跨度，则可能不想创建一个新的跨度。</font></p>
</li>
<li>
<p><strong><font o="3406">Hystrix</font></strong><font o="3406"> - 执行Hystrix命令很可能是当前处理的逻辑部分。</font><font o="3407">实际上，它只是一个技术实现细节，你不一定要反映在跟踪中作为一个单独的存在。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3408">持续的跨度实例等于它继续的范围：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Span continuedSpan = this.tracer.continueSpan(spanToContinue);
assertThat(continuedSpan).isEqualTo(spanToContinue);</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3409">要继续跨度，您可以使用</font><strong><font o="3409">Tracer</font></strong><font o="3409">界面。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X
Span continuedSpan = this.tracer.continueSpan(initialSpan);
try {
	// ...
	// You can tag a span
	this.tracer.addTag("taxValue", taxValue);
	// ...
	// You can log an event on a span
	continuedSpan.logEvent("taxCalculated");
} finally {
	// Once done remember to detach the span. That way you'll
	// safely remove it from the current thread without closing it
	this.tracer.detach(continuedSpan);
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3410">重要</font></div>
</td>
<td class="content"><font o="3411">
创建跨度后始终清洁！</font><font o="3412">如果在一个线程（例如线程X）中开始了某些工作，并且正在等待其他线程（例如Y，Z）完成，请不要忘记分离跨距。</font><font o="3413">那么线程Y，Z中的spans在工作结束时应该被分离。</font><font o="3414">当收集结果时，螺纹X中的跨度应该被关闭。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="creating-spans-with-explicit-parent"><font o="3415">用明确的父代创建spans</font></h3>
<div class="paragraph">
<p><font o="3416">您可能想要开始一个新的跨度，并提供该跨度的显式父级。</font><font o="3417">假设跨度的父项在一个线程中，并且要在另一个线程中启动一个新的跨度。</font><font o="3418"><code i="1804">Tracer</code>接口的<code i="1803">startSpan</code>方法是您要查找的方法。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X. `initialSpan` will be the parent
// of the `newSpan`
Span newSpan = this.tracer.createSpan("calculateCommission", initialSpan);
try {
	// ...
	// You can tag a span
	this.tracer.addTag("commissionValue", commissionValue);
	// ...
	// You can log an event on a span
	newSpan.logEvent("commissionCalculated");
} finally {
	// Once done remember to close the span. This will allow collecting
	// the span to send it to Zipkin. The tags and events set on the
	// newSpan will not be present on the parent
	this.tracer.close(newSpan);
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3419">重要</font></div>
</td>
<td class="content"><font o="3420">
创建这样一个跨度后，记得关闭它。</font><font o="3421">否则，您将在您的日志中看到很多警告，其中有一个事实，即您在当前线程中存在一个跨度，而不是您要关闭的线程。</font><font o="3422">更糟糕的是，您的spans不会正确关闭，因此不会收集到Zipkin。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_naming_spans"><font o="3423">命名spans</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3424">选择一个跨度名称不是一件小事。</font><font o="3425">Span名称应该描述一个操作名称。</font><font o="3426">名称应该是低基数（例如不包括标识符）。</font></p>
</div>
<div class="paragraph">
<p><font o="3427">由于有很多仪器仪表在一些跨度名称将是人为的：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3428"><code i="1805">controller-method-name</code>当控制器以方法名<code i="1806">conrollerMethodName</code>接收时</font></p>
</li>
<li>
<p><font o="3429"><code i="1807">async</code>通过包装<code i="1808">Callable</code>和<code i="1809">Runnable</code>完成异步操作。</font></p>
</li>
<li>
<p><font o="3430"><code i="1810">@Scheduled</code>注释方法将返回类的简单名称。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3431">幸运的是，对于异步处理，您可以提供明确的命名。</font></p>
</div>
<div class="sect2">
<h3 id="__spanname_annotation"><font o="3432">@SpanName注释</font></h3>
<div class="paragraph">
<p><font o="3433">您可以通过<code i="1811">@SpanName</code>注释显式指定该跨度。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpanName("calculateTax")
class TaxCountingRunnable implements Runnable {

	@Override public void run() {
		// perform logic
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3434">在这种情况下，以下列方式处理时：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Runnable runnable = new TraceRunnable(tracer, spanNamer, new TaxCountingRunnable());
Future&lt;?&gt; future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3435">该范围将被命名为<code i="1812">calculateTax</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_tostring_method"><font o="3436">toString（）方法</font></h3>
<div class="paragraph">
<p><font o="3437">为<code i="1813">Runnable</code>或<code i="1814">Callable</code>创建单独的课程很少见。</font><font o="3438">通常，创建这些类的匿名实例。</font><font o="3439">如果没有<code i="1815">@SpanName</code>注释，我们将检查该类是否具有<code i="1816">toString()</code>方法的自定义实现。</font></p>
</div>
<div class="paragraph">
<p><font o="3440">所以执行这样的代码：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Runnable runnable = new TraceRunnable(tracer, spanNamer, new Runnable() {
	@Override public void run() {
		// perform logic
	}

	@Override public String toString() {
		return "calculateTax";
	}
});
Future&lt;?&gt; future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3441">将导致创建一个名为<code i="1817">calculateTax</code>的跨度。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_managing_spans_with_annotations"><font o="3442">管理spans注释</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rationale"><font o="3443">合理</font></h3>
<div class="paragraph">
<p><font o="3444">这个功能的主要论据是</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3445">api-agnostic意味着与跨度进行合作</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="3446">使用注释允许用户添加到跨度api没有库依赖的跨度。</font><font o="3447">这允许Sleuth将其核心api的影响改变为对用户代码的影响较小。</font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="3448">减少基础跨度作业的表面积。</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="3449">没有这个功能，必须使用span api，它具有不正确使用的生命周期命令。</font><font o="3450">通过仅显示范围，标签和日志功能，用户可以协作，而不会意外中断跨度生命周期。</font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="3451">与运行时生成的代码协作</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="3452">使用诸如Spring Data / Feign的库，在运行时生成接口的实现，从而跨越对象的包装是乏味的。</font><font o="3453">现在，您可以通过这些接口的接口和参数提供注释</font></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_new_spans"><font o="3454">创建新的spans</font></h3>
<div class="paragraph">
<p><font o="3455">如果您真的不想手动创建本地spans，您可以从<code i="1818">@NewSpan</code>注释中获利。</font><font o="3456">此外，我们还提供<code i="1819">@SpanTag</code>注释，以自动方式添加标签。</font></p>
</div>
<div class="paragraph">
<p><font o="3457">我们来看一些使用的例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan
void testMethod();</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3458">注释没有任何参数的方法将导致创建名称将等于注释方法名称的新跨度。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan("customNameOnTestMethod4")
void testMethod4();</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3459">如果您在注释中提供值（直接或通过<code i="1820">name</code>参数），则创建的范围将具有提供的值的名称。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// method declaration
@NewSpan(name = "customNameOnTestMethod5")
void testMethod5(@SpanTag("testTag") String param);

// and method execution
this.testBean.testMethod5("test");</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3460">您可以组合名称和标签。</font><font o="3461">我们来关注后者。</font><font o="3462">在这种情况下，无论注释方法的参数运行时值的值如何 - 这将是标记的值。</font><font o="3463">在我们的示例中，标签密钥将为<code i="1821">testTag</code>，标签值为<code i="1822">test</code>。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan(name = "customNameOnTestMethod3")
@Override
public void testMethod3() {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3464">您可以将<code i="1823">@NewSpan</code>注释放在类和接口上。</font><font o="3465">如果覆盖接口的方法并提供不同的<code i="1824">@NewSpan</code>注释值，则最具体的一个获胜（在这种情况下<code i="1825">customNameOnTestMethod3</code>将被设置）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_continuing_spans"><font o="3466">继续spans</font></h3>
<div class="paragraph">
<p><font o="3467">如果您只想添加标签和注释到现有的跨度，就可以使用如下所示的<code i="1826">@ContinueSpan</code>注释。</font><font o="3468">请注意，与<code i="1827">@NewSpan</code>注释相反，您还可以通过<code i="1828">log</code>参数添加日志：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// method declaration
@ContinueSpan(log = "testMethod11")
void testMethod11(@SpanTag("testTag11") String param);

// method execution
this.testBean.testMethod11("test");</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3469">这样，跨越将继续下去：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3470">将创建名称为<code i="1829">testMethod11.before</code>和<code i="1830">testMethod11.after</code>的日志</font></p>
</li>
<li>
<p><font o="3471">如果抛出异常，也将创建一个日志<code i="1831">testMethod11.afterFailure</code></font></p>
</li>
<li>
<p><font o="3472">将创建密钥<code i="1832">testTag11</code>和值<code i="1833">test</code>的标签</font></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_more_advanced_tag_setting"><font o="3473">更高级的标签设置</font></h3>
<div class="paragraph">
<p><font o="3474">有三种不同的方法可以将标签添加到跨度。</font><font o="3475">所有这些都由<code i="1834">SpanTag</code>注释控制。</font><font o="3476">优先级是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3477">尝试使用<code i="1835">TagValueResolver</code>类型的bean，并提供名称</font></p>
</li>
<li>
<p><font o="3478">如果没有提供bean名称，请尝试评估一个表达式。</font><font o="3479">我们正在搜索一个<code i="1836">TagValueExpressionResolver</code> bean。</font><font o="3480">默认实现使用SPEL表达式解析。</font></p>
</li>
<li>
<p><font o="3481">如果没有提供任何表达式来评估只返回参数的<code i="1837">toString()</code>值</font></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_custom_extractor"><font o="3482">自定义提取器</font></h4>
<div class="paragraph">
<p><font o="3483">以下方法的标签值将由<code i="1838">TagValueResolver</code>接口的实现来计算。</font><font o="3484">其类名必须作为<code i="1839">resolver</code>属性的值传递。</font></p>
</div>
<div class="paragraph">
<p><font o="3485">有这样一个注释的方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan
public void getAnnotationForTagValueResolver(@SpanTag(key = "test", resolver = TagValueResolver.class) String test) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3486">和这样一个<code i="1840">TagValueResolver</code> bean实现</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean(name = "myCustomTagValueResolver")
public TagValueResolver tagValueResolver() {
	return parameter -&gt; "Value from myCustomTagValueResolver";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3487">将导致标签值的设置等于<code i="1841">Value from myCustomTagValueResolver</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_resolving_expressions_for_value"><font o="3488">解决表达式的价值</font></h4>
<div class="paragraph">
<p><font o="3489">有这样一个注释的方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan
public void getAnnotationForTagValueExpression(@SpanTag(key = "test", expression = "length() + ' characters'") String test) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3490">并且没有自定义的<code i="1842">TagValueExpressionResolver</code>实现将导致对SPEL表达式的评估，并且将在span上设置值为<code i="1843">4 characters</code>的标签。</font><font o="3491">如果要使用其他表达式解析机制，您可以创建自己的bean实现。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_using_tostring_method"><font o="3492">使用toString方法</font></h4>
<div class="paragraph">
<p><font o="3493">有这样一个注释的方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@NewSpan
public void getAnnotationForArgumentToString(@SpanTag("test") Long param) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3494">如果使用值为<code i="1844">15</code>执行，则将导致设置String值为<code i="1845">"15"</code>的标记。</font></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_customizations"><font o="3495">自定义</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3496">感谢<code i="1846">SpanInjector</code>和<code i="1847">SpanExtractor</code>，您可以自定义spans的创建和传播方式。</font></p>
</div>
<div class="paragraph">
<p><font o="3497">目前有两种在进程之间传递跟踪信息的内置方式：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3498">通过Spring Integration</font></p>
</li>
<li>
<p><font o="3499">通过HTTP</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3500">Span ids从Zipkin兼容（B3）头（<code i="1848">Message</code>或HTTP头）中提取，以启动或加入现有跟踪。</font><font o="3501">跟踪信息被注入到任何出站请求中，所以下一跳可以提取它们。</font></p>
</div>
<div class="paragraph">
<p><font o="3502">与以前版本的Sleuth相比，重要的变化是Sleuth正在实施Open Tracing的<code i="1849">TextMap</code>概念。</font><font o="3503">在Sleuth，它被称为<code i="1850">SpanTextMap</code>。</font><font o="3504">基本上这个想法是通过<code i="1851">SpanTextMap</code>可以抽象出任何通信手段（例如消息，http请求等）。</font><font o="3505">这个抽象定义了如何将数据插入到载体中以及如何从那里检索数据。</font><font o="3506">感谢这样，如果您想要使用一个使用<code i="1852">FooRequest</code>作为发送HTTP请求的平均值的新HTTP库，那么您必须创建一个<code i="1853">SpanTextMap</code>的实现，它将调用委托给<code i="1854">FooRequest</code>检索和插入HTTP标头。</font></p>
</div>
<div class="sect2">
<h3 id="_spring_integration">Spring Integration</h3>
<div class="paragraph">
<p><font o="3508">对于Spring Integration，有2个接口负责从<code i="1855">Message</code>创建Span。</font><font o="3509">这些是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MessagingSpanTextMapExtractor</code></p>
</li>
<li>
<p><code>MessagingSpanTextMapInjector</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3510">您可以通过提供自己的实现来覆盖它们。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_http"><font o="3511">HTTP</font></h3>
<div class="paragraph">
<p><font o="3512">对于HTTP，有2个接口负责从<code i="1856">Message</code>创建Span。</font><font o="3513">这些是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HttpSpanExtractor</code></p>
</li>
<li>
<p><code>HttpSpanInjector</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3514">您可以通过提供自己的实现来覆盖它们。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_example"><font o="3515">例</font></h3>
<div class="paragraph">
<p><font o="3516">我们假设，而不是标准的Zipkin兼容的跟踪HTTP头名称</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3517">for trace id  -  <code i="1857">correlationId</code></font></p>
</li>
<li>
<p><font o="3518">for span id  -  <code i="1858">mySpanId</code></font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3519">这是<code i="1859">SpanExtractor</code>的一个例子</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">static class CustomHttpSpanExtractor implements HttpSpanExtractor {

	@Override public Span joinTrace(SpanTextMap carrier) {
		Map&lt;String, String&gt; map = TextMapUtil.asMap(carrier);
		long traceId = Span.hexToId(map.get("correlationid"));
		long spanId = Span.hexToId(map.get("myspanid"));
		// extract all necessary headers
		Span.SpanBuilder builder = Span.builder().traceId(traceId).spanId(spanId);
		// build rest of the Span
		return builder.build();
	}
}

static class CustomHttpSpanInjector implements HttpSpanInjector {

	@Override
	public void inject(Span span, SpanTextMap carrier) {
		carrier.put("correlationId", span.traceIdString());
		carrier.put("mySpanId", Span.idToHex(span.getSpanId()));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3520">你可以这样注册：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
HttpSpanInjector customHttpSpanInjector() {
	return new CustomHttpSpanInjector();
}

@Bean
HttpSpanExtractor customHttpSpanExtractor() {
	return new CustomHttpSpanExtractor();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3521">Spring Cloud为了安全起见，Sleuth不会将跟踪/跨度相关的标头添加到Http响应。</font><font o="3522">如果您需要标题，那么将标题注入Http响应的自定义<code i="1860">SpanInjector</code>，并且可以使用以下方式添加一个使用此标签的Servlet过滤器：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">static class CustomHttpServletResponseSpanInjector extends ZipkinHttpSpanInjector {

	@Override
	public void inject(Span span, SpanTextMap carrier) {
		super.inject(span, carrier);
		carrier.put(Span.TRACE_ID_NAME, span.traceIdString());
		carrier.put(Span.SPAN_ID_NAME, Span.idToHex(span.getSpanId()));
	}
}

static class HttpResponseInjectingTraceFilter extends GenericFilterBean {

	private final Tracer tracer;
	private final HttpSpanInjector spanInjector;

	public HttpResponseInjectingTraceFilter(Tracer tracer, HttpSpanInjector spanInjector) {
		this.tracer = tracer;
		this.spanInjector = spanInjector;
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
		HttpServletResponse response = (HttpServletResponse) servletResponse;
		Span currentSpan = this.tracer.getCurrentSpan();
		this.spanInjector.inject(currentSpan, new HttpServletResponseTextMap(response));
		filterChain.doFilter(request, response);
	}

	 class HttpServletResponseTextMap implements SpanTextMap {

		 private final HttpServletResponse delegate;

		 HttpServletResponseTextMap(HttpServletResponse delegate) {
			 this.delegate = delegate;
		 }

		 @Override
		 public Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() {
			 Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
			 for (String header : this.delegate.getHeaderNames()) {
				map.put(header, this.delegate.getHeader(header));
			 }
			 return map.entrySet().iterator();
		 }

		 @Override
		 public void put(String key, String value) {
			this.delegate.addHeader(key, value);
		 }
	 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3523">你可以这样注册：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean HttpSpanInjector customHttpServletResponseSpanInjector() {
	return new CustomHttpServletResponseSpanInjector();
}

@Bean
HttpResponseInjectingTraceFilter responseInjectingTraceFilter(Tracer tracer) {
	return new HttpResponseInjectingTraceFilter(tracer, customHttpServletResponseSpanInjector());
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_sa_tag_in_zipkin"><font o="3524">Zipkin中的自定义SA标签</font></h3>
<div class="paragraph">
<p><font o="3525">有时你想创建一个手动Span，将一个电话包裹到一个没有被检测的外部服务。</font><font o="3526">您可以做的是创建一个带有<code i="1861">peer.service</code>标签的跨度，其中包含要调用的服务的值。</font><font o="3527">下面你可以看到一个调用Redis的例子，它被包装在这样一个跨度里。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">org.springframework.cloud.sleuth.Span newSpan = tracer.createSpan("redis");
try {
	newSpan.tag("redis.op", "get");
	newSpan.tag("lc", "redis");
	newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_SEND);
	// call redis service e.g
	// return (SomeObj) redisTemplate.opsForHash().get("MYHASH", someObjKey);
} finally {
	newSpan.tag("peer.service", "redisService");
	newSpan.tag("peer.ipv4", "1.2.3.4");
	newSpan.tag("peer.port", "1234");
	newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_RECV);
	tracer.close(newSpan);
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3528">重要</font></div>
</td>
<td class="content"><font o="3529">
记住不要添加<code i="1862">peer.service</code>标签和<code i="1863">SA</code>标签！</font><font o="3530">您只需添加<code i="1864">peer.service</code>。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_custom_service_name"><font o="3531">自定义服务名称</font></h3>
<div class="paragraph">
<p><font o="3532">默认情况下，Sleuth假设当您将跨度发送到Zipkin时，您希望跨度的服务名称等于<code i="1865">spring.application.name</code>值。</font><font o="3533">这并不总是这样。</font><font o="3534">在某些情况下，您希望为您应用程序中的所有spans提供不同的服务名称。</font><font o="3535">要实现这一点，只需将以下属性传递给应用程序即可覆盖该值（<code i="1866">foo</code>服务名称的示例）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring.zipkin.service.name: foo</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_host_locator"><font o="3536">主机定位器</font></h3>
<div class="paragraph">
<p><font o="3537">为了定义与特定跨度对应的主机，我们需要解析主机名和端口。</font><font o="3538">默认方法是从服务器属性中获取它。</font><font o="3539">如果由于某些原因没有设置，那么我们正在尝试从网络接口检索主机名。</font></p>
</div>
<div class="paragraph">
<p><font o="3540">如果您启用了发现客户端，并且更愿意从服务注册表中注册的实例检索主机地址，那么您必须设置属性（适用于基于HTTP和Stream的跨度报告）。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring.zipkin.locator.discovery.enabled: true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_span_data_as_messages"><font o="3541">Span Data作为消息</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3542">您可以通过将<code i="1867">spring-cloud-sleuth-stream</code> jar作为依赖关系来累加并发送跨越Spring Cloud Stream的数据，并为RabbitMQ或<code i="1869">spring-cloud-starter-stream-kafka</code>添加通道Binder实现（例如<code i="1868">spring-cloud-starter-stream-rabbit</code>）为Kafka）。</font><font o="3542">通过将<code i="1867">spring-cloud-sleuth-stream</code> jar作为依赖关系，并添加RabbitMQ或<code i="1869">spring-cloud-starter-stream-kafka</code>的Binder通道<code i="1868">spring-cloud-starter-stream-rabbit</code>来实现{ </font><a href="http://cloud.spring.io/spring-cloud-stream"><font o="3542">22 /} Stream</font></a><font o="3542">的</font><font o="3542">累积和发送范围数据。
 </font><font o="3542">Kafka）。</font><font o="3543">这将自动将您的应用程序转换为有效载荷类型为<code i="1870">Spans</code>的邮件的制作者。</font></p>
</div>
<div class="sect2">
<h3 id="_zipkin_consumer"><font o="3544">Zipkin消费者</font></h3>
<div class="paragraph">
<p><font o="3545">有一个特殊的便利注释，用于为Span数据设置消息使用者，并将其推入Zipkin <code i="1871">SpanStore</code>。</font><font o="3546">这个应用程序</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableZipkinStreamServer
public class Consumer {
	public static void main(String[] args) {
		SpringApplication.run(Consumer.class, args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3547">将通过Spring Cloud Stream<code i="1872">Binder</code>（例如RabbitMQ包含<code i="1873">spring-cloud-starter-stream-rabbit</code>）来收听您提供的任何运输的Span数据，Redis和Kafka的类似起始者） 。</font><font o="3548">如果添加以下UI依赖关系</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;
&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3549">然后，您将有一个</font><a href="https://github.com/openzipkin/zipkin"><font o="3549">Zipkin服务器</font></a><font o="3549">，</font><font o="3549">您的应用程序
 </font><font o="3549">在端口9411上承载UI和API。</font></p>
</div>
<div class="paragraph">
<p><font o="3550">默认<code i="1874">SpanStore</code>是内存中的（适合演示，快速入门）。</font><font o="3551">对于更强大的解决方案，您可以将MySQL和<code i="1875">spring-boot-starter-jdbc</code>添加到类路径中，并通过配置启用JDBC <code i="1876">SpanStore</code>，例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">spring:
  rabbitmq:
    host: ${RABBIT_HOST:localhost}
  datasource:
    schema: classpath:/mysql.sql
    url: jdbc:mysql://${MYSQL_HOST:localhost}/test
    username: root
    password: root
# Switch this on to create the schema on startup:
    initialize: true
    continueOnError: true
  sleuth:
    enabled: false
zipkin:
  storage:
    type: mysql</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3552">注意</font></div>
</td>
<td class="content"><font o="3553">
<code i="1877">@EnableZipkinStreamServer</code>还用<code i="1878">@EnableZipkinServer</code>注释，因此该过程还将公开标准的Zipkin服务器端点，以通过HTTP收集spans，并在Zipkin Web UI中进行查询。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_custom_consumer"><font o="3554">定制消费者</font></h3>
<div class="paragraph">
<p><font o="3555">也可以使用<code i="1879">spring-cloud-sleuth-stream</code>并绑定到<code i="1880">SleuthSink</code>来轻松实现自定义消费者。</font><font o="3556">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableBinding(SleuthSink.class)
@SpringBootApplication(exclude = SleuthStreamAutoConfiguration.class)
@MessageEndpoint
public class Consumer {

    @ServiceActivator(inputChannel = SleuthSink.INPUT)
    public void sink(Spans input) throws Exception {
        // ... process spans
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3557">注意</font></div>
</td>
<td class="content"><font o="3558">
上面的示例消费者应用程序明确排除<code i="1881">SleuthStreamAutoConfiguration</code>，因此它不会向其自己发送消息，但这是可选的（您可能实际上想要将消息跟踪到消费者应用程序中）。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3559">为了自定义轮询机制，您可以创建名称等于<code i="1883">StreamSpanReporter.POLLER</code>的<code i="1882">PollerMetadata</code>类型的bean。</font><font o="3560">在这里可以找到这样一个配置的例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Configuration
public static class CustomPollerConfiguration {

	@Bean(name = StreamSpanReporter.POLLER)
	PollerMetadata customPoller() {
		PollerMetadata poller = new PollerMetadata();
		poller.setMaxMessagesPerPoll(500);
		poller.setTrigger(new PeriodicTrigger(5000L));
		return poller;
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_metrics"><font o="3561">度量</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3562">目前Spring Cloud Sleuth注册了与spans相关的简单指标。</font><font o="3563">它使用</font><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-recording-metrics"><font o="3563">Spring Boot的指标支持</font></a><font o="3563"> 
来计算接受和删除的数量spans。</font><font o="3564">每次发送到Zipkin时，接受的spans的数量将增加。</font><font o="3565">如果出现错误，那么删除的数字spans将会增加。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrations"><font o="3566">集成</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_runnable_and_callable"><font o="3567">可运行和可调用</font></h3>
<div class="paragraph">
<p><font o="3568">如果你在<code i="1884">Runnable</code>或<code i="1885">Callable</code>中包含你的逻辑，就可以将这些类包装在他们的Sleuth代表中。</font></p>
</div>
<div class="paragraph">
<p><font o="3569"><code i="1886">Runnable</code>的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Runnable runnable = new Runnable() {
	@Override
	public void run() {
		// do some work
	}

	@Override
	public String toString() {
		return "spanNameFromToStringMethod";
	}
};
// Manual `TraceRunnable` creation with explicit "calculateTax" Span name
Runnable traceRunnable = new TraceRunnable(tracer, spanNamer, runnable, "calculateTax");
// Wrapping `Runnable` with `Tracer`. The Span name will be taken either from the
// `@SpanName` annotation or from `toString` method
Runnable traceRunnableFromTracer = tracer.wrap(runnable);</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3570"><code i="1887">Callable</code>的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">Callable&lt;String&gt; callable = new Callable&lt;String&gt;() {
	@Override
	public String call() throws Exception {
		return someLogic();
	}

	@Override
	public String toString() {
		return "spanNameFromToStringMethod";
	}
};
// Manual `TraceCallable` creation with explicit "calculateTax" Span name
Callable&lt;String&gt; traceCallable = new TraceCallable&lt;&gt;(tracer, spanNamer, callable, "calculateTax");
// Wrapping `Callable` with `Tracer`. The Span name will be taken either from the
// `@SpanName` annotation or from `toString` method
Callable&lt;String&gt; traceCallableFromTracer = tracer.wrap(callable);</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3571">这样，您将确保为每次执行创建并关闭新的Span。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_hystrix">Hystrix</h3>
<div class="sect3">
<h4 id="_custom_concurrency_strategy"><font o="3573">自定义并发策略</font></h4>
<div class="paragraph">
<p><font o="3574">我们正在注册</font><a href="https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy"><code>HystrixConcurrencyStrategy</code></a><font o="3574">
将所有<code i="1888">Callable</code>实例包装到他们的Sleuth代表 -  <code i="1889">TraceCallable</code>中的定制。</font><font o="3575">该策略是启动或继续跨越，这取决于调用Hystrix命令之前跟踪是否已经进行的事实。</font><font o="3576">要禁用自定义Hystrix并发策略，将<code i="1890">spring.sleuth.hystrix.strategy.enabled</code>设置为<code i="1891">false</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_manual_command_setting"><font o="3577">手动命令设置</font></h4>
<div class="paragraph">
<p><font o="3578">假设您有以下<code i="1892">HystrixCommand</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">HystrixCommand&lt;String&gt; hystrixCommand = new HystrixCommand&lt;String&gt;(setter) {
	@Override
	protected String run() throws Exception {
		return someLogic();
	}
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3579">为了传递跟踪信息，您必须在<code i="1893">HystrixCommand</code>的<code i="1893">HystrixCommand</code>的Sleuth版本中包装相同的逻辑：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">TraceCommand&lt;String&gt; traceCommand = new TraceCommand&lt;String&gt;(tracer, traceKeys, setter) {
	@Override
	public String doRun() throws Exception {
		return someLogic();
	}
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rxjava"><font o="3580">RxJava</font></h3>
<div class="paragraph">
<p><font o="3581">我们正在注册</font><a href="https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook"><code>RxJavaSchedulersHook</code></a><font o="3581">
将所有<code i="1895">Action0</code>实例包装到他们的Sleuth代表 -  <code i="1896">TraceAction</code>中的定制。</font><font o="3582">钩子起动或继续一个跨度取决于跟踪在Action被安排之前是否已经进行的事实。</font><font o="3583">要禁用自定义RxJavaSchedulersHook，将<code i="1897">spring.sleuth.rxjava.schedulers.hook.enabled</code>设置为<code i="1898">false</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="3584">您可以定义线程名称的正则表达式列表，您不希望创建一个Span。</font><font o="3585">只需在<code i="1899">spring.sleuth.rxjava.schedulers.ignoredthreads</code>属性中提供逗号分隔的正则表达式列表。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_http_integration"><font o="3586">HTTP集成</font></h3>
<div class="paragraph">
<p><font o="3587">可以通过提供值等于<code i="1901">false</code>的<code i="1900">spring.sleuth.web.enabled</code>属性来禁用此部分的功能。</font></p>
</div>
<div class="sect3">
<h4 id="_http_filter"><font o="3588">HTTP过滤器</font></h4>
<div class="paragraph">
<p><font o="3589">通过<code i="1902">TraceFilter</code>所有采样的进入请求导致创建Span。</font><font o="3590">Span的名称是<code i="1903">http:</code> +发送请求的路径。</font><font o="3591">例如，如果请求已发送到<code i="1904">/foo/bar</code>，则该名称将为<code i="1905">http:/foo/bar</code>。</font><font o="3592">您可以通过<code i="1906">spring.sleuth.web.skipPattern</code>属性配置要跳过的URI。</font><font o="3593">如果您在类路径上有<code i="1907">ManagementServerProperties</code>，则其值<code i="1908">contextPath</code>将附加到提供的跳过模式。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_handlerinterceptor"><font o="3594">的HandlerInterceptor</font></h4>
<div class="paragraph">
<p><font o="3595">由于我们希望跨度名称是精确的，我们使用的<code i="1909">TraceHandlerInterceptor</code>包装现有的<code i="1910">HandlerInterceptor</code>，或直接添加到现有的<code i="1911">HandlerInterceptors</code>列表中。</font><font o="3596"><code i="1912">TraceHandlerInterceptor</code>向给定的<code i="1913">HttpServletRequest</code>添加了一个特殊请求属性。</font><font o="3597">如果<code i="1914">TraceFilter</code>没有看到此属性集，它将创建一个“后备”跨度，这是在服务器端创建的一个额外的跨度，以便在UI中正确显示跟踪。</font><font o="3598">看到最有可能意味着有一个缺失的仪器。</font><font o="3599">在这种情况下，请在Spring Cloud Sleuth中提出问题。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_async_servlet_support"><font o="3600">异步Servlet支持</font></h4>
<div class="paragraph">
<p><font o="3601">如果您的控制器返回<code i="1915">Callable</code>或<code i="1916">WebAsyncTask</code> Spring Cloud，Sleuth将继续现有的跨度，而不是创建一个新的跨度。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_client_integration"><font o="3602">HTTP客户端集成</font></h3>
<div class="sect3">
<h4 id="_synchronous_rest_template"><font o="3603">同步休息模板</font></h4>
<div class="paragraph">
<p><font o="3604">我们注入一个<code i="1917">RestTemplate</code>拦截器，确保所有跟踪信息都传递给请求。</font><font o="3605">每次呼叫都会创建一个新的Span。</font><font o="3606">收到回应后关闭。</font><font o="3607">为了阻止将<code i="1919">spring.sleuth.web.client.enabled</code>设置为<code i="1920">false</code>的同步<code i="1918">RestTemplate</code>功能。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3608">重要</font></div>
</td>
<td class="content"><font o="3609">
你必须注册<code i="1921">RestTemplate</code>作为一个bean，以便拦截器被注入。</font><font o="3610">如果您使用<code i="1923">new</code>关键字创建<code i="1922">RestTemplate</code>实例，那么该工具将不工作。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_asynchronous_rest_template"><font o="3611">异步休息模板</font></h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3612">重要</font></div>
</td>
<td class="content"><font o="3613">
一个<code i="1924">AsyncRestTemplate</code> bean的跟踪版本是为您开箱即用的。</font><font o="3614">如果你有自己的bean，你必须用<code i="1925">TraceAsyncRestTemplate</code>表示来包装它。</font><font o="3615">最好的解决方案是只定制<code i="1926">ClientHttpRequestFactory</code>和/或<code i="1927">AsyncClientHttpRequestFactory</code>。
</font><strong><font o="3616">如果您有自己的<code i="1928">AsyncRestTemplate</code>，并且您不要包装您的电话将不会被追踪</font></strong><font o="3616">。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3617">定制仪器设置为在发送和接收请求时创建和关闭跨度。</font><font o="3618">您可以通过注册您的bean来自定义<code i="1929">ClientHttpRequestFactory</code>和<code i="1930">AsyncClientHttpRequestFactory</code>。</font><font o="3619">记住使用跟踪兼容的实现（例如，不要忘记在<code i="1932">TraceAsyncListenableTaskExecutor</code>中包装<code i="1931">ThreadPoolTaskScheduler</code>）。</font><font o="3620">自定义请求工厂示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@EnableAutoConfiguration
@Configuration
public static class TestConfiguration {

	@Bean
	ClientHttpRequestFactory mySyncClientFactory() {
		return new MySyncClientHttpRequestFactory();
	}

	@Bean
	AsyncClientHttpRequestFactory myAsyncClientFactory() {
		return new MyAsyncClientHttpRequestFactory();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3621">将<code i="1933">AsyncRestTemplate</code>功能集<code i="1934">spring.sleuth.web.async.client.enabled</code>阻止为<code i="1935">false</code>。</font><font o="3622">禁用<code i="1936">TraceAsyncClientHttpRequestFactoryWrapper</code>设置<code i="1937">spring.sleuth.web.async.client.factory.enabled</code>设置为<code i="1938">false</code>。</font><font o="3623">如果您不想将所有<code i="1940">spring.sleuth.web.async.client.template.enabled</code> <code i="1941">false</code>的<code i="1939">AsyncRestClient</code>创建为<code i="1941">false</code>。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_feign">Feign</h3>
<div class="paragraph">
<p><font o="3625">默认情况下，Spring Cloud Sleuth通过<code i="1942">TraceFeignClientAutoConfiguration</code>提供与feign的集成。</font><font o="3626">您可以通过将<code i="1943">spring.sleuth.feign.enabled</code>设置为false来完全禁用它。</font><font o="3627">如果这样做，那么不会发生Feign相关的仪器。</font></p>
</div>
<div class="paragraph">
<p><font o="3628">Feign仪器的一部分是通过<code i="1944">FeignBeanPostProcessor</code>完成的。</font><font o="3629">您可以通过提供<code i="1945">spring.sleuth.feign.processor.enabled</code>等于<code i="1946">false</code>来禁用它。</font><font o="3630">如果你这样设置，那么Spring Cloud Sleuth不会调整你的任何自定义Feign组件。</font><font o="3631">然而，所有默认的工具仍然存在。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronous_communication"><font o="3632">异步通信</font></h3>
<div class="sect3">
<h4 id="__async_annotated_methods"><font o="3633">@Async注释方法</font></h4>
<div class="paragraph">
<p><font o="3634">在Spring Cloud Sleuth中，我们正在调用异步相关组件，以便跟踪信息在线程之间传递。</font><font o="3635">您可以通过将<code i="1947">spring.sleuth.async.enabled</code>的值设置为<code i="1948">false</code>来禁用此行为。</font></p>
</div>
<div class="paragraph">
<p><font o="3636">如果您使用<code i="1949">@Async</code>注释方法，那么我们将自动创建一个具有以下特征的新的Span：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3637">Span名称将是注释方法名称</font></p>
</li>
<li>
<p><font o="3638">Span将被该方法的类名称和方法名称标记</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="__scheduled_annotated_methods"><font o="3639">@Scheduled注释方法</font></h4>
<div class="paragraph">
<p><font o="3640">在Spring Cloud Sleuth中，我们正在调试计划的方法执行，以便跟踪信息在线程之间传递。</font><font o="3641">您可以通过将<code i="1950">spring.sleuth.scheduled.enabled</code>的值设置为<code i="1951">false</code>来禁用此行为。</font></p>
</div>
<div class="paragraph">
<p><font o="3642">如果您使用<code i="1952">@Scheduled</code>注释方法，那么我们将自动创建一个具有以下特征的新的Span：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3643">Span名称将是注释方法名称</font></p>
</li>
<li>
<p><font o="3644">Span将被该方法的类名称和方法名称标记</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3645">如果要跳过某些<code i="1953">@Scheduled</code>注释类的Span创建，您可以使用与<code i="1955">@Scheduled</code>注释类的完全限定名称匹配的正则表达式来设置<code i="1954">spring.sleuth.scheduled.skipPattern</code>。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3646">提示</font></div>
</td>
<td class="content"><font o="3647">
如果您一起使用<code i="1956">spring-cloud-sleuth-stream</code>和<code i="1957">spring-cloud-netflix-hystrix-stream</code>，将为每个Hystrix指标创建Span并发送到Zipkin。</font><font o="3648">这可能是恼人的。</font><font o="3649">您可以设置<code i="1958">spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask</code>
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_executor_executorservice_and_scheduledexecutorservice"><font o="3650">Executor，ExecutorService和ScheduledExecutorService</font></h4>
<div class="paragraph">
<p><font o="3651">我们提供<code i="1959">LazyTraceExecutor</code>，<code i="1960">TraceableExecutorService</code>和<code i="1961">TraceableScheduledExecutorService</code>。</font><font o="3652">每次提交，调用或调度新任务时，这些实现都将创建Spans。</font></p>
</div>
<div class="paragraph">
<p><font o="3653">在这里，您可以看到使用<code i="1963">CompletableFuture</code>使用<code i="1962">TraceableExecutorService</code>传递跟踪信息的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">CompletableFuture&lt;Long&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
	// perform some logic
	return 1_000_000L;
}, new TraceableExecutorService(executorService,
		// 'calculateTax' explicitly names the span - this param is optional
		tracer, traceKeys, spanNamer, "calculateTax"));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_messaging"><font o="3654">消息</font></h3>
<div class="paragraph">
<p><font o="3655">Spring Cloud Sleuth与</font><a href="http://projects.spring.io/spring-integration/"><font o="3655">Spring Integration</font></a><font o="3655">集成</font><font o="3655">。</font><font o="3656">它创建spans发布和订阅事件。</font><font o="3657">要禁用Spring Integration检测，请将​​<code i="1964">spring.sleuth.integration.enabled</code>设置为false。</font></p>
</div>
<div class="paragraph">
<p><font o="3658">您可以提供<code i="1965">spring.sleuth.integration.patterns</code>模式，以明确提供要包括的用于跟踪的通道的名称。</font><font o="3659">默认情况下，所有通道都包含在内。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3660">重要</font></div>
</td>
<td class="content"><font o="3661">
当使用<code i="1966">Executor</code>构建Spring Integration <code i="1967">IntegrationFlow</code>时，请记住使用</font><font o="3661"><code i="1968">Executor</code> </font><font o="3661">的</font><strong><font o="3661">未跟踪</font></strong><font o="3661">版本。</font><font o="3662">用<code i="1969">TraceableExecutorService</code>装饰Spring Integration执行者频道将导致spans被关闭。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_zuul_2">Zuul</h3>
<div class="paragraph">
<p><font o="3664">我们正在注册Zuul过滤器来传播跟踪信息（请求标头丰富了跟踪数据）。</font><font o="3665">要禁用Zuul支持，请将<code i="1970">spring.sleuth.zuul.enabled</code>属性设置为<code i="1971">false</code>。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_examples"><font o="3666">运行示例</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3667">您可以在</font><a href="https://run.pivotal.io/"><font o="3667">Pivotal Web Services</font></a><font o="3667">中找到部署的运行示例</font><font o="3667">。</font><font o="3668">在以下链接中查看它们：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docssleuth-zipkin-server.cfapps.io/"><font o="3669">Zipkin表示样品中的应用程序到顶部</font></a></p>
</li>
<li>
<p><a href="https://docsbrewing-zipkin-web.cfapps.io/"><font o="3670">Zipkin为啤酒厂在PWS</font></a><font o="3670">，其</font><a href="https://github.com/spring-cloud-samples/brewery"><font o="3670">Github代码</font></a></p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_spring_cloud_consul" class="sect0">Spring Cloud Consul</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><strong><font o="3672">Dalston.RELEASE</font></strong></p>
</div>
<div class="paragraph">
<p><font o="3673">该项目通过自动配置并绑定到Spring环境和其他Spring编程模型成语，为Spring Boot应用程序提供Consul集成。</font><font o="3674">通过几个简单的注释，您可以快速启用和配置应用程序中的常见模式，并使用基于Consul的组件构建大型分布式系统。</font><font o="3675">提供的模式包括服务发现，控制总线和配置。</font><font o="3676">智能路由（Zuul）和客户端负载平衡（Ribbon），断路器（Hystrix）通过与Spring Cloud Netflix的集成提供。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-install"><font o="3677">安装Consul</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3678">请参阅</font><a href="https://www.consul.io/intro/getting-started/install.html"><font o="3678">安装文档</font></a><font o="3678">获取有关如何安装Consul指令。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-agent">Consul Agent</h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3680">所有Spring Cloud Consul应用程序必须可以使用Consul Agent客户端。</font><font o="3681">默认情况下，代理客户端预计位于<code i="1972">localhost:8500</code>。</font><font o="3682">有关</font><font o="3682">如何启动代理客户端以及如何连接到Consul Agent服务器集群的</font><font o="3682">详细信息，请参阅</font><a href="https://consul.io/docs/agent/basics.html"><font o="3682">代理文档</font></a><font o="3682">。</font><font o="3683">对于开发，安装领事后，您可以使用以下命令启动Consul Agent：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">./src/main/bash/local_run_consul.sh</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3684">这将启动端口8500上的服务器模式的代理，其中ui可以在</font><a href="http://localhost:8500/" class="bare"><font o="3684">http：// localhost：8500上找到</font></a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-discovery"><font o="3685">服务发现与Consul</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3686">服务发现是基于微服务架构的关键原则之一。</font><font o="3687">尝试配置每个客户端或某种形式的约定可能非常困难，可以非常脆弱。</font><font o="3688">Consul通过</font><a href="https://www.consul.io/docs/agent/http.html"><font o="3688">HTTP API</font></a><font o="3688">和</font><a href="https://www.consul.io/docs/agent/dns.html"><font o="3688">DNS</font></a><font o="3688">提供服务发现服务</font><font o="3688">。</font><font o="3689">Spring Cloud Consul利用HTTP API进行服务注册和发现。</font><font o="3690">这不会阻止非Spring Cloud应用程序利用DNS界面。</font><font o="3691">Consul代理服务器在</font><font o="3691">通过</font><a href="https://www.consul.io/docs/internals/gossip.html"><font o="3691">八卦协议进行通信</font></a><font o="3691">的</font><a href="https://www.consul.io/docs/internals/architecture.html"><font o="3691">集群</font></a><font o="3691">中运行，</font><font o="3691">并使用</font><a href="https://www.consul.io/docs/internals/consensus.html"><font o="3691">Raft协议协议</font></a><font o="3691">。</font><a href="https://www.consul.io/docs/internals/gossip.html"><font></font></a><font></font><a href="https://www.consul.io/docs/internals/consensus.html"><font></font></a><font></font></p>
</div>
<div class="sect2">
<h3 id="_how_to_activate"><font o="3692">如何激活</font></h3>
<div class="paragraph">
<p><font o="3693">要激活Consul服务发现，请使用组<code i="1973">org.springframework.cloud</code>和artifact id <code i="1974">spring-cloud-starter-consul-discovery</code>的启动器。</font><font o="3694">有关</font><font o="3694">使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="3694">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="3694">Spring Cloud项目页面</font></a><font o="3694">。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_registering_with_consul"><font o="3695">注册Consul</font></h3>
<div class="paragraph">
<p><font o="3696">当客户端注册Consul时，它提供有关自身的元数据，如主机和端口，ID，名称和标签。</font><font o="3697">默认情况下会创建</font><font o="3697">一个HTTP </font><a href="https://www.consul.io/docs/agent/checks.html"><font o="3697">检查</font></a><font o="3697">，每隔10秒，Consul命中<code i="1975">/health</code>端点。</font><font o="3698">如果健康检查失败，则服务实例被标记为关键。</font></p>
</div>
<div class="paragraph">
<p><font o="3699">示例Consul客户端：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3700">（即完全正常的Spring Boot应用程序）。</font><font o="3701">如果Consul客户端位于<code i="1976">localhost:8500</code>以外的位置，则需要配置来定位客户端。</font><font o="3702">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3703">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      host: localhost
      port: 8500</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3704">警告</font></div>
</td>
<td class="content"><font o="3705">
如果您使用</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-consul-config"><font o="3705">Spring Cloud Consul Config</font></a><font o="3705">，上述值将需要放在<code i="1977">bootstrap.yml</code>而不是<code i="1978">application.yml</code>中。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3706">来自<code i="1979">Environment</code>的默认服务名称，实例ID和端口分别为<code i="1980">${spring.application.name}</code>，Spring上下文ID和<code i="1981">${server.port}</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="3707"><code i="1982">@EnableDiscoveryClient</code>将应用程序设为Consul“服务”（即注册自己）和“客户端”（即可以查询Consul查找其他服务）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_http_health_check"><font o="3708">HTTP健康检查</font></h3>
<div class="paragraph">
<p><font o="3709">Consul实例的运行状况检查默认为“/ health”，这是Spring Boot执行器应用程序中有用端点的默认位置。</font><font o="3710">如果您使用非默认上下文路径或servlet路径（例如<code i="1983">server.servletPath=/foo</code>）或管理端点路径（例如<code i="1984">management.context-path=/admin</code>），则需要更改这些，即使是执行器应用程序。</font><font o="3711">也可以配置Consul用于检查运行状况端点的间隔。</font><font o="3712">“10s”和“1m”分别表示10秒和1分钟。</font><font o="3713">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3714">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      discovery:
        healthCheckPath: ${management.context-path}/health
        healthCheckInterval: 15s</pre>
</div>
</div>
<div class="sect3">
<h4 id="_metadata_and_consul_tags"><font o="3715">元数据和Consul标签</font></h4>
<div class="paragraph">
<p><font o="3716">Consul尚未支持服务元数据。</font><font o="3717">Spring Cloud的<code i="1985">ServiceInstance</code>有一个<code i="1986">Map&lt;String, String&gt; metadata</code>字段。</font><font o="3718">Spring Cloud Consul使用Consul标签来近似元数据，直到Consul正式支持元数据。</font><font o="3719">使用<code i="1987">key=value</code>形式的标签将被分割并分别用作<code i="1988">Map</code>键和值。</font><font o="3720">标签没有相同的<code i="1989">=</code>符号，将被用作键和值两者。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3721">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      discovery:
        tags: foo=bar, baz</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3722">上述配置将导致具有<code i="1990">foo→bar</code>和<code i="1991">baz→baz</code>的映射。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_making_the_consul_instance_id_unique"><font o="3723">使Consul实例ID唯一</font></h4>
<div class="paragraph">
<p><font o="3724">默认情况下，一个领事实体注册了一个等于其Spring应用程序上下文ID的ID。</font><font o="3725">默认情况下，Spring应用程序上下文ID为<code i="1992">${spring.application.name}:comma,separated,profiles:${server.port}</code>。</font><font o="3726">在大多数情况下，这将允许一个服务的多个实例在一台机器上运行。</font><font o="3727">如果需要进一步的唯一性，使用Spring Cloud，您可以通过在<code i="1993">spring.cloud.consul.discovery.instanceId</code>中提供唯一的标识来覆盖此。</font><font o="3728">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3729">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      discovery:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3730">使用这个元数据和在localhost上部署的多个服务实例，随机值将在那里进行，以使实例是唯一的。</font><font o="3731">在Cloudfoundry中，<code i="1994">vcap.application.instance_id</code>将在Spring Boot应用程序中自动填充，因此不需要随机值。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_discoveryclient"><font o="3732">使用DiscoveryClient</font></h3>
<div class="paragraph">
<p><font o="3733">Spring Cloud支持</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign"><font o="3733">Feign</font></a><font o="3733">（REST客户端构建器），</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon"><font o="3733">Spring <code i="1995">RestTemplate</code></font></a><font o="3733">使用逻辑服务名称而不是物理URL。</font></p>
</div>
<div class="paragraph">
<p><font o="3734">您还可以使用<code i="1996">org.springframework.cloud.client.discovery.DiscoveryClient</code>，它为Netflix不特定的发现客户端提供了一个简单的API，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-config"><font o="3735">具有Consul的分布式配置</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3736">Consul提供了一个</font><font o="3736">用于存储配置和其他元数据</font><font o="3736">的</font><a href="https://consul.io/docs/agent/http/kv.html"><font o="3736">键/值存储</font></a><font o="3736">。</font><font o="3737">Spring Cloud Consul Config是</font><a href="https://github.com/spring-cloud/spring-cloud-config"><font o="3737">Config Server和Client</font></a><font o="3737">的替代方案</font><font o="3737">。</font><font o="3738">在特殊的“引导”阶段，配置被加载到Spring环境中。</font><font o="3739">默认情况下，配置存储在<code i="1997">/config</code>文件夹中。</font><font o="3740">基于应用程序的名称和模拟解析属性的Spring Cloud Config顺序的活动配置文件创建多个<code i="1998">PropertySource</code>实例。</font><font o="3741">例如，名为“testApp”的应用程序和“dev”配置文件将创建以下属性源：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">config/testApp,dev/
config/testApp/
config/application,dev/
config/application/</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3742">最具体的物业来源位于顶部，底部最不具体。</font><font o="3743">Properties是<code i="1999">config/application</code>文件夹适用于使用consul进行配置的所有应用程序。</font><font o="3744"><code i="2000">config/testApp</code>文件夹中的Properties仅适用于名为“testApp”的服务实例。</font></p>
</div>
<div class="paragraph">
<p><font o="3745">配置当前在应用程序启动时被读取。</font><font o="3746">发送HTTP POST到<code i="2001">/refresh</code>将导致配置被重新加载。</font><font o="3747">观看关键价值商店（Consul支持））目前不可能，但将来将是此项目的补充。</font></p>
</div>
<div class="sect2">
<h3 id="_how_to_activate_2"><font o="3748">如何激活</font></h3>
<div class="paragraph">
<p><font o="3749">要开始使用Consul配置，请使用组<code i="2002">org.springframework.cloud</code>和artifact id <code i="2003">spring-cloud-starter-consul-config</code>的启动器。</font><font o="3750">有关</font><font o="3750">使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="3750">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="3750">Spring Cloud项目页面</font></a><font o="3750">。</font></p>
</div>
<div class="paragraph">
<p><font o="3751">这将启用自动配置，将设置Spring Cloud Consul配置。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing"><font o="3752">定制</font></h3>
<div class="paragraph">
<p><font o="3753">Consul可以使用以下属性定制配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3754">bootstrap.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      config:
        enabled: true
        prefix: configuration
        defaultContext: apps
        profileSeparator: '::'</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3755"><code i="2004">enabled</code>将此值设置为“false”禁用Consul配置</font></p>
</li>
<li>
<p><font o="3756"><code i="2005">prefix</code>设置配置值的基本文件夹</font></p>
</li>
<li>
<p><font o="3757"><code i="2006">defaultContext</code>设置所有应用程序使用的文件夹名称</font></p>
</li>
<li>
<p><font o="3758"><code i="2007">profileSeparator</code>设置用于使用配置文件在属性源中分隔配置文件名称的分隔符的值</font></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-config-watch"><font o="3759">配置观察</font></h3>
<div class="paragraph">
<p><font o="3760">Consul配置观察功能可以利用领事</font><a href="https://www.consul.io/docs/agent/watches.html#keyprefix"><font o="3760">看守钥匙前缀</font></a><font o="3760">的能力</font><font o="3760">。</font><font o="3761">Config Watch会阻止Consul HTTP API调用，以确定当前应用程序是否有任何相关配置数据发生更改。</font><font o="3762">如果有新的配置数据，则会发布刷新事件。</font><font o="3763">这相当于调用<code i="2008">/refresh</code>执行器端点。</font></p>
</div>
<div class="paragraph">
<p><font o="3764">要更改Config Watch调用的频率change <code i="2009">spring.cloud.consul.config.watch.delay</code>。</font><font o="3765">默认值为1000，以毫秒为单位。</font></p>
</div>
<div class="paragraph">
<p><font o="3766">禁用配置观察集<code i="2010">spring.cloud.consul.config.watch.enabled=false</code>。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-config-format"><font o="3767">YAML或Properties配置</font></h3>
<div class="paragraph">
<p><font o="3768">与单个键/值对相反，可以更方便地将YBL或Properties格式的属性块存储起来。</font><font o="3769">将<code i="2011">spring.cloud.consul.config.format</code>属性设置为<code i="2012">YAML</code>或<code i="2013">PROPERTIES</code>。</font><font o="3770">例如使用YAML：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3771">bootstrap.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      config:
        format: YAML</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3772">YAML必须在合适的<code i="2014">data</code>键中设置。</font><font o="3773">使用键上面的默认值将如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">config/testApp,dev/data
config/testApp/data
config/application,dev/data
config/application/data</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3774">您可以将YAML文档存储在上述任何键中。</font></p>
</div>
<div class="paragraph">
<p><font o="3775">您可以使用<code i="2015">spring.cloud.consul.config.data-key</code>更改数据密钥。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-config-git2consul"><font o="3776">git2consul与配置</font></h3>
<div class="paragraph">
<p><font o="3777">git2consul是一个Consul社区项目，将文件从git存储库加载到各个密钥到Consul。</font><font o="3778">默认情况下，密钥的名称是文件的名称。</font><font o="3779">YAML和Properties文件分别支持<code i="2016">.yml</code>和<code i="2017">.properties</code>的文件扩展名。</font><font o="3780">将<code i="2018">spring.cloud.consul.config.format</code>属性设置为<code i="2019">FILES</code>。</font><font o="3781">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3782">bootstrap.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    consul:
      config:
        format: FILES</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3783">给定<code i="2020">/config</code>中的以下密钥，<code i="2021">development</code>配置文件和应用程序名称为<code i="2022">foo</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">.gitignore
application.yml
bar.properties
foo-development.properties
foo-production.yml
foo.properties
master.ref</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3784">将创建以下属性来源：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">config/foo-development.properties
config/foo.properties
config/application.yml</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3785">每个键的值需要是一个格式正确的YAML或Properties文件。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-failfast"><font o="3786">快速失败</font></h3>
<div class="paragraph">
<p><font o="3787">在某些情况下（如本地开发或某些测试场景）可能会方便，如果不能配置领事，则不会失败。</font><font o="3788">在<code i="2024">bootstrap.yml</code>中设置<code i="2023">spring.cloud.consul.config.failFast=false</code>将导致配置模块记录一个警告而不是抛出异常。</font><font o="3789">这将允许应用程序继续正常启动。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-retry"><font o="3790">Consul重试</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3791">如果您希望您的应用程序启动时可能偶尔无法使用代理商，则可以要求您在发生故障后继续尝试。</font><font o="3792">您需要在您的类路径中添加<code i="2025">spring-retry</code>和<code i="2026">spring-boot-starter-aop</code>。</font><font o="3793">默认行为是重试6次，初始退避间隔为1000ms，指数乘数为1.1，用于后续退避。</font><font o="3794">您可以使用<code i="2027">spring.cloud.consul.retry.*</code>配置属性配置这些属性（和其他）。</font><font o="3795">这适用于Spring Cloud Consul配置和发现注册。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3796">提示</font></div>
</td>
<td class="content"><font o="3797">
要完全控制重试，请使用id为“consulRetryInterceptor”添加<code i="2029">RetryOperationsInterceptor</code>类型的<code i="2028">@Bean</code>。</font><font o="3798">Spring重试有一个<code i="2030">RetryInterceptorBuilder</code>可以轻松创建一个。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-bus"><font o="3799">Spring Cloud Bus与Consul</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_how_to_activate_3"><font o="3800">如何激活</font></h3>
<div class="paragraph">
<p><font o="3801">要开始使用Consul总线，使用组<code i="2031">org.springframework.cloud</code>和工件id <code i="2032">spring-cloud-starter-consul-bus</code>的起动器。</font><font o="3802">有关</font><font o="3802">使用当前的Spring Cloud发布列表设置构建系统的详细信息，</font><font o="3802">请参阅</font><a href="http://projects.spring.io/spring-cloud/"><font o="3802">Spring Cloud项目页面</font></a><font o="3802">。</font></p>
</div>
<div class="paragraph">
<p><font o="3803">有关</font><font o="3803">可用的执行机构端点以及如何发送自定义消息，</font><font o="3803">请参阅</font><a href="https://cloud.spring.io/spring-cloud-bus/"><font o="3803">Spring Cloud Bus</font></a><font o="3803">文档。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-hystrix"><font o="3804">断路器与Hystrix</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3805">应用程序可以使用Spring Cloud Netflix项目提供的Hystrix断路器将这个启动器包含在项目pom.xml：<code i="2033">spring-cloud-starter-hystrix</code>中。</font><font o="3806">Hystrix不依赖于Netflix Discovery Client。</font><font o="3807"><code i="2034">@EnableHystrix</code>注释应放置在配置类（通常是主类）上。</font><font o="3808">那么方法可以用<code i="2035">@HystrixCommand</code>注释来被断路器保护。</font><font o="3809">有关</font><font o="3809">详细信息，</font><font o="3809">请参阅</font><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients"><font o="3809">文档</font></a><font o="3809">。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul-turbine"><font o="3810">使用Turbine和Consul Hystrix指标聚合</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3811">Turbine（由Spring Cloud Netflix项目提供））聚合多个实例Hystrix指标流，因此仪表板可以显示聚合视图。</font><font o="3812">Turbine使用<code i="2036">DiscoveryClient</code>接口查找相关实例。</font><font o="3813">要将Turbine与Spring Cloud Consul结合使用，请按以下示例配置Turbine应用程序：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3814">的pom.xml</font></div>
<div class="content">
<pre class="notranslate">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-netflix-turbine&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3815">请注意，Turbine依赖不是起始者。</font><font o="3816">涡轮启动器包括对Netflix Eureka的支持。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3817">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring.application.name: turbine
applications: consulhystrixclient
turbine:
  aggregator:
    clusterConfig: ${applications}
  appConfig: ${applications}</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3818"><code i="2037">clusterConfig</code>和<code i="2038">appConfig</code>部分必须匹配，因此将逗号分隔的服务标识列表放在单独的配置属性中是有用的。</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3819">Turbine。java的</font></div>
<div class="content">
<pre class="notranslate">@EnableTurbine
@EnableDiscoveryClient
@SpringBootApplication
public class Turbine {
    public static void main(String[] args) {
        SpringApplication.run(DemoturbinecommonsApplication.class, args);
    }
}</pre>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_zookeeper" class="sect0">Spring Cloud Zookeeper</h1>
<div class="openblock partintro">
<div class="content"><font o="3821">
该项目通过自动配置并绑定到Spring环境和其他Spring编程模型成语，为Spring Boot应用程序提供Zookeeper集成。</font><font o="3822">通过几个简单的注释，您可以快速启用和配置应用程序中的常见模式，并使用基于Zookeeper的组件构建大型分布式系统。</font><font o="3823">提供的模式包括服务发现和配置。</font><font o="3824">智能路由（Zuul）和客户端负载平衡（Ribbon），断路器（Hystrix）通过与Spring Cloud Netflix的集成提供。
</font></div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-install"><font o="3825">安装Zookeeper</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3826">请参阅</font><a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html"><font o="3826">安装文档</font></a><font o="3826">获取有关如何安装Zookeeper指令。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-discovery"><font o="3827">服务发现与Zookeeper</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3828">服务发现是基于微服务架构的关键原则之一。</font><font o="3829">尝试配置每个客户端或某种形式的约定可能非常困难，可以非常脆弱。</font><a href="https://curator.apache.org/"><font o="3830">策展人</font></a><font o="3830">（一个用于Zookeeper的java库）通过</font><a href="https://curator.apache.org/curator-x-discovery/"><font o="3830">服务发现扩展</font></a><font o="3830">提供服务发现服务</font><font o="3830">。</font><font o="3831">Spring Cloud Zookeeper利用此扩展功能进行服务注册和发现。</font></p>
</div>
<div class="sect2">
<h3 id="_how_to_activate_4"><font o="3832">如何激活</font></h3>
<div class="paragraph">
<p><font o="3833">包括对<code i="2039">org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>的依赖将启用将设置Spring Cloud Zookeeper发现的自动配置。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3834">注意</font></div>
</td>
<td class="content"><font o="3835">
您仍然需要包含<code i="2040">org.springframework.boot:spring-boot-starter-web</code>的网页功能。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_registering_with_zookeeper"><font o="3836">注册Zookeeper</font></h3>
<div class="paragraph">
<p><font o="3837">当客户端注册Zookeeper时，它提供有关自身的元数据，如主机和端口，ID和名称。</font></p>
</div>
<div class="paragraph">
<p><font o="3838">示例Zookeeper客户端：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3839">（即完全正常的Spring Boot应用程序）。</font><font o="3840">如果Zookeeper位于<code i="2041">localhost:2181</code>以外的地方，则需要配置来定位服务器。</font><font o="3841">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3842">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    zookeeper:
      connect-string: localhost:2181</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3843">警告</font></div>
</td>
<td class="content"><font o="3844">
如果您使用</font><a href="https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-zookeeper-config"><font o="3844">Spring Cloud Zookeeper配置</font></a><font o="3844">，上述值将需要放置在<code i="2042">bootstrap.yml</code>而不是<code i="2043">application.yml</code>中。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="3845">来自<code i="2044">Environment</code>的默认服务名称，实例ID和端口分别为<code i="2045">${spring.application.name}</code>，Spring上下文ID和<code i="2046">${server.port}</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="3846"><code i="2047">@EnableDiscoveryClient</code>将应用程序同时进入Zookeeper“服务”（即注册自己）和“客户端”（即可以查询Zookeeper查找其他服务）。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_discoveryclient_2"><font o="3847">使用DiscoveryClient</font></h3>
<div class="paragraph">
<p><font o="3848">Spring Cloud支持</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign"><font o="3848">Feign</font></a><font o="3848">（REST客户端构建器），还支持</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon"><font o="3848">Spring <code i="2048">RestTemplate</code></font></a><font o="3848">使用逻辑服务名称而不是物理URL。</font></p>
</div>
<div class="paragraph">
<p><font o="3849">您还可以使用<code i="2049">org.springframework.cloud.client.discovery.DiscoveryClient</code>，它为Netflix不具体的发现客户端提供简单的API，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri().toString();
    }
    return null;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-netflix"><font o="3850">使用Spring Cloud Zookeeper与Spring Cloud Netflix组件</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3851">Spring Cloud Netflix提供有用的工具，无论使用哪种<code i="2050">DiscoveryClient</code>实现。</font><font o="3852">Feign，Turbine，Ribbon和Zuul均与Spring Cloud Zookeeper合作。</font></p>
</div>
<div class="sect2">
<h3 id="_ribbon_with_zookeeper"><font o="3853">Ribbon与Zookeeper</font></h3>
<div class="paragraph">
<p><font o="3854">Spring Cloud Zookeeper提供Ribbon的<code i="2051">ServerList</code>的实现。</font><font o="3855">当使用<code i="2052">spring-cloud-starter-zookeeper-discovery</code>时，Ribbon默认情况下自动配置为使用<code i="2053">ZookeeperServerList</code>。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-service-registry"><font o="3856">Spring Cloud Zookeeper和服务注册表</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3857">Spring Cloud Zookeeper实现<code i="2054">ServiceRegistry</code>接口，允许开发人员以编程方式注册任意服务。</font></p>
</div>
<div class="paragraph">
<p><font o="3858"><code i="2055">ServiceInstanceRegistration</code>类提供<code i="2056">builder()</code>方法来创建可以由<code i="2058">ServiceRegistry</code>使用的<code i="2057">Registration</code>对象。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Autowired
private ZookeeperServiceRegistry serviceRegistry;

public void registerThings() {
    ZookeeperRegistration registration = ServiceInstanceRegistration.builder()
            .defaultUriSpec()
            .address("anyUrl")
            .port(10)
            .name("/a/b/c/d/anotherservice")
            .build();
    this.serviceRegistry.register(registration);
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_instance_status"><font o="3859">实例状态</font></h3>
<div class="paragraph">
<p><font o="3860">Netflix Eureka支持在服务器上注册的实例是<code i="2059">OUT_OF_SERVICE</code>，而不是作为活动服务实例返回。</font><font o="3861">这对于诸如蓝色/绿色部署之类的行为非常有用。</font><font o="3862">策展人服务发现配方不支持此行为。</font><font o="3863">利用灵活的有效载荷，让Spring Cloud Zookeeper通过更新一些特定的元数据，然后对Ribbon <code i="2061">ZookeeperServerList</code>中的元数据进行过滤来实现<code i="2060">OUT_OF_SERVICE</code>。</font><font o="3864"><code i="2062">ZookeeperServerList</code>过滤出不等于<code i="2063">UP</code>的所有非空实例状态。</font><font o="3865">如果实例状态字段为空，则向后兼容性被认为是<code i="2064">UP</code>。</font><font o="3866">将实例POST <code i="2065">OUT_OF_SERVICE</code>的状态更改为<code i="2066">ServiceRegistry</code>实例状态执行器端点。</font></p>
</div>
<div class="literalblock">
<div class="content">
<pre class="notranslate">----
$ echo -n OUT_OF_SERVICE | http POST http://localhost:8081/service-registry/instance-status
----</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre class="notranslate">NOTE: The above example uses the `http` command from https://httpie.org</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-dependencies"><font o="3867">Zookeeper依赖关系</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_using_the_zookeeper_dependencies"><font o="3868">使用Zookeeper依赖关系</font></h3>
<div class="paragraph">
<p><font o="3869">Spring Cloud Zookeeper可以让您提供应用程序的依赖关系作为属性。</font><font o="3870">作为依赖关系，您可以了解Zookeeper中注册的其他应用程序，您可以通过</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign"><font o="3870">Feign</font></a><font o="3870">（REST客户端构建器）以及</font><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon"><font o="3870">Spring <code i="2067">RestTemplate</code></font></a><font o="3870">呼叫</font><font o="3870">。</font></p>
</div>
<div class="paragraph">
<p><font o="3871">您还可以从Zookeeper依赖关系观察者功能中受益，这些功能可让您控制和监视依赖关系的状态，并决定如何处理。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_activate_zookeeper_dependencies"><font o="3872">如何激活Zookeeper依赖关系</font></h3>
<div class="ulist">
<ul>
<li>
<p><font o="3873">包括对<code i="2068">org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>的依赖将启用将自动配置Spring Cloud Zookeeper依赖关系的自动配置。</font></p>
</li>
<li>
<p><font o="3874">如果您必须正确设置<code i="2069">spring.cloud.zookeeper.dependencies</code>部分 - 请查看后续部分以获取更多详细信息，然后该功能处于活动状态</font></p>
</li>
<li>
<p><font o="3875">即使您在属性中提供依赖关系，也可以关闭依赖关系。</font><font o="3876">只需将属性<code i="2070">spring.cloud.zookeeper.dependency.enabled</code>设置为false（默认为<code i="2071">true</code>）。</font></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_zookeeper_dependencies"><font o="3877">设置Zookeeper依赖关系</font></h3>
<div class="paragraph">
<p><font o="3878">我们来仔细看一下依赖关系表示的例子：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3879">application.yml</font></div>
<div class="content">
<pre class="notranslate">spring.application.name: yourServiceName
spring.cloud.zookeeper:
  dependencies:
    newsletter:
      path: /path/where/newsletter/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.newsletter.$version+json
      version: v1
      headers:
        header1:
            - value1
        header2:
            - value2
      required: false
      stubs: org.springframework:foo:stubs
    mailing:
      path: /path/where/mailing/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.mailing.$version+json
      version: v1
      required: true</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3880">现在让我们一个接一个地遍历依赖的每个部分。</font><font o="3881">根属性名称为<code i="2072">spring.cloud.zookeeper.dependencies</code>。</font></p>
</div>
<div class="sect3">
<h4 id="_aliases"><font o="3882">别名</font></h4>
<div class="paragraph">
<p><font o="3883">在根属性下面，由于Ribbon的限制，必须通过别名来表示每个依赖关系（应用程序ID必须放在URL中，因此您不能传递任何复杂的路径，如/ foo / bar / name ）。</font><font o="3884">别名将是您将使用的名称，而不是<code i="2073">DiscoveryClient</code>，<code i="2074">Feign</code>或<code i="2075">RestTemplate</code>的serviceId。</font></p>
</div>
<div class="paragraph">
<p><font o="3885">在上述例子中，别名是<code i="2076">newsletter</code>和<code i="2077">mailing</code>。</font><font o="3886">使用<code i="2078">newsletter</code>的Feign使用示例为：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@FeignClient("newsletter")
public interface NewsletterService {
        @RequestMapping(method = RequestMethod.GET, value = "/newsletter")
        String getNewsletters();
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_path"><font o="3887">路径</font></h4>
<div class="paragraph">
<p><font o="3888">代表<code i="2079">path</code> yaml属性。</font></p>
</div>
<div class="paragraph">
<p><font o="3889">Path是根据Zookeeper注册依赖关系的路径。</font><font o="3890">像Ribbon之前提交的URL，因此这个路径不符合其要求。</font><font o="3891">这就是为什么Spring Cloud Zookeeper将别名映射到正确的路径。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_load_balancer_type"><font o="3892">负载平衡器类型</font></h4>
<div class="paragraph">
<p><font o="3893">代表<code i="2080">loadBalancerType</code> yaml属性。</font></p>
</div>
<div class="paragraph">
<p><font o="3894">如果您知道在调用此特定依赖关系时必须应用什么样的负载平衡策略，那么您可以在yaml文件中提供它，并将自动应用。</font><font o="3895">您可以选择以下负载平衡策略之一</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3896">STICKY  - 一旦选择了该实例将始终被调用</font></p>
</li>
<li>
<p><font o="3897">随机 - 随机选择一个实例</font></p>
</li>
<li>
<p><font o="3898">ROUND_ROBIN  - 一遍又一遍地迭代实例</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_content_type_template_and_version"><font o="3899">Content-Type模板和版本</font></h4>
<div class="paragraph">
<p><font o="3900">代表<code i="2081">contentTypeTemplate</code>和<code i="2082">version</code> yaml属性。</font></p>
</div>
<div class="paragraph">
<p><font o="3901">如果您通过<code i="2083">Content-Type</code>标题版本您的api，那么您不想将此标头添加到您的每个请求中。</font><font o="3902">另外如果你想调用一个新版本的API，你不想漫游你的代码，以增加API版本。</font><font o="3903">这就是为什么您可以提供<code i="2084">contentTypeTemplate</code>特殊<code i="2085">$version</code>占位符的原因。</font><font o="3904">该占位符将由<code i="2086">version</code> yaml属性的值填充。</font><font o="3905">我们来看一个例子。</font></p>
</div>
<div class="paragraph">
<p><font o="3906">拥有以下<code i="2087">contentTypeTemplate</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">application/vnd.newsletter.$version+json</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3907">和以下<code i="2088">version</code>：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">v1</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3908">将导致为每个请求设置<code i="2089">Content-Type</code>标题：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">application/vnd.newsletter.v1+json</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_default_headers"><font o="3909">默认标题</font></h4>
<div class="paragraph">
<p><font o="3910">由yaml代表<code i="2090">headers</code>映射</font></p>
</div>
<div class="paragraph">
<p><font o="3911">有时每次调用依赖关系都需要设置一些默认标头。</font><font o="3912">为了不在代码中这样做，您可以在yaml文件中设置它们。</font><font o="3913">拥有以下<code i="2091">headers</code>部分：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">headers:
    Accept:
        - text/html
        - application/xhtml+xml
    Cache-Control:
        - no-cache</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3914">结果在您的HTTP请求中添加适当的值列表的<code i="2092">Accept</code>和<code i="2093">Cache-Control</code>标头。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_obligatory_dependencies"><font o="3915">强制依赖</font></h4>
<div class="paragraph">
<p><font o="3916">在yaml中由<code i="2094">required</code>属性表示</font></p>
</div>
<div class="paragraph">
<p><font o="3917">如果您的一个依赖关系在您的应用程序启动时需要启动并运行，则可以在yaml文件中设置<code i="2095">required: true</code>属性。</font></p>
</div>
<div class="paragraph">
<p><font o="3918">如果您的应用程序无法在引导期间本地化所需的依赖关系，则会抛出异常，并且Spring上下文将无法设置。</font><font o="3919">换句话说，如果Zookeeper中没有注册所需的依赖关系，则您的应用程序将无法启动。</font></p>
</div>
<div class="paragraph">
<p><font o="3920">您可以在以下部分阅读有关Spring Cloud Zookeeper存在检查器的更多信息。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_stubs"><font o="3921">存根</font></h4>
<div class="paragraph">
<p><font o="3922">您可以为包含依赖关系的存根的JAR提供冒号分隔路径。</font><font o="3923">例</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>stubs: org.springframework:foo:stubs</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3924">意味着对于特定的依赖关系可以在下面找到：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3925">groupId：<code i="2096">org.springframework</code></font></p>
</li>
<li>
<p><font o="3926">artifactId：<code i="2097">foo</code></font></p>
</li>
<li>
<p><font o="3927">分类器：<code i="2098">stubs</code>  - 这是默认值</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3928">这实际上等于</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>stubs: org.springframework:foo</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3929">因为<code i="2099">stubs</code>是默认分类器。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_spring_cloud_zookeeper_dependencies"><font o="3930">配置Spring Cloud Zookeeper依赖关系</font></h3>
<div class="paragraph">
<p><font o="3931">有一些属性可以设置为启用/禁用Zookeeper依赖关系功能的部分。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3932"><code i="2100">spring.cloud.zookeeper.dependencies</code>  - 如果您不设置此属性，则不会从Zookeeper依赖关系中受益</font></p>
</li>
<li>
<p><font o="3933"><code i="2101">spring.cloud.zookeeper.dependency.ribbon.enabled</code>（默认情况下启用） -  Ribbon需要显式的全局配置或特定的依赖关系。</font><font o="3934">通过打开此属性，运行时负载平衡策略解决是可能的，您可以从Zookeeper依赖关系的<code i="2102">loadBalancerType</code>部分获利。</font><font o="3935">需要此属性的配置具有<code i="2103">LoadBalancerClient</code>的实现，委托给下一个子弹中的<code i="2104">ILoadBalancer</code></font></p>
</li>
<li>
<p><font o="3936"><code i="2105">spring.cloud.zookeeper.dependency.ribbon.loadbalancer</code>（默认情况下启用） - 感谢这个属性，自定义<code i="2106">ILoadBalancer</code>知道传递给Ribbon的URI部分实际上可能是必须被解析为Zookeeper。</font><font o="3937">没有此属性，您将无法在嵌套路径下注册应用程序。</font></p>
</li>
<li>
<p><font o="3938"><code i="2107">spring.cloud.zookeeper.dependency.headers.enabled</code>（默认情况下启用） - 此属性注册这样的一个<code i="2108">RibbonClient</code>，它会自动附加适当的头文件和内容类型，其中包含依赖关系配置中显示的版本。</font><font o="3939">没有这两个参数的设置将不会运行。</font></p>
</li>
<li>
<p><font o="3940"><code i="2109">spring.cloud.zookeeper.dependency.resttemplate.enabled</code>（默认情况下启用） - 启用时将修改<code i="2110">@LoadBalanced</code>注释的<code i="2111">RestTemplate</code>的请求标头，以便它通过依赖关系配置中设置的版本的标题和内容类型。</font><font o="3941">Wihtout这两个参数的设置将无法运行。</font></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-dependency-watcher"><font o="3942">Spring Cloud Zookeeper依赖关系观察者</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3943">依赖关系观察器机制允许您将侦听器注册到依赖关系中。</font><font o="3944">功能实际上是<code i="2112">Observator</code>模式的实现。</font><font o="3945">当依赖关系改变其状态（UP或DOWN）时，可以应用一些自定义逻辑。</font></p>
</div>
<div class="sect2">
<h3 id="_how_to_activate_5"><font o="3946">如何激活</font></h3>
<div class="paragraph">
<p><font o="3947">Spring Cloud Zookeeper依赖关系功能需要启用从依赖关系观察器机制中获利。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_registering_a_listener"><font o="3948">注册听众</font></h3>
<div class="paragraph">
<p><font o="3949">为了注册一个监听器，你必须实现一个接口<code i="2113">org.springframework.cloud.zookeeper.discovery.watcher.DependencyWatcherListener</code>，并将其注册为一个bean。</font><font o="3950">该界面为您提供了一种方法：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">    void stateChanged(String dependencyName, DependencyState newState);</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3951">如果要为特定的依赖关系注册一个侦听器，那么<code i="2114">dependencyName</code>将是具体实现的鉴别器。</font><font o="3952"><code i="2115">newState</code>将提供您的依赖关系是否已更改为<code i="2116">CONNECTED</code>或<code i="2117">DISCONNECTED</code>的信息。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_presence_checker"><font o="3953">存在检查</font></h3>
<div class="paragraph">
<p><font o="3954">绑定与依赖关系观察器是称为存在检查器的功能。</font><font o="3955">它允许您在启动应用程序时提供自定义行为，以根据您的依赖关系的状态作出反应。</font></p>
</div>
<div class="paragraph">
<p><font o="3956">抽象<code i="2118">org.springframework.cloud.zookeeper.discovery.watcher.presence.DependencyPresenceOnStartupVerifier</code>类的默认实现是<code i="2119">org.springframework.cloud.zookeeper.discovery.watcher.presence.DefaultDependencyPresenceOnStartupVerifier</code>，它以以下方式工作。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3957">如果依赖关系标记为我们<code i="2120">required</code>，并且不在Zookeeper中，则在引导时，您的应用程序将抛出异​​常并关闭</font></p>
</li>
<li>
<p><font o="3958">如果依赖关系不是<code i="2121">required</code>，<code i="2122">org.springframework.cloud.zookeeper.discovery.watcher.presence.LogMissingDependencyChecker</code>将在<code i="2123">WARN</code>级别上记录该应用程序</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3959">功能可以被覆盖，因为只有当没有<code i="2125">DependencyPresenceOnStartupVerifier</code>的bean时才会注册<code i="2124">DefaultDependencyPresenceOnStartupVerifier</code>。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper-config"><font o="3960">分布式配置与Zookeeper</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="3961">Zookeeper提供了一个</font><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace"><font o="3961">分层命名空间</font></a><font o="3961">，允许客户端存储任意数据，如配置数据。</font><font o="3962">Spring Cloud Zookeeper Config是</font><a href="https://github.com/spring-cloud/spring-cloud-config"><font o="3962">Config Server和Client</font></a><font o="3962">的替代方案</font><font o="3962">。</font><font o="3963">在特殊的“引导”阶段，配置被加载到Spring环境中。</font><font o="3964">默认情况下，配置存储在<code i="2126">/config</code>命名空间中。</font><font o="3965">根据应用程序的名称和模拟解析属性的Spring Cloud Config顺序的活动配置文件，创建多个<code i="2127">PropertySource</code>实例。</font><font o="3966">例如，名为“testApp”的应用程序和“dev”配置文件将创建以下属性源：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">config/testApp,dev
config/testApp
config/application,dev
config/application</pre>
</div>
</div>
<div class="paragraph">
<p><font o="3967">最具体的物业来源位于顶部，底部最不具体。</font><font o="3968">Properties是<code i="2128">config/application</code>命名空间适用于使用zookeeper进行配置的所有应用程序。</font><font o="3969"><code i="2129">config/testApp</code>命名空间中的Properties仅适用于名为“testApp”的服务实例。</font></p>
</div>
<div class="paragraph">
<p><font o="3970">配置当前在应用程序启动时被读取。</font><font o="3971">发送HTTP POST到<code i="2130">/refresh</code>将导致重新加载配置。</font><font o="3972">观看配置命名空间（Zookeeper支持））目前尚未实现，但将来将会添加到此项目中。</font></p>
</div>
<div class="sect2">
<h3 id="_how_to_activate_6"><font o="3973">如何激活</font></h3>
<div class="paragraph">
<p><font o="3974">包括对<code i="2131">org.springframework.cloud:spring-cloud-starter-zookeeper-config</code>的依赖将启用将配置Spring Cloud Zookeeper配置的自动配置。</font></p>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_2"><font o="3975">定制</font></h3>
<div class="paragraph">
<p><font o="3976">Zookeeper可以使用以下属性自定义配置：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3977">bootstrap.yml</font></div>
<div class="content">
<pre class="notranslate">spring:
  cloud:
    zookeeper:
      config:
        enabled: true
        root: configuration
        defaultContext: apps
        profileSeparator: '::'</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="3978"><code i="2132">enabled</code>将此值设置为“false”将禁用Zookeeper配置</font></p>
</li>
<li>
<p><font o="3979"><code i="2133">root</code>设置配置值的基本命名空间</font></p>
</li>
<li>
<p><font o="3980"><code i="2134">defaultContext</code>设置所有应用程序使用的名称</font></p>
</li>
<li>
<p><font o="3981"><code i="2135">profileSeparator</code>设置用于使用配置文件在属性源中分隔配置文件名称的分隔符的值</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="3982">spring-cloud.adoc中的未解决的指令 -  include :: / Users / sgibb / workspace / spring / spring-cloud-samples / scripts / docs /../ cli / docs / src / main / asciidoc / spring-cloud-cli。 ADOC []</font></p>
</div>
</div>
</div>
</div>
<h1 id="_spring_cloud_security" class="sect0">Spring Cloud Security</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><font o="3984">Spring Cloud Security提供了一组用于构建安全应用程序和服务的原语，最小化。</font><font o="3985">可以从外部（或集中）高度配置的声明式模型适用于通常使用中央契约管理服务的大型合作远程组件系统的实现。</font><font o="3986">在像Cloud Foundry这样的服务平台上也很容易使用。</font><font o="3987">基于Spring Boot和Spring安全性OAuth2，我们可以快速创建实现常见模式的系统，如单点登录，令牌中继和令牌交换。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="3988">注意</font></div>
</td>
<td class="content"><font o="3989">
Spring Cloud根据非限制性Apache 2.0许可证发布。</font><font o="3990">如果您想为文档的这一部分做出贡献，或者发现错误，请在</font><a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/asciidoc"><font o="3990">github</font></a><font o="3990">中找到项目中的源代码和问题跟踪器</font><font o="3990">。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_quickstart"><font o="3991">快速开始</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_oauth2_single_sign_on"><font o="3992">OAuth2单一登录</font></h3>
<div class="paragraph">
<p><font o="3993">这是一个具有HTTP基本身份验证和单个用户帐户的Spring Cloud“Hello World”应用程序</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3994">app.groovy</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Grab('spring-boot-starter-security')
@Controller
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3995">您可以使用<code i="2136">spring run app.groovy</code>运行它，并观察日志的密码（用户名为“用户”）。</font><font o="3996">到目前为止，这只是一个Spring Boot应用程序的默认设置。</font></p>
</div>
<div class="paragraph">
<p><font o="3997">这是一个使用OAuth2 SSO的Spring Cloud应用程序：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="3998">app.groovy</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Controller
@EnableOAuth2Sso
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="3999">指出不同？</font><font o="4000">这个应用程序的行为实际上与之前的一样，因为它不知道它是OAuth2的信誉。</font></p>
</div>
<div class="paragraph">
<p><font o="4001">您可以很容易地在github注册一个应用程序，所以如果你想要一个生产应用程序在你自己的域上尝试。</font><font o="4002">如果您很乐意在localhost：8080上测试，那么请在应用程序配置中设置这些属性：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4003">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    client:
      clientId: bd1c0a783ccdd1c9b9e4
      clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
      accessTokenUri: https://github.com/login/oauth/access_token
      userAuthorizationUri: https://github.com/login/oauth/authorize
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4004">运行上面的应用程序，它将重定向到github进行授权。</font><font o="4005">如果您已经登录github，您甚至不会注意到它已经通过身份验证。</font><font o="4006">只有您的应用程序在8080端口上运行，这些凭据才会起作用。</font></p>
</div>
<div class="paragraph">
<p><font o="4007">要限制客户端在获取访问令牌时要求的范围，您可以设置<code i="2137">security.oauth2.client.scope</code>（逗号分隔或YAML中的数组）。</font><font o="4008">默认情况下，作用域为空，由授权服务器确定默认值是什么，通常取决于客户端注册中的设置。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4009">注意</font></div>
</td>
<td class="content"><font o="4010">
上面的例子都是Groovy脚本。</font><font o="4011">如果要在Java（或Groovy）中编写相同的代码，则需要将Spring Security OAuth2添加到类路径中（例如，请参阅</font><a href="https://github.com/spring-cloud-samples/sso"><font o="4011">此处</font></a><font o="4011">的
 </font><a href="https://github.com/spring-cloud-samples/sso"><font o="4011">示例</font></a><font o="4011">）。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_oauth2_protected_resource"><font o="4012">OAuth2受保护资源</font></h3>
<div class="paragraph">
<p><font o="4013">您要使用OAuth2令牌保护API资源？</font><font o="4014">这是一个简单的例子（与上面的客户端配对）：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4015">app.groovy</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Grab('spring-cloud-starter-security')
@RestController
@EnableResourceServer
class Application {

  @RequestMapping('/')
  def home() {
    [message: 'Hello World']
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4016">和</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4017">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_detail"><font o="4018">更多详情</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_single_sign_on"><font o="4019">单点登录</font></h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4020">注意</font></div>
</td>
<td class="content"><font o="4021">
所有OAuth2 SSO和资源服务器功能在版本1.3中移动到Spring Boot。</font><font o="4022">您可以在</font><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/"><font o="4022">Spring Boot用户指南</font></a><font o="4022">中找到文档
 </font><font o="4022">。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_token_relay"><font o="4023">令牌中继</font></h3>
<div class="paragraph">
<p><font o="4024">令牌中继是OAuth2消费者充当客户端，并将传入令牌转发到外发资源请求。</font><font o="4025">消费者可以是纯客户端（如SSO应用程序）或资源服务器。</font></p>
</div>
<div class="sect3">
<h4 id="_client_token_relay"><font o="4026">客户端令牌中继</font></h4>
<div class="paragraph">
<p><font o="4027">如果您的应用是面向OAuth2客户端的用户（即声明为<code i="2138">@EnableOAuth2Sso</code>或<code i="2139">@EnableOAuth2Client</code>），那么它的请求范围为spring security的<code i="2140">OAuth2ClientContext</code>。</font><font o="4028">您可以从此上下文和自动连线<code i="2142">OAuth2ProtectedResourceDetails</code>创建自己的<code i="2141">OAuth2RestTemplate</code>，然后上下文将始终向下转发访问令牌，如果过期则自动刷新访问令牌。</font><font o="4029">（这些是Spring安全和Spring Boot的功能。）</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4030">注意</font></div>
</td>
<td class="content"><font o="4031">
如果您使用<code i="2144">client_credentials</code>令牌，则Spring Boot（1.4.1）不会自动创建<code i="2143">OAuth2ProtectedResourceDetails</code>。</font><font o="4032">在这种情况下，您需要创建自己的<code i="2145">ClientCredentialsResourceDetails</code>并使用<code i="2146">@ConfigurationProperties("security.oauth2.client")</code>进行配置。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_client_token_relay_in_zuul_proxy"><font o="4033">客户端令牌中继在Zuul代理</font></h4>
<div class="paragraph">
<p><font o="4034">如果您的应用程式还有
 </font><a href="http://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy"><font o="4034">Spring Cloud Zuul</font></a><font o="4034">嵌入式反向代理（使用<code i="2147">@EnableZuulProxy</code>），那么您可以要求将OAuth2访问令牌转发到其正在代理的服务。</font><font o="4035">因此，上述的SSO应用程序可以简单地增强：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4036">app.groovy</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Controller
@EnableOAuth2Sso
@EnableZuulProxy
class Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4037">并且（除了将用户登录并抓取令牌之外）将下载的身份验证令牌传递到<code i="2148">/proxy/*</code>服务。</font><font o="4038">如果这些服务是用<code i="2149">@EnableResourceServer</code>实现的，那么他们将在正确的标题中获得一个有效的标记。</font></p>
</div>
<div class="paragraph">
<p><font o="4039">它是如何工作的？</font><font o="4040"><code i="2150">@EnableOAuth2Sso</code>注释引入<code i="2151">spring-cloud-starter-security</code>（您可以在传统应用程序中手动执行），而这又会触发一个<code i="2152">ZuulFilter</code>的自动配置，该属性本身被激活，因为Zuul在classpath（通过<code i="2153">@EnableZuulProxy</code>）。</font><font o="4041">该
 </font><a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/OAuth2TokenRelayFilter.java"><font o="4041">过滤器</font></a><font o="4041"> 
仅从当前已认证的用户提取访问令牌，并将其放入下游请求的请求头中。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_resource_server_token_relay"><font o="4042">资源服务器令牌中继</font></h4>
<div class="paragraph">
<p><font o="4043">如果您的应用有<code i="2154">@EnableResourceServer</code>，您可能希望将传入令牌下载到其他服务。</font><font o="4044">如果您使用<code i="2155">RestTemplate</code>联系下游服务，那么这只是如何使用正确的上下文创建模板的问题。</font></p>
</div>
<div class="paragraph">
<p><font o="4045">如果您的服务使用<code i="2156">UserInfoTokenServices</code>验证传入令牌（即正在使用<code i="2157">security.oauth2.user-info-uri</code>配置）），则可以使用自动连线<code i="2159">OAuth2ClientContext</code>创建<code i="2158">OAuth2RestTemplate</code>（将由身份验证过程之前它遇到后端代码）。</font><font o="4046">相等（使用Spring Boot 1.4），您可以在配置中注入<code i="2160">UserInfoRestTemplateFactory</code>并抓取其中的<code i="2161">OAuth2RestTemplate</code>。</font><font o="4047">例如：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4048">MyConfiguration.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
public OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) {
    return factory.getUserInfoRestTemplate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4049">然后，此休息模板将具有由身份验证过滤器使用的<code i="2162">OAuth2ClientContext</code>（请求作用域）相同，因此您可以使用它来发送具有相同访问令牌的请求。</font></p>
</div>
<div class="paragraph">
<p><font o="4050">如果您的应用没有使用<code i="2163">UserInfoTokenServices</code>，但仍然是客户端（即声明<code i="2164">@EnableOAuth2Client</code>或<code i="2165">@EnableOAuth2Sso</code>），则使用Spring安全云任何<code i="2166">OAuth2RestOperations</code>，用户从<code i="2167">@Autowired</code> <code i="2168">@OAuth2Context</code>也会转发令牌。</font><font o="4051">此功能默认实现为MVC处理程序拦截器，因此它仅适用于Spring MVC。</font><font o="4052">如果您不使用MVC，可以使用包含<code i="2169">AccessTokenContextRelay</code>的自定义过滤器或AOP拦截器来提供相同的功能。</font></p>
</div>
<div class="paragraph">
<p><font o="4053">以下是一个基本示例，显示了使用其他地方创建的自动连线休息模板（“foo.com”是一个资源服务器，接受与周围应用程序相同的令牌）：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4054">MyController.java</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Autowired
private OAuth2RestOperations restTemplate;

@RequestMapping("/relay")
public String relay() {
    ResponseEntity&lt;String&gt; response =
      restTemplate.getForEntity("https://foo.com/bar", String.class);
    return "Success! (" + response.getBody() + ")";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4055">如果您不想转发令牌（这是一个有效的选择，因为您可能希望以自己的身份而不是向您发送令牌的客户端），那么您只需要创建自己的<code i="2170">OAuth2Context</code>的自动装配默认值。</font></p>
</div>
<div class="paragraph">
<p><font o="4056">Feign客户端也会选择使用<code i="2171">OAuth2ClientContext</code>的拦截器，如果它是可用的，那么他们还应该在<code i="2172">RestTemplate</code>将要执行的令牌中继。</font></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuring_authentication_downstream_of_a_zuul_proxy"><font o="4057">配置Zuul代理下游的认证</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4058">您可以通过<code i="2174">proxy.auth.*</code>设置控制<code i="2173">@EnableZuulProxy</code>下游的授权行为。</font><font o="4059">例：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4060">application.yml</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">proxy:
  auth:
    routes:
      customers: oauth2
      stores: passthru
      recommendations: none</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4061">在此示例中，“客户”服务获取OAuth2令牌中继，“存储”服务获取传递（授权头只是通过下游），“建议”服务已删除其授权头。</font><font o="4062">如果有令牌可用，则默认行为是执行令牌中继，否则为passthru。</font></p>
</div>
<div class="paragraph">
<p><font o="4063">有关</font><font o="4063">详细信息，</font><font o="4063">请参阅
 </font><a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/ProxyAuthenticationProperties"><font o="4063">
ProxyAuthenticationProperties</font></a><font o="4063">。</font></p>
</div>
</div>
</div>
<h1 id="_spring_cloud_for_cloud_foundry" class="sect0"><font o="4064">Spring Cloud为Cloud Foundry</font></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><font o="4065">Cloudfoundry的Spring Cloud可以轻松地</font><font o="4065">在</font><a href="https://github.com/cloudfoundry"><font o="4065">Cloud Foundry</font></a><font o="4065">（平台即服务）</font><font o="4065">中运行
 </font><a href="https://github.com/spring-cloud"><font o="4065">Spring Cloud</font></a><font o="4065">应用程序
 </font><font o="4065">。</font><font o="4066">Cloud Foundry有一个“服务”的概念，它是“绑定”到应用程序的中间件，本质上为其提供包含凭据的环境变量（例如，用于服务的位置和用户名）。</font><a href="https://github.com/cloudfoundry"><font></font></a><font></font></p>
</div>
<div class="paragraph">
<p><font o="4067"><code i="2175">spring-cloud-cloudfoundry-web</code>项目为Cloud Foundry中的webapps的一些增强功能提供基本支持：自动绑定到单点登录服务，并可选择启用粘性路由进行发现。</font></p>
</div>
<div class="paragraph">
<p><font o="4068"><code i="2176">spring-cloud-cloudfoundry-discovery</code>项目提供Spring Cloud Commons <code i="2177">DiscoveryClient</code>的实施，因此您可以<code i="2178">@EnableDiscoveryClient</code>并将您的凭据提供为<code i="2179">spring.cloud.cloudfoundry.discovery.[email,password]</code>，然后直接或通过<code i="2181">LoadBalancerClient</code>使用<code i="2180">DiscoveryClient</code> /}（如果您没有连接到</font><a href="https://run.pivotal.io/"><font o="4068">Pivotal Web Services，</font></a><font o="4068">则也为<code i="2182">*.url</code>
 </font><font o="4068">）。</font></p>
</div>
<div class="paragraph">
<p><font o="4069">第一次使用它时，发现客户端可能很慢，因为它必须从Cloud Foundry获取访问令牌。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discovery"><font o="4070">发现</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4071">以下是Cloud Foundry发现的Spring Cloud应用程序：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4072">app.groovy</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Grab('org.springframework.cloud:spring-cloud-cloudfoundry')
@RestController
@EnableDiscoveryClient
class Application {

  @Autowired
  DiscoveryClient client

  @RequestMapping('/')
  String home() {
    'Hello from ' + client.getLocalServiceInstance()
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4073">如果您运行它没有任何服务绑定：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">$ spring jar app.jar app.groovy
$ cf push -p app.jar</pre>
</div>
</div>
<div class="paragraph">
<p><font o="4074">它将在主页中显示其应用程序名称。</font></p>
</div>
<div class="paragraph">
<p><font o="4075"><code i="2183">DiscoveryClient</code>可以根据身份验证的凭据列出空间中的所有应用程序，其中的空间默认为客户端运行的空间（如果有的话）。</font><font o="4076">如果组织和空间都不配置，则它们将根据Cloud Foundry中的用户配置文件进行默认。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_single_sign_on_2"><font o="4077">单点登录</font></h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4078">注意</font></div>
</td>
<td class="content"><font o="4079">
所有OAuth2 SSO和资源服务器功能在版本1.3中移动到Spring Boot。</font><font o="4080">您可以在</font><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/"><font o="4080">Spring Boot用户指南</font></a><font o="4080">中找到文档
 </font><font o="4080">。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4081">该项目提供从CloudFoundry服务凭据到Spring Boot功能的自动绑定。</font><font o="4082">如果您有一个称为“sso”的CloudFoundry服务，例如，使用包含“client_id”，“client_secret”和“auth_domain”的凭据，它将自动绑定到您使用<code i="2184">@EnableOAuth2Sso</code>启用的Spring OAuth2客户端来自Spring Boot）。</font><font o="4083">可以使用<code i="2185">spring.oauth2.sso.serviceId</code>对服务的名称进行参数化。</font></p>
</div>
</div>
</div>
<h1 id="_spring_cloud_contract" class="sect0">Spring Cloud Contract</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><em><font o="4085">文献作者：Adam Dudczak，MathiasDüsterhöft，Marcin Grzejszczak，Dennis Kieselhorst，JakubKubryński，Karol Lassak，Olga Maciaszek-Sharma，MariuszSmykuła，Dave Syer</font></em></p>
</div>
<div class="paragraph">
<p><font o="4086">Dalston.RELEASE</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract_2">Spring Cloud Contract</h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4088">您始终需要的是将新功能推向分布式系统中的新应用程序或服务的信心。</font><font o="4089">该项目为Spring应用程序中的消费者驱动Contracts和服务架构提供支持，涵盖了一系列用于编写测试的选项，将其作为资产发布，声称生产者和消费者保留合同用于HTTP和消息的交互。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract_wiremock"><font o="4090">Spring Cloud Contract WireMock</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4091">模块让您有可能使用
 </font><a href="http://wiremock.org/"><font o="4091">WireMock</font></a><font o="4091">使用嵌入在Spring Boot应用的“环境”服务器不同的服务器。</font><font o="4092">查看
 </font><a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples"><font o="4092">样品</font></a><font o="4092"> 
了解更多详情。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4093">重要</font></div>
</td>
<td class="content"><font o="4094">
Spring Cloud发布列表BOM导入<code i="2186">spring-cloud-contract-dependencies</code>，这反过来又排除了WireMock所需的依赖关系。</font><font o="4095">这可能导致一种情况，即使你不使用Spring Cloud Contract，那么你的依赖将会受到影响。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4096">如果您有一个使用Tomcat作为嵌入式服务器的Spring Boot应用程序（默认为<code i="2187">spring-boot-starter-web</code>）），那么您可以简单地将<code i="2188">spring-cloud-contract-wiremock</code>添加到类路径中并添加<code i="2189">@AutoConfigureWireMock</code>，以便可以在测试中使用Wiremock。</font><font o="4097">Wiremock作为存根服务器运行，您可以使用Java API或通过静态JSON声明来注册存根行为，作为测试的一部分。</font><font o="4098">这是一个简单的例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
public class WiremockForDocsTests {
	// A service that calls out over HTTP
	@Autowired private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4099">要使用<code i="2190">@AutoConfigureWireMock(port=9999)</code>（例如）启动不同端口上的存根服务器，并且对于随机端口使用值0.存根服务器端口将在测试应用程序上下文中绑定为“wiremock.server.port”。</font><font o="4100">使用<code i="2191">@AutoConfigureWireMock</code>将一个类型为<code i="2192">WiremockConfiguration</code>的bean添加到测试应用程序上下文中，它将被缓存在具有相同上下文的方法和类之间，就像一般的Spring集成测试一样。</font></p>
</div>
<div class="sect2">
<h3 id="_registering_stubs_automatically"><font o="4101">自动注册存根</font></h3>
<div class="paragraph">
<p><font o="4102">如果您使用<code i="2193">@AutoConfigureWireMock</code>，则它将从文件系统或类路径注册WireMock JSON存根，默认情况下为<code i="2194">file:src/test/resources/mappings</code>。</font><font o="4103">您可以使用注释中的<code i="2195">stubs</code>属性自定义位置，这可以是资源模式（ant-style）或目录，在这种情况下，附加<code i="2196"><strong>*/</strong>.json</code>。</font><font o="4104">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="notranslate">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(stubs="classpath:/stubs")
public class WiremockImportApplicationTests {

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4105">注意</font></div>
</td>
<td class="content"><font o="4106">
实际上，WireMock总是从<code i="2197">src/test/resources/mappings</code> </font><strong><font o="4106">中</font></strong><font o="4106">加载映射</font><strong><font o="4106">以及</font></strong><font o="4106"> stubs属性</font><strong><font o="4106">中</font></strong><font o="4106">的自定义位置。</font><font o="4107">要更改此行为，您还必须如下所述指定文件根。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_using_files_to_specify_the_stub_bodies"><font o="4108">使用文件指定存根体</font></h3>
<div class="paragraph">
<p><font o="4109">WireMock可以从类路径或文件系统上的文件读取响应体。</font><font o="4110">在这种情况下，您将在JSON DSL中看到响应具有“bodyFileName”而不是（文字）“body”。</font><font o="4111">默认情况下，相对于根目录<code i="2198">src/test/resources/__files</code>解析文件。</font><font o="4112">要自定义此位置，您可以将<code i="2200">@AutoConfigureWireMock</code>注释中的<code i="2199">files</code>属性设置为父目录的位置（即，位置<code i="2201">__files</code>是子目录）。</font><font o="4113">您可以使用Spring资源符号来引用<code i="2202">file:…​</code>或<code i="2203">classpath:…​</code>位置（但不支持通用URL）。</font><font o="4114">可以给出值列表，并且WireMock将在需要查找响应体时解析存在的第一个文件。</font></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4115">注意</font></div>
</td>
<td class="content"><font o="4116">
当配置<code i="2204">files</code>根时，它会影响自动加载存根（它们来自称为“映射”的子目录中的根位置）。</font><font o="4117"><code i="2205">files</code>的值对从<code i="2206">stubs</code>属性明确加载的存根没有影响。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_alternative_using_junit_rules"><font o="4118">替代方法：使用JUnit规则</font></h3>
<div class="paragraph">
<p><font o="4119">对于更常规的WireMock体验，使用JUnit <code i="2207">@Rules</code>启动和停止服务器，只需使用<code i="2208">WireMockSpring</code>便利类来获取<code i="2209">Options</code>实例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class WiremockForDocsClassRuleTests {

	// Start WireMock on some dynamic port
	// for some reason `dynamicPort()` is not working properly
	@ClassRule
	public static WireMockClassRule wiremock = new WireMockClassRule(
			WireMockSpring.options().dynamicPort());
	// A service that calls out over HTTP to localhost:${wiremock.port}
	@Autowired
	private Service service;

	// Using the WireMock APIs in the normal way:
	@Test
	public void contextLoads() throws Exception {
		// Stubbing WireMock
		wiremock.stubFor(get(urlEqualTo("/resource"))
				.willReturn(aResponse().withHeader("Content-Type", "text/plain").withBody("Hello World!")));
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4120">使用<code i="2210">@ClassRule</code>表示服务器将在此类中的所有方法后关闭。</font></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wiremock_and_spring_mvc_mocks"><font o="4121">WireMock和Spring MVC模拟器</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4122">Spring Cloud Contract提供了一个方便的类，可以将JSON WireMock存根加载到Spring <code i="2211">MockRestServiceServer</code>中。</font><font o="4123">以下是一个例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
public class WiremockForDocsMockServerApplicationTests {

	@Autowired
	private RestTemplate restTemplate;

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		// will read stubs classpath
		MockRestServiceServer server = WireMockRestServiceServer.with(this.restTemplate)
				.baseUrl("http://example.org").stubs("classpath:/stubs/resource.json")
				.build();
		// We're asserting if WireMock responded properly
		assertThat(this.service.go()).isEqualTo("Hello World");
		server.verify();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4124"><code i="2212">baseUrl</code>前面是所有模拟调用，<code i="2213">stubs()</code>方法将一个存根路径资源模式作为参数。</font><font o="4125">所以在这个例子中，<code i="2214">/stubs/resource.json</code>定义的存根被加载到模拟服务器中，所以如果<code i="2215">RestTemplate</code>被要求访问<code i="2216"><a href="http://example.org/" class="bare">http://example.org/</a></code>，那么它将得到所声明的响应。</font><font o="4126">可以指定多个存根模式，每个可以是一个目录（对于所有“.json”的递归列表）或一个固定的文件名（如上例所示）或一个蚂蚁样式模式。</font><font o="4127">JSON格式是通常的WireMock格式，您可以在WireMock网站上阅读。</font></p>
</div>
<div class="paragraph">
<p><font o="4128">目前，我们支持Tomcat，Jetty和Undertow作为Spring Boot嵌入式服务器，而Wiremock本身对特定版本的Jetty（目前为9.2）具有“本机”支持。</font><font o="4129">要使用本地Jetty，您需要添加本机线程依赖关系，并排除Spring Boot容器（如果有的话）。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_stubs_using_restdocs"><font o="4130">使用RestDocs生成存根</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://projects.spring.io/spring-restdocs"><font o="4131">Spring RestDocs</font></a><font o="4131">可用于为具有Spring MockMvc或RestEasy的HTTP API生成文档（例如，asciidoctor格式）。</font><font o="4132">在生成API文档的同时，还可以使用Spring Cloud Contract WireMock生成WireMock存根。</font><font o="4133">只需编写正常的RestDocs测试用例，并使用<code i="2217">@AutoConfigureRestDocs</code>在restdocs输出目录中自动存储存根。</font><font o="4134">例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(get("/resource"))
				.andExpect(content().string("Hello World"))
				.andDo(document("resource"));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4135">从此测试将在“target / snippets / stubs / resource.json”上生成一个WireMock存根。</font><font o="4136">它将所有GET请求与“/ resource”路径相匹配。</font></p>
</div>
<div class="paragraph">
<p><font o="4137">没有任何其他配置，这将创建一个存根与HTTP方法的请求匹配器和除“主机”和“内容长度”之外的所有头。</font><font o="4138">为了更准确地匹配请求，例如要匹配POST或PUT的正文，我们需要明确创建一个请求匹配器。</font><font o="4139">这将做两件事情：1）创建一个只匹配您指定的方式的存根，2）断言测试用例中的请求也匹配相同的条件。</font></p>
</div>
<div class="paragraph">
<p><font o="4140">主要的入口点是<code i="2218">WireMockRestDocs.verify()</code>，可以替代<code i="2219">document()</code>便利方法。</font><font o="4141">例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(post("/resource")
                .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
				.andExpect(status().isOk())
				.andDo(verify().jsonPath("$.id")
                        .stub("resource"));
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4142">所以这个合同是说：任何有效的POST与“id”字段将得到与本测试相同的响应。</font><font o="4143">您可以将来电链接到<code i="2220">.jsonPath()</code>以添加其他匹配器。</font><font o="4144">如果
 </font><font o="4144">您不</font><a href="https://github.com/jayway/JsonPath"><font o="4144">熟悉JayWay文档，</font></a><font o="4144">可以帮助您加快JSON路径的速度。</font></p>
</div>
<div class="paragraph">
<p><font o="4145">您也可以使用WireMock API来验证请求是否与创建的存根匹配，而不是使用<code i="2221">jsonPath</code>和<code i="2222">contentType</code>方法。</font><font o="4146">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Test
public void contextLoads() throws Exception {
	mockMvc.perform(post("/resource")
               .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
			.andExpect(status().isOk())
			.andDo(verify()
					.wiremock(WireMock.post(
						urlPathEquals("/resource"))
						.withRequestBody(matchingJsonPath("$.id"))
                       .stub("post-resource"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4147">WireMock API是丰富的 - 您可以通过正则表达式以及json路径来匹配头文件，查询参数和请求正文，因此这可以用于创建具有更广泛参数的存根。</font><font o="4148">上面的例子会生成一个这样的stub：</font></p>
</div>
<div class="listingblock">
<div class="title"><font o="4149">后resource.json</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
  "request" : {
    "url" : "/resource",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$.id"
    }]
  },
  "response" : {
    "status" : 200,
    "body" : "Hello World",
    "headers" : {
      "X-Application-Context" : "application:-1",
      "Content-Type" : "text/plain"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4150">注意</font></div>
</td>
<td class="content"><font o="4151">
您可以使用<code i="2223">wiremock()</code>方法或<code i="2224">jsonPath()</code>和<code i="2225">contentType()</code>方法创建请求匹配器，但不能同时使用两者。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4152">在消费方面，假设上面生成的<code i="2226">resource.json</code>可以在类路径中使用，您可以使用WireMock以多种不同的方式创建一个存根，其中包括上述使用<code i="2227">@AutoConfigureWireMock(stubs="classpath:resource.json")</code>的描述。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_contracts_using_restdocs"><font o="4153">使用RestDocs生成Contracts</font></h2>
<div class="sectionbody">
<div class="paragraph">
<p><font o="4154">可以使用Spring RestDocs生成的另一件事是Spring Cloud Contract DSL文件和文档。</font><font o="4155">如果您将其与Spring Cloud WireMock相结合，那么您将获得合同和存根。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4156">提示</font></div>
</td>
<td class="content"><font o="4157">
您可能会想知道为什么该功能在WireMock模块中。</font><font o="4158">来想一想，它确实有道理，因为只生成合同并且不生成存根就没有意义。</font><font o="4159">这就是为什么我们建议做这两个。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4160">我们来想象下面的测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">		this.mockMvc.perform(post("/foo")
					.accept(MediaType.APPLICATION_PDF)
					.accept(MediaType.APPLICATION_JSON)
					.contentType(MediaType.APPLICATION_JSON)
					.content("{\"foo\": 23 }"))
				.andExpect(status().isOk())
				.andExpect(content().string("bar"))
				// first WireMock
				.andDo(WireMockRestDocs.verify()
						.jsonPath("$[?(@.foo &gt;= 20)]")
						.contentType(MediaType.valueOf("application/json"))
						.stub("shouldGrantABeerIfOldEnough"))
				// then Contract DSL documentation
				.andDo(document("index", SpringCloudContractRestDocs.dslContract()));</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4161">这将导致在上一节中介绍的存根的创建，合同将被生成和文档文件。</font></p>
</div>
<div class="paragraph">
<p><font o="4162">合同将被称为<code i="2228">index.groovy</code>，看起来更像是这样。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method 'POST'
        url 'http://localhost:8080/foo'
        body('''
            {"foo": 23 }
        ''')
        headers {
            header('''Accept''', '''application/json''')
            header('''Content-Type''', '''application/json''')
            header('''Host''', '''localhost:8080''')
            header('''Content-Length''', '''12''')
        }
    }
    response {
        status 200
        body('''
        bar
        ''')
        headers {
            header('''Content-Type''', '''application/json;charset=UTF-8''')
            header('''Content-Length''', '''3''')
        }
        testMatchers {
            jsonPath('$[?(@.foo &gt;= 20)]', byType())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4163">生成的文档（Asciidoc的示例）将包含格式化的合同（此文件的位置将为<code i="2229">index/dsl-contract.adoc</code>）。</font></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_cloud_contract_verifier"><font o="4164">Spring Cloud Contract验证者</font></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction"><font o="4165">介绍</font></h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4166">重要</font></div>
</td>
<td class="content">
<a href="https://codearte.github.io/accurest"><font o="4167">1.1.0版中已弃用的Accurest项目的文档可在此处获取。</font></a>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4168">提示</font></div>
</td>
<td class="content"><font o="4169">
Accurest项目最初是由Marcin Grzejszczak和Jakub Kubrynski（</font><a href="http://codearte.io/"><font o="4169">codearte.io</font></a><font o="4169">）
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4170">只是为了简短说明 -  Spring Cloud Contract验证程序是一种能够启用消费者驱动合同（CDC）开发基于JVM的应用程序的工具。</font><font o="4171">它与</font><em><font o="4171">合同定义语言</font></em><font o="4171">（DSL）</font><font o="4171">一起提供</font><font o="4171">。</font><font o="4172">合同定义用于生成以下资源：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4173">在客户端代码（</font><em><font o="4173">客户端测试</font></em><font o="4173">）</font><font o="4173">上进行集成测试时，WireMock将使用JSON存根定义</font><font o="4173">。</font><font o="4174">测试代码仍然需要手动编写，测试数据由Spring Cloud Contract验证器生成。</font></p>
</li>
<li>
<p><font o="4175">消息传递路由，如果你使用一个。</font><font o="4176">我们正在与Spring Integration，Spring Cloud Stream，Spring AMQP和Apache Camel进行整合。</font><font o="4177">然而，您可以设置自己的集成，如果你想</font></p>
</li>
<li>
<p><font o="4178">验收测试（在JUnit或Spock中）用于验证API的服务器端实现是否符合合同（</font><em><font o="4178">服务器测试</font></em><font o="4178">）。</font><font o="4179">完全测试由Spring Cloud Contract验证器生成。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4180">Spring Cloud Contract验证者将TDD移动到软件体系结构的层次。</font></p>
</div>
<div class="sect3">
<h4 id="_spring_cloud_contract_video"><font o="4181">Spring Cloud Contract视频</font></h4>
<div class="paragraph">
<p><font o="4182">您可以查看华沙JUG关于Spring Cloud Contract的视频：</font>
<a href="https://www.youtube.com/embed/sAAklvxmPmk?rel=0&amp;start=538"><font o="3309">点击此处查看视频</font></a></p>
</div>

</div>
<div class="sect3">
<h4 id="_why"><font o="4183">为什么？</font></h4>
<div class="paragraph">
<p><font o="4184">让我们假设我们有一个由多个微服务组成的系统：</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/Deps.png" alt="微服务架构">
</div>
</div>
<div class="sect4">
<h5 id="_testing_issues"><font o="4185">测试问题</font></h5>
<div class="paragraph">
<p><font o="4186">如果我们想测试应用程序在左上角，如果它可以与其他服务通信，那么我们可以做两件事之一：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4187">部署所有微服务器并执行端到端测试</font></p>
</li>
<li>
<p><font o="4188">模拟其他微型服务单元/集成测试</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4189">两者都有其优点，但也有很多缺点。</font><font o="4190">我们来关注后者。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4191">部署所有微服务器并执行端到端测试</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4192">优点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4193">模拟生产</font></p>
</li>
<li>
<p><font o="4194">测试服务之间的真实沟通</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4195">缺点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4196">要测试一个微服务器，我们将不得不部署6个微服务器，几个数据库等。</font></p>
</li>
<li>
<p><font o="4197">将进行测试的环境将被锁定用于一套测试（即没有人能够在此期间运行测试）。</font></p>
</li>
<li>
<p><font o="4198">长跑</font></p>
</li>
<li>
<p><font o="4199">非常迟的反馈</font></p>
</li>
<li>
<p><font o="4200">非常难调试</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><font o="4201">模拟其他微型服务单元/集成测试</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4202">优点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4203">非常快的反馈</font></p>
</li>
<li>
<p><font o="4204">没有基础架构要求</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4205">缺点：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4206">服务的实现者创建存根，因此它们可能与现实无关</font></p>
</li>
<li>
<p><font o="4207">您可以通过测试和生产不合格进行生产</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4208">为了解决上述问题，Spring Cloud Contract Stub Runner的验证器被创建。</font><font o="4209">他们的主要思想是给你非常快的反馈，而不需要建立整个微服务的世界。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/Stubs1.png" alt="Stubbed服务">
</div>
</div>
<div class="paragraph">
<p><font o="4210">如果您在存根上工作，那么您需要的唯一应用是应用程序直接使用的应用程序。</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/Stubs2.png" alt="Stubbed服务">
</div>
</div>
<div class="paragraph">
<p><font o="4211">Spring Cloud Contract验证者确定您使用的存根是由您正在调用的服务创建的。</font><font o="4212">此外，如果您可以使用它们，这意味着它们是针对生产者的一方进行测试的。</font><font o="4213">换句话说 - 你可以信任这些存根。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_purposes"><font o="4214">目的</font></h4>
<div class="paragraph">
<p><font o="4215">Spring Cloud Contract验证器与Stub Runner的主要目的是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4216">确保WireMock / Messaging存根（在开发客户端时使用）正在完全实际执行服务器端实现，</font></p>
</li>
<li>
<p><font o="4217">推广ATDD方法和微服务架构风格，</font></p>
</li>
<li>
<p><font o="4218">提供一种发布双方立即可见的合同变更的方法，</font></p>
</li>
<li>
<p><font o="4219">生成服务器端使用的样板测试代码。</font></p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4220">重要</font></div>
</td>
<td class="content"><font o="4221">
Spring Cloud Contract验证者的目的不是开始在合同中编写业务功能。</font><font o="4222">我们假设我们有一个欺诈检查的商业用例。</font><font o="4223">如果一个用户因为100个不同的原因而被欺骗，我们假设你会创建2个合同。</font><font o="4224">一个为正面，一个为负面欺诈案。</font><font o="4225">合同测试用于测试应用程序之间的合同，而不是模拟完整行为。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_client_side"><font o="4226">客户端</font></h4>
<div class="paragraph">
<p><font o="4227">在测试期间，您希望启动并运行一个模拟服务Y的WireMock实例/消息传递路由。您希望为该实例提供适当的存根定义。</font><font o="4228">该存根定义将需要有效，并且也应在服务器端可重用。</font></p>
</div>
<div class="paragraph">
<p><em><font o="4229">总结：</font></em><font o="4229">在这方面，在存根定义中，您可以使用模式进行请求存根，并需要确切的响应值。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_server_side"><font o="4230">服务器端</font></h4>
<div class="paragraph">
<p><font o="4231">作为开发您的存根的服务Y，您需要确保它实际上类似于您的具体实现。</font><font o="4232">您不能以某种方式存在您的存根行为，并且您的生产应用程序以不同的方式运行。</font></p>
</div>
<div class="paragraph">
<p><font o="4233">这就是为什么会生成提供的存根验收测试，这将确保您的应用程序的行为与您在存根中定义的相同。</font></p>
</div>
<div class="paragraph">
<p><em><font o="4234">总结：</font></em><font o="4234">在这方面，在存根定义中，您需要精确的值作为请求，并可以使用模式/方法进行响应验证。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_step_by_step_guide_to_cdc"><font o="4235">逐步向CDC指导</font></h4>
<div class="paragraph">
<p><font o="4236">举一个欺诈检测和贷款发行流程的例子。</font><font o="4237">业务情景是这样的，我们想向人们发放贷款，但不希望他们从我们那里偷钱。</font><font o="4238">目前我们的系统实施给大家贷款。</font></p>
</div>
<div class="paragraph">
<p><font o="4239">假设<code i="2230">Loan Issuance</code>是<code i="2231">Fraud Detection</code>服务器的客户端。</font><font o="4240">在目前的冲刺中，我们需要开发一个新的功能 - 如果客户想要借到太多的钱，那么我们将他们标记为欺诈。</font></p>
</div>
<div class="paragraph">
<p><font o="4241">技术说明 - 欺诈检测将具有工件ID <code i="2232">http-server</code>，贷款发行<code i="2233">http-client</code>，两者都具有组ID <code i="2234">com.example</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="4242">社会声明 - 客户端和服务器开发团队都需要直接沟通，并在整个过程中讨论变更。</font><font o="4243">CDC是关于沟通的。</font></p>
</div>
<div class="paragraph">
<p><font o="4244">在</font><a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/dsl/http-server"><font o="4244">服务器端代码可以在这里</font></a><font o="4244">和</font><a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/dsl/http-client"><font o="4244">这里的客户端代码</font></a><font o="4244">。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4245">提示</font></div>
</td>
<td class="content"><font o="4246">
在这种情况下，合同的所有权在生产者方面。</font><font o="4247">这意味着物理上所有的合同都存在于生产者存储库中
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_technical_note"><font o="4248">技术说明</font></h5>
<div class="paragraph">
<p><font o="4249">如果使用</font><strong><font o="4249">SNAPSHOT</font></strong><font o="4249"> / </font><strong><font o="4249">里程碑</font></strong><font o="4249"> / </font><strong><font o="4249">版本候选</font></strong><font o="4249">版本，请将以下部分添加到您的</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="4250">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="4251">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">repositories {
	mavenCentral()
	mavenLocal()
	maven { url "http://repo.spring.io/snapshot" }
	maven { url "http://repo.spring.io/milestone" }
	maven { url "http://repo.spring.io/release" }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_side_loan_issuance"><font o="4252">消费方（贷款发行）</font></h5>
<div class="paragraph">
<p><font o="4253">作为贷款发行服务（欺诈检测服务器的消费者）的开发人员：</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4254">通过对您的功能进行测试开始做TDD</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@Test
public void shouldBeRejectedDueToAbnormalLoanAmount() {
	// given:
	LoanApplication application = new LoanApplication(new Client("1234567890"),
			99999);
	// when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
	// then:
	assertThat(loanApplication.getLoanApplicationStatus())
			.isEqualTo(LoanApplicationStatus.LOAN_APPLICATION_REJECTED);
	assertThat(loanApplication.getRejectionReason()).isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4255">我们刚刚写了一个关于我们新功能的测试。</font><font o="4256">如果收到大额的贷款申请，我们应该拒绝有一些描述的贷款申请。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4257">写入缺少的实现</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4258">在某些时间点，您需要向欺诈检测服务发送请求。</font><font o="4259">我们假设我们要发送包含客户端ID和要从我们借款的金额的请求。</font><font o="4260">我们想通过<code i="2236">PUT</code>方法将其发送到<code i="2235">/fraudcheck</code>网址。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">ResponseEntity&lt;FraudServiceResponse&gt; response =
		restTemplate.exchange("http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
				new HttpEntity&lt;&gt;(request, httpHeaders),
				FraudServiceResponse.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4261">为了简单起见，我们已将<code i="2237">8080</code>的欺诈检测服务端口硬编码，我们的应用程序正在<code i="2238">8090</code>上运行。</font></p>
</div>
<div class="paragraph">
<p><font o="4262">如果我们开始写测试，显然会因为端口<code i="2239">8080</code>上没有运行而打断。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4263">在本地克隆欺诈检测服务存储库</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4264">我们将开始玩服务器端的合同。</font><font o="4265">这就是为什么我们需要先克隆它。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">git clone https://your-git-server.com/server-side.git local-http-server-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="4266">在欺诈检测服务的回购中本地定义合同</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4267">作为消费者，我们需要确定我们想要实现的目标。</font><font o="4268">我们需要制定我们的期望。</font><font o="4269">这就是为什么我们写下面的合同。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4270">重要</font></div>
</td>
<td class="content"><font o="4271">
我们将合同放在<code i="2240">src/test/resources/contract/fraud</code>下。</font><font o="4272"><code i="2241">fraud</code>文件夹是重要的，因为我们将在生产者的测试基类中引用该文件夹。
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { // (1)
		method 'PUT' // (2)
		url '/fraudcheck' // (3)
		body([ // (4)
			   clientId: $(regex('[0-9]{10}')),
			   loanAmount: 99999
		])
		headers { // (5)
			contentType('application/vnd.fraud.v1+json')
		}
	}
	response { // (6)
		status 200 // (7)
		body([ // (8)
			   fraudCheckStatus: "FRAUD",
			   rejectionReason: "Amount too high"
		])
		headers { // (9)
			contentType('application/vnd.fraud.v1+json')
		}
	}
}

/*
Since we don't want to force on the user to hardcode values of fields that are dynamic
(timestamps, database ids etc.), one can parametrize those entries. If you wrap your field's
 value in a `$(...)` or `value(...)` and provide a dynamic value of a field then
 the concrete value will be generated for you. If you want to be really explicit about
 which side gets which value you can do that by using the `value(consumer(...), producer(...))` notation.
 That way what's present in the `consumer` section will end up in the produced stub. What's
 there in the `producer` will end up in the autogenerated test. If you provide only the
 regular expression side without the concrete value then Spring Cloud Contract will generate one for you.

From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `clientId` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `clientId` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/vnd.fraud.v1+json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/vnd.fraud.v1+json.*`
 */</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4273">合同使用静态类型的Groovy DSL编写。</font><font o="4274">你可能想知道这些<code i="2242">value(client(…​), server(…​))</code>部分是什么。</font><font o="4275">通过使用这种符号Spring Cloud Contract，您可以定义动态的JSON / URL /等的部分。</font><font o="4276">在标识符或时间戳的情况下，您不想硬编码一个值。</font><font o="4277">你想允许一些不同的值范围。</font><font o="4278">这就是为什么对于消费者端，您可以设置与这些值匹配的正则表达式。</font><font o="4279">您可以通过地图符号或带插值的String来提供身体。
</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl"><font o="4280">有关更多信息，请参阅文档。</font></a><font o="4281">我们强烈推荐使用地图符号！</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4282">提示</font></div>
</td>
<td class="content"><font o="4283">
了解地图符号设置合同非常重要。</font><font o="4284">请阅读有关</font><a href="http://groovy-lang.org/json.html"><font o="4284">JSON</font></a><font o="4284">的
 </font><a href="http://groovy-lang.org/json.html"><font o="4284">Groovy文档</font></a>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4285">上述合同是双方达成的协议：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4286">如果发送了HTTP请求</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="4287">端点<code i="2244">/fraudcheck</code>上的方法<code i="2243">PUT</code></font></p>
</li>
<li>
<p><font o="4288">与<code i="2245">clientPesel</code>的正则表达式<code i="2246">[0-9]{10}</code>和<code i="2247">loanAmount</code>等于<code i="2248">99999</code>的JSON体</font></p>
</li>
<li>
<p><font o="4289">并且标题<code i="2249">Content-Type</code>等于<code i="2250">application/vnd.fraud.v1+json</code></font></p>
</li>
</ul>
</div>
</li>
<li>
<p><font o="4290">那么HTTP响应将被发送给消费者</font></p>
<div class="ulist">
<ul>
<li>
<p><font o="4291">状态为<code i="2251">200</code></font></p>
</li>
<li>
<p><font o="4292">包含JSON体，其中包含值为<code i="2253">FRAUD</code>的<code i="2252">fraudCheckStatus</code>字段和值为<code i="2255">Amount too high</code>的<code i="2254">rejectionReason</code>字段</font></p>
</li>
<li>
<p><font o="4293">和一个值为<code i="2257">application/vnd.fraud.v1+json</code>的<code i="2256">Content-Type</code>标头</font></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4294">一旦我们准备好在集成测试中实际检查API，我们需要在本地安装存根</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4295">添加Spring Cloud Contract验证程序插件</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4296">我们可以添加Maven或Gradle插件 - 在这个例子中，我们将展示如何添加Maven。</font><font o="4297">首先我们需要添加<code i="2258">Spring Cloud Contract</code> BOM。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4298">接下来，<code i="2259">Spring Cloud Contract Verifier</code> Maven插件</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4299">自添加插件后，我们将从提供的合同中获得<code i="2260">Spring Cloud Contract Verifier</code>功能：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4300">生成并运行测试</font></p>
</li>
<li>
<p><font o="4301">生产并安装存根</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4302">我们不想生成测试，因为我们作为消费者，只想玩短线。</font><font o="4303">这就是为什么我们需要跳过测试生成和执行。</font><font o="4304">当我们执行：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">cd local-http-server-repo
./mvnw clean install -DskipTests</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4305">在日志中，我们将看到如下：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">[INFO] --- spring-cloud-contract-maven-plugin:1.0.0.BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.0.BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4306">这条线是非常重要的</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4307">确认<code i="2261">http-server</code>的存根已安装在本地存储库中。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4308">运行集成测试</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4309">为了从自动存根下载的Spring Cloud Contract Stub Runner功能中获利，您必须在我们的消费者端项目（<code i="2262">Loan Application service</code>）中执行以下操作。</font></p>
</div>
<div class="paragraph">
<p><font o="4310">添加<code i="2263">Spring Cloud Contract</code> BOM</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4311">将依赖关系添加到<code i="2264">Spring Cloud Contract Stub Runner</code></font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4312">用<code i="2265">@AutoConfigureStubRunner</code>标注你的测试课程。</font><font o="4313">在注释中，提供Stub Runner下载协作者存根的组ID和工件ID。</font><font o="4314">离线工作开关还可以离线使用协作者（可选步骤）。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"}, workOffline = true)
@DirtiesContext
public class LoanApplicationServiceTests {</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4315">现在如果你运行测试你会看到这样的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">2016-07-19 14:22:25.403  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
2016-07-19 14:22:25.438  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is 0.0.1-SNAPSHOT
2016-07-19 14:22:25.439  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT using remote repositories []
2016-07-19 14:22:25.451  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar
2016-07-19 14:22:25.465  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar]
2016-07-19 14:22:25.475  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/0p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
2016-07-19 14:22:27.737  INFO 41050 --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:0.0.1-SNAPSHOT:stubs=8080}]</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4316">这意味着Stub Runner找到了您的存根，并为具有组ID为<code i="2266">com.example</code>，artifact id <code i="2267">http-server</code>，版本为<code i="2268">0.0.1-SNAPSHOT</code>的存根和<code i="2269">stubs</code>分类器的端口<code i="2270">8080</code>。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4317">档案公关</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4318">我们到现在为止是一个迭代的过程。</font><font o="4319">我们可以玩合同，安装在本地，在消费者身边工作，直到我们对合同感到满意。</font></p>
</div>
<div class="paragraph">
<p><font o="4320">一旦我们对结果感到满意，测试通过将PR发布到服务器端。</font><font o="4321">目前消费者方面的工作已经完成。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_producer_side_fraud_detection_server"><font o="4322">生产者方（欺诈检测服务器）</font></h5>
<div class="paragraph">
<p><font o="4323">作为欺诈检测服务器（贷款发行服务的服务器）的开发人员：</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4324">初步实施</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4325">作为提醒，您可以看到初始实现</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RequestMapping(
		value = "/fraudcheck",
		method = PUT,
		consumes = FRAUD_SERVICE_JSON_VERSION_1,
		produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="4326">接管公关</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">git checkout -b contract-change-pr master
git pull https://your-git-server.com/server-side-fork.git contract-change-pr</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4327">您必须添加自动生成测试所需的依赖关系</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">	&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-starter-contract-verifier&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4328">在Maven插件的配置中，我们传递了<code i="2271">packageWithBaseClasses</code>属性</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4329">重要</font></div>
</td>
<td class="content"><font o="4330">
我们决定使用“约定”命名，方法是设置<code i="2272">packageWithBaseClasses</code>属性。</font><font o="4331">这意味着最后的两个包将被组合成基本测试类的名称。</font><font o="4332">在我们这个例子中，这些合约是<code i="2273">src/test/resources/contract/fraud</code>。</font><font o="4333">由于我们没有从<code i="2274">contracts</code>文件夹开始有2个包，我们只挑选一个是<code i="2275">fraud</code>。</font><font o="4334">我们正在添加<code i="2276">Base</code>后缀，我们正在大写<code i="2277">fraud</code>。</font><font o="4335">这给了我们<code i="2278">FraudBase</code>测试类名称。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4336">这是因为所有生成的测试都会扩展该类。</font><font o="4337">在那里你可以设置你的Spring上下文或任何必要的。</font><font o="4338">在我们的例子中，我们使用</font><a href="http://rest-assured.io/"><font o="4338">Rest Assured MVC</font></a><font o="4338">来启动服务器端<code i="2279">FraudDetectionController</code>。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.example.fraud;

import org.junit.Before;

import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc;

public class FraudBase {
	@Before
	public void setup() {
		RestAssuredMockMvc.standaloneSetup(new FraudDetectionController(),
				new FraudStatsController(stubbedStatsProvider()));
	}

	private StatsProvider stubbedStatsProvider() {
		return fraudType -&gt; {
			switch (fraudType) {
			case DRUNKS:
				return 100;
			case ALL:
				return 200;
			}
			return 0;
		};
	}

	public void assertThatRejectionReasonIsNull(Object rejectionReason) {
		assert rejectionReason == null;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4339">现在，如果你运行<code i="2280">./mvnw clean install</code>，你会得到这样的sth：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">Results :

Tests in error:
  ContractVerifierTest.validate_shouldMarkClientAsFraud:32 » IllegalState Parsed...</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4340">这是因为您有一个新的合同，从中生成测试，并且由于您尚未实现该功能而失败。</font><font o="4341">自动生成测试将如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"clientPesel\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("fraudCheckStatus").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4342">您可以看到<code i="2282">value(consumer(…​), producer(…​))</code>块中存在的所有<code i="2281">producer()</code>部分合同注入测试。</font></p>
</div>
<div class="paragraph">
<p><font o="4343">重要的是在生产者方面，我们也在做TDD。</font><font o="4344">我们有一个测试形式的期望。</font><font o="4345">此测试正在向我们自己的应用程序拍摄一个在合同中定义的URL，标题和主体的请求。</font><font o="4346">它也期待响应中非常精确地定义的值。</font><font o="4347">换句话说，您是<code i="2284">red</code> <code i="2285">green</code>和<code i="2286">refactor</code>的<code i="2283">red</code>部分。</font><font o="4348">将<code i="2287">red</code>转换为<code i="2288">green</code>的时间。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4349">写入缺少的实现</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4350">现在，由于我们现在预期的输入和预期的输出是什么，我们来写这个缺少的实现。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RequestMapping(
		value = "/fraudcheck",
		method = PUT,
		consumes = FRAUD_SERVICE_JSON_VERSION_1,
		produces = FRAUD_SERVICE_JSON_VERSION_1)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
if (amountGreaterThanThreshold(fraudCheck)) {
	return new FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
}
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4351">如果再次执行<code i="2289">./mvnw clean install</code>，测试将通过。</font><font o="4352">由于<code i="2290">Spring Cloud Contract Verifier</code>插件将测试添加到<code i="2291">generated-test-sources</code>，您可以从IDE中实际运行这些测试。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4353">部署你的应用程序</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4354">完成工作后，现在是部署变更的时候了。</font><font o="4355">首先合并分支</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">git checkout master
git merge --no-ff contract-change-pr
git push origin master</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4356">那么我们假设你的CI将像<code i="2292">./mvnw clean deploy</code>一样运行，它将发布应用程序和存根工件。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_side_loan_issuance_final_step"><font o="4357">消费方（贷款发行）最后一步</font></h5>
<div class="paragraph">
<p><font o="4358">作为贷款发行服务（欺诈检测服务器的消费者）的开发人员：</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4359">合并分支到主</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">git checkout master
git merge --no-ff contract-change-pr</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="4360">在线工作</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4361">现在，您可以禁用Spring Cloud Contract Stub Runner广告的离线工作，以提供存储库与存根的位置。</font><font o="4362">此时，服务器端的存根将自动从Nexus / Artifactory下载。</font><font o="4363">您可以关闭注释中的<code i="2293">workOffline</code>参数的值。</font><font o="4364">在下面你可以看到一个通过改变属性实现相同的例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: http://repo.spring.io/libs-snapshot</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4365">就是这样！</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dependencies"><font o="4366">依赖</font></h4>
<div class="paragraph">
<p><font o="4367">添加依赖关系的最佳方法是使用正确的<code i="2294">starter</code>依赖关系。</font></p>
</div>
<div class="paragraph">
<p><font o="4368">对于<code i="2295">stub-runner</code>使用<code i="2296">spring-cloud-starter-stub-runner</code>，当您使用插件时，只需添加<code i="2297">spring-cloud-starter-contract-verifier</code>。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_additional_links"><font o="4369">附加链接</font></h4>
<div class="paragraph">
<p><font o="4370">以下可以找到与Spring Cloud Contract验证器和Stub Runner相关的一些资源。</font><font o="4371">注意，有些可以过时，因为Spring Cloud Contract验证程序项目正在不断发展。</font></p>
</div>
<div class="sect4">
<h5 id="_readings"><font o="4372">阅读</font></h5>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.slideshare.net/MarcinGrzejszczak/stick-to-the-rules-consumer-driven-contracts-201507-confitura"><font o="4373">来自Marcin Grzejszczak关于Accurest的演讲</font></a></p>
</li>
<li>
<p><a href="http://toomuchcoding.com/blog/categories/accurest/"><font o="4374">来自Marcin Grzejszczak的博客的Accurest相关文章</font></a></p>
</li>
<li>
<p><a href="http://toomuchcoding.com/blog/categories/spring-cloud-contract/"><font o="4375">来自Marcin Grzejszczak博客的Spring Cloud Contract相关文章</font></a></p>
</li>
<li>
<p><a href="http://groovy-lang.org/json.html"><font o="4376">Groovy关于JSON的文档</font></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_samples_2"><font o="4377">样品</font></h4>
<div class="paragraph">
<p><font o="4378">在这里可以找到一些</font><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples"><font o="4378">样品</font></a><font o="4378">。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_faq"><font o="4379">常问问题</font></h3>
<div class="sect3">
<h4 id="_why_use_spring_cloud_contract_verifier_and_not_x"><font o="4380">为什么使用Spring Cloud Contract验证器而不是X？</font></h4>
<div class="paragraph">
<p><font o="4381">目前Spring Cloud Contract验证器是基于JVM的工具。</font><font o="4382">因此，当您已经为JVM创建软件时，可能是您的第一选择。</font><font o="4383">这个项目有很多非常有趣的功能，但特别是其中一些绝对让Spring Cloud Contract Verifier在消费者驱动合同（CDC）工具的“市场”上脱颖而出。</font><font o="4384">许多最有趣的是：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4385">CDC可以通过消息传递</font></p>
</li>
<li>
<p><font o="4386">清晰易用，静态DSL</font></p>
</li>
<li>
<p><font o="4387">可以将当前的JSON文件粘贴到合同中，并且仅编辑其元素</font></p>
</li>
<li>
<p><font o="4388">从定义的合同自动生成测试</font></p>
</li>
<li>
<p><font o="4389">Stub Runner功能 - 存根在运行时自动从Nexus / Artifactory下载</font></p>
</li>
<li>
<p><font o="4390">Spring Cloud集成 - 集成测试不需要发现服务</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_what_is_this_value_consumer_producer"><font o="4391">这个值是（consumer（），producer（））？</font></h4>
<div class="paragraph">
<p><font o="4392">与存根相关的最大挑战之一是可重用性。</font><font o="4393">只有如果他们能够被广泛使用，他们是否会服务于他们的目的。</font><font o="4394">通常使得难点是请求/响应元素的硬编码值。</font><font o="4395">例如日期或ids。</font><font o="4396">想象下面的JSON请求</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4397">和JSON响应</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4398">想象一下，通过更改系统中的时钟或提供数据提供者的存根实现，设置<code i="2298">time</code>字段的正确值（我们假设这个内容是由数据库生成的）所需的痛苦。</font><font o="4399">这同样涉及到称为<code i="2299">id</code>的字段。</font><font o="4400">你会创建一个UUID发生器的stubbed实现？</font><font o="4401">没有意义</font></p>
</div>
<div class="paragraph">
<p><font o="4402">所以作为一个消费者，你想发送一个匹配任何形式的时间或任何UUID的请求。</font><font o="4403">这样，您的系统将照常工作 - 将生成数据，您不必将任何东西存入。</font><font o="4404">假设在上述JSON的情况下，最重要的部分是<code i="2300">body</code>字段。</font><font o="4405">您可以专注于其他领域，并提供匹配。</font><font o="4406">换句话说，你想要的存根是这样工作的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4407">就响应作为消费者而言，您需要具有可操作性的具体价值。</font><font o="4408">所以这样的JSON是有效的</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4409">从前面的部分可以看出，我们从合同中产生测试。</font><font o="4410">所以从生产者的角度看，情况看起来差别很大。</font><font o="4411">我们正在解析提供的合同，在测试中我们想向您的端点发送一个真正的请求。</font><font o="4412">因此，对于请求的生产者来说，我们不能进行任何匹配。</font><font o="4413">我们需要具体的价值观，使制片人的后台能够工作。</font><font o="4414">这样的JSON将是一个有效的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4415">另一方面，从合同的有效性的角度来看，响应不一定必须包含<code i="2301">time</code>或<code i="2302">id</code>的具体值。</font><font o="4416">假设您在生产者方面产生这些 - 再次，您必须做很多桩，以确保始终返回相同的值。</font><font o="4417">这就是为什么从生产者那边你可能想要的是以下回应：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4418">那么您如何才能为消费者提供一次匹配，并为生产者提供具体的价值，反之亦然？</font><font o="4419">在Spring Cloud Contract中，我们允许您提供</font><strong><font o="4419">动态值</font></strong><font o="4419">。</font><font o="4420">这意味着通信双方可能有所不同。</font><font o="4421">你可以传递值：</font></p>
</div>
<div class="paragraph">
<p><font o="4422">可以通过<code i="2303">value</code>方法</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">value(consumer(...), producer(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4423">或使用<code i="2304">$()</code>方法</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">$(consumer(...), producer(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4424">您可以在</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_contract_dsl"><font o="4424">Contract DSL部分</font></a><font o="4424">阅读更多信息</font><font o="4424">。</font></p>
</div>
<div class="paragraph">
<p><font o="4425">调用<code i="2305">value()</code>或<code i="2306">$()</code>告诉Spring Cloud Contract您将传递一个动态值。</font><font o="4426">在<code i="2307">consumer()</code>方法中，传递消费者端（在生成的存根）中应该使用的值。</font><font o="4427">在<code i="2308">producer()</code>方法中，传递应在生产者端使用的值（在生成的测试中）。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4428">提示</font></div>
</td>
<td class="content"><font o="4429">
如果一方面你已经通过了正则表达式，而你没有通过另一方，那么对方就会自动生成。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4430">大多数情况下，您将使用该方法与<code i="2309">regex</code>辅助方法。</font><font o="4431">例如<code i="2310">consumer(regex('[0-9]{10}'))</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="4432">总而言之，上述情景的合同看起来或多或少是这样的（正则表达式的时间和UUID被简化，很可能是无效的，但是我们希望在这个例子中保持很简单）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
				request {
					method 'GET'
					url '/someUrl'
					body([
					    time : value(consumer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value(consumer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "foo"
					])
				}
			response {
				status 200
				body([
					    time : value(producer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value([producer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "bar"
					])
			}
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4433">重要</font></div>
</td>
<td class="content"><font o="4434">
请阅读</font><a href="http://groovy-lang.org/json.html"><font o="4434">与JSON相关</font></a><font o="4434">的</font><a href="http://groovy-lang.org/json.html"><font o="4434">Groovy文档，</font></a><font o="4434">以了解如何正确构建请求/响应实体。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_how_to_do_stubs_versioning"><font o="4435">如何做Stubs版本控制？</font></h4>
<div class="sect4">
<h5 id="_api_versioning"><font o="4436">API版本控制</font></h5>
<div class="paragraph">
<p><font o="4437">让我们尝试回答一个真正意义上的版本控制的问题。</font><font o="4438">如果你指的是API版本，那么有不同的方法。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4439">使用超媒体，链接，不要通过任何方式版本您的API</font></p>
</li>
<li>
<p><font o="4440">通过标题/网址传递版本</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4441">我不会试图回答一个方法更好的问题。</font><font o="4442">无论适合您的需求，并允许您创造商业价值应被挑选。</font></p>
</div>
<div class="paragraph">
<p><font o="4443">假设你做你的API版本。</font><font o="4444">在这种情况下，您应该提供与您支持的许多版本一样多的合同。</font><font o="4445">您可以为每个版本创建一个子文件夹，或将其附加到合同名称 - 无论如何适合您。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_jar_versioning"><font o="4446">JAR版本控制</font></h5>
<div class="paragraph">
<p><font o="4447">如果通过版本控制是指包含存根的JAR的版本，那么基本上有两种主要方法。</font></p>
</div>
<div class="paragraph">
<p><font o="4448">假设您正在进行连续交付/部署，这意味着您每次通过管道生成新版本的jar时，该jar可以随时进行生产。</font><font o="4449">例如你的jar版本看起来像这样（它建立在20.10.2016在20:15:21）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">1.0.0.20161020-201521-RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4450">在这种情况下，您生成的存根jar将看起来像这样。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">1.0.0.20161020-201521-RELEASE-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4451">在这种情况下，您应该在<code i="2311">application.yml</code>或<code i="2312">@AutoConfigureStubRunner</code>内引用存根提供最新版本的存根。</font><font o="4452">您可以通过传递<code i="2313">+</code>号来做到这一点。</font><font o="4453">例</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4454">如果版本控制是固定的（例如<code i="2314">1.0.4.RELEASE</code>或<code i="2315">2.1.1</code>），则必须设置jar版本的具体值。</font><font o="4455">示例2.1.1。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:2.1.1:stubs:8080"})</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_dev_or_prod_stubs"><font o="4456">开发者或生产者存根</font></h5>
<div class="paragraph">
<p><font o="4457">您可以操作分类器，以针对其他服务的存根或部署到生产的存根的当前开发版本来运行测试。</font><font o="4458">如果您在构建生产部署之后，使用<code i="2316">prod-stubs</code>分类器来更改构建部署，那么您可以在一个案例中使用dev stub运行测试，另一个则使用prod stub进行测试。</font></p>
</div>
<div class="paragraph">
<p><font o="4459">使用开发版存根的测试示例</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4460">使用生产版本的存根的测试示例</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:prod-stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4461">您也可以通过部署管道中的属性传递这些值。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_common_repo_with_contracts"><font o="4462">共同回购合同</font></h4>
<div class="paragraph">
<p><font o="4463">存储合同以外的另一种方法是将它们保存在一个共同的地方。</font><font o="4464">它可能与消费者无法克隆生产者代码的安全问题相关。</font><font o="4465">另外，如果您在一个地方保留合约，那么作为生产者，您将知道有多少消费者，以及您的本地变更会消费哪些消费者。</font></p>
</div>
<div class="sect4">
<h5 id="_repo_structure"><font o="4466">回购结构</font></h5>
<div class="paragraph">
<p><font o="4467">假设我们有一个坐标为<code i="2317">com.example:server</code>和3个消费者的生产者：<code i="2318">client1</code>，<code i="2319">client2</code>，<code i="2320">client3</code>。</font><font o="4468">然后在具有常见合同的存储库中，您将具有以下设置（您可以</font><a href="https://github.com/spring-cloud/spring-cloud-contract/tree/1.0.x/samples/standalone/contracts"><font o="4468">在此处查看</font></a><font o="4468">：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── com
│&nbsp;&nbsp; └── example
│&nbsp;&nbsp;     └── server
│&nbsp;&nbsp;         ├── client1
│&nbsp;&nbsp;         │&nbsp;&nbsp; └── expectation.groovy
│&nbsp;&nbsp;         ├── client2
│&nbsp;&nbsp;         │&nbsp;&nbsp; └── expectation.groovy
│&nbsp;&nbsp;         ├── client3
│&nbsp;&nbsp;         │&nbsp;&nbsp; └── expectation.groovy
│&nbsp;&nbsp;         └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4469">您可以看到下面的斜线分隔的groupid <code i="2321">/</code>工件id文件夹（<code i="2322">com/example/server</code>），您对3个消费者（<code i="2323">client1</code>，<code i="2324">client2</code>和<code i="2325">client3</code>）有期望。</font><font o="4470">期望是本文档中描述的标准Groovy DSL合同文件。</font><font o="4471">该存储库必须生成一个将一对一映射到回收内容的JAR文件。</font></p>
</div>
<div class="paragraph">
<p><font o="4472"><code i="2327">server</code>文件夹内的<code i="2326">pom.xml</code>示例。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;server&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Server Stubs&lt;/name&gt;
	&lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;1.5.0.BUILD-SNAPSHOT&lt;/version&gt;
		&lt;relativePath /&gt;
	&lt;/parent&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
		&lt;spring-cloud-contract.version&gt;1.1.0.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
		&lt;spring-cloud-dependencies.version&gt;Dalston.BUILD-SNAPSHOT&lt;/spring-cloud-dependencies.version&gt;
		&lt;excludeBuildFolders&gt;true&lt;/excludeBuildFolders&gt;
	&lt;/properties&gt;

	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
				&lt;type&gt;pom&lt;/type&gt;
				&lt;scope&gt;import&lt;/scope&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
				&lt;extensions&gt;true&lt;/extensions&gt;
				&lt;configuration&gt;
					&lt;!-- By default it would search under src/test/resources/ --&gt;
					&lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4473">你可以看到除了Spring Cloud Contract Maven插件之外没有依赖关系。</font><font o="4474">这些垃圾是消费者运行<code i="2328">mvn clean install -DskipTests</code>来本地安装生产者项目的存根的必要条件。</font></p>
</div>
<div class="paragraph">
<p><font o="4475">根文件夹中的<code i="2329">pom.xml</code>可以如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
	&lt;artifactId&gt;contracts&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Contracts&lt;/name&gt;
	&lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the producers to generate tests and stubs&lt;/description&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
	&lt;/properties&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;id&gt;contracts&lt;/id&gt;
						&lt;phase&gt;prepare-package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;single&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
							&lt;attach&gt;true&lt;/attach&gt;
							&lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
							&lt;!-- If you want an explicit classifier remove the following line --&gt;
							&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4476">它正在使用程序集插件来构建所有合同的JAR。</font><font o="4477">此类设置的示例如下：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
		  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;project&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.basedir}&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
			&lt;excludes&gt;
				&lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
				&lt;exclude&gt;mvnw&lt;/exclude&gt;
				&lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
				&lt;exclude&gt;.mvn/**&lt;/exclude&gt;
				&lt;exclude&gt;src/**&lt;/exclude&gt;
			&lt;/excludes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_workflow"><font o="4478">工作流程</font></h5>
<div class="paragraph">
<p><font o="4479">工作流程将与<code i="2330">Step by step guide to CDC</code>中提供的工作流程类似。</font><font o="4480">唯一的区别是生产者不再拥有合同。</font><font o="4481">所以消费者和生产者必须在共同的仓库中处理共同的合同。</font></p>
</div>
<div class="sect5">
<h6 id="_consumer"><font o="4482">消费者</font></h6>
<div class="paragraph">
<p><font o="4483">当</font><strong><font o="4483">消费者</font></strong><font o="4483">希望脱机工作，而不是克隆生产者代码时，消费者团队克隆了公用存储库，转到所需的生产者的文件夹（例如<code i="2331">com/example/server</code>），并运行<code i="2332">mvn clean install -DskipTests</code>在本地安装存根从合同转换。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4484">提示</font></div>
</td>
<td class="content"><font o="4485">
您需要在</font><a href="https://maven.apache.org/download.cgi"><font o="4485">本地</font></a><font o="4485">安装</font><a href="https://maven.apache.org/download.cgi"><font o="4485">Maven</font></a>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_producer"><font o="4486">制片人</font></h6>
<div class="paragraph">
<p><font o="4487">作为一个</font><strong><font o="4487">生产者</font></strong><font o="4487">，足以改变Spring Cloud Contract验证器来提供包含合同的URL和依赖关系：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;contractsRepositoryUrl&gt;http://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
		&lt;contractDependency&gt;
			&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
			&lt;artifactId&gt;contracts&lt;/artifactId&gt;
		&lt;/contractDependency&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4488">使用此设置，将从<code i="2335"><a href="http://link/to/your/nexus/or/artifactory/or/sth" class="bare">http://link/to/your/nexus/or/artifactory/or/sth</a></code>下载具有groupid <code i="2333">com.example.standalone</code>和artifactid <code i="2334">contracts</code>的JAR。</font><font o="4489">然后将在本地临时文件夹中解压缩，并将<code i="2336">com/example/server</code>下的合同作为用于生成测试和存根的选择。</font><font o="4490">由于这个惯例，生产者团队将会知道当一些不兼容的更改完成时，哪些消费者团队将被破坏。</font></p>
</div>
<div class="paragraph">
<p><font o="4491">其余的流程看起来是一样的。</font></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_can_i_have_multiple_base_classes_for_tests"><font o="4492">我可以有多个基类进行测试吗？</font></h4>
<div class="paragraph">
<p><font o="4493">是! </font><font o="4494">查看</font><font o="4494">Gradle或Maven插件的</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts"><font o="4494">合同</font></a><font o="4494">部分</font><font o="4494">的</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts"><font o="4494">不同基类</font></a><font o="4494">。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_how_can_i_debug_the_request_response_being_sent_by_the_generated_tests_client"><font o="4495">如何调试生成的测试客户端发送的请求/响应？</font></h4>
<div class="paragraph">
<p><font o="4496">生成的测试都以某种形式或时尚的方式依赖于</font><a href="https://hc.apache.org/httpcomponents-client-ga/"><font o="4496">Apache HttpClient进行RestAssured</font></a><font o="4496">。</font><font o="4497">HttpClient有一个名为</font><a href="https://hc.apache.org/httpcomponents-client-ga/logging.html#Wire_Logging"><font o="4497">wire logging的工具</font></a><font o="4497">，它将整个请求和响应记录到HttpClient。</font><font o="4498">Spring Boot有一个日志记录</font><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html"><font o="4498">通用应用程序属性</font></a><font o="4498">来做这种事情，只需将其添加到应用程序属性中即可</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-properties" data-lang="properties">logging.level.org.apache.http.wire=DEBUG</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_can_i_reference_the_request_from_the_response"><font o="4499">可以从响应中引用请求吗？</font></h4>
<div class="paragraph">
<p><font o="4500">是! </font><font o="4501">使用版本1.1.0，我们添加了这样一种可能性。</font><font o="4502">在HTTP存根服务器端，我们正在为WireMock提供支持。</font><font o="4503">在其他HTTP服务器存根的情况下，您必须自己实现该方法。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_verifier_http"><font o="4504">Spring Cloud Contract验证者HTTP</font></h3>
<div class="sect3">
<h4 id="_gradle_project"><font o="4505">毕业项目</font></h4>
<div class="sect4">
<h5 id="_prerequisites"><font o="4506">先决条件</font></h5>
<div class="paragraph">
<p><font o="4507">为了在WireMock中使用Spring Cloud Contract验证器，您必须使用Gradle或Maven插件。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4508">警告</font></div>
</td>
<td class="content"><font o="4509">
如果您想在项目中使用Spock，则必须单独添加<code i="2337">spock-core</code>和<code i="2338">spock-spring</code>模块。</font><font o="4510">检查</font><a href="https://spockframework.github.io/"><font o="4510">Spock文档以获取更多信息</font></a>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_add_gradle_plugin_with_dependencies"><font o="4511">添加具有依赖关系的渐变插件</font></h6>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
	    classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
		classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
	}
}

apply plugin: 'groovy'
apply plugin: 'spring-cloud-contract'

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${verifier_version}"
	}
}

dependencies {
	testCompile 'org.codehaus.groovy:groovy-all:2.4.6'
	// example with adding Spock core and Spock Spring
	testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
	testCompile 'org.spockframework:spock-spring:1.0-groovy-2.4'
	testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_snapshot_versions_for_gradle"><font o="4512">Gradle的快照版本</font></h6>
<div class="paragraph">
<p><font o="4513">将其他快照存储库添加到您的build.gradle以使用快照版本，每次成功构建后都会自动上传：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "http://repo.spring.io/snapshot" }
		maven { url "http://repo.spring.io/milestone" }
		maven { url "http://repo.spring.io/release" }
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_add_stubs"><font o="4514">添加存根</font></h6>
<div class="paragraph">
<p><font o="4515">默认情况下Spring Cloud Contract验证器正在<code i="2339">src/test/resources/contracts</code>目录中查找存根。</font></p>
</div>
<div class="paragraph">
<p><font o="4516">包含存根定义的目录被视为一个类名称，每个存根定义被视为单个测试。</font><font o="4517">我们假设它至少包含一个用作测试类名称的目录。</font><font o="4518">如果有多个级别的嵌套目录，除了最后一个级别将被用作包名称。</font><font o="4519">所以具有以下结构</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4520">Spring Cloud Contract验证程序将使用两种方法创建测试类<code i="2340">defaultBasePackage.MyService</code></font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shouldCreateUser()</code></p>
</li>
<li>
<p><code>shouldReturnUser()</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_run_plugin"><font o="4521">运行插件</font></h5>
<div class="paragraph">
<p><font o="4522">插件注册自己在<code i="2341">check</code>任务之前被调用。</font><font o="4523">只要您希望它成为构建过程的一部分，您就无所事事。</font><font o="4524">如果您只想生成测试，请调用<code i="2342">generateContractTests</code>任务。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_default_setup"><font o="4525">默认设置</font></h5>
<div class="paragraph">
<p><font o="4526">默认的Gradle插件设置创建了以下Gradle部分的构建（它是一个伪代码）</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">contracts {
    targetFramework = 'JUNIT'
    testMode = 'MockMvc'
    generatedTestSourcesDir = project.file("${project.buildDir}/generated-test-sources/contracts")
    contractsDslDir = "${project.rootDir}/src/test/resources/contracts"
    basePackageForTests = 'org.springframework.cloud.verifier.tests'
    stubsOutputDir = project.file("${project.buildDir}/stubs")

    // the following properties are used when you want to provide where the JAR with contract lays
    contractDependency {
        stringNotation = ''
    }
    contractsPath = ''
    contractsWorkOffline = false
}

tasks.create(type: Jar, name: 'verifierStubsJar', dependsOn: 'generateClientStubs') {
    baseName = project.name
    classifier = contracts.stubsSuffix
    from contractVerifier.stubsOutputDir
}

project.artifacts {
    archives task
}

tasks.create(type: Copy, name: 'copyContracts') {
    from contracts.contractsDslDir
    into contracts.stubsOutputDir
}

verifierStubsJar.dependsOn 'copyContracts'

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId project.name
            artifact verifierStubsJar
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configure_plugin"><font o="4527">配置插件</font></h5>
<div class="paragraph">
<p><font o="4528">要更改默认配置，只需在您的Gradle配置中添加<code i="2343">contracts</code>代码段即可</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">contracts {
	testMode = 'MockMvc'
	baseClassForTests = 'org.mycompany.tests'
	generatedTestSourcesDir = project.file('src/generatedContract')
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_configuration_options_4"><font o="4529">配置选项</font></h6>
<div class="ulist">
<ul>
<li>
<p><strong><font o="4530">testMode</font></strong><font o="4530"> - 定义接受测试的模式。</font><font o="4531">默认的基于Spring的MockMvc的MockMvc。</font><font o="4532">也可以将其更改为</font><strong><font o="4532">JaxRsClient</font></strong><font o="4532">或</font><strong><font o="4532">显式</font></strong><font o="4532">为真实的HTTP调用。</font></p>
</li>
<li>
<p><strong><font o="4533">导入</font></strong><font o="4533"> - 应包含在生成的测试中的</font><strong><font o="4533">导入的</font></strong><font o="4533">数组（例如['org.myorg.Matchers']）。</font><font o="4534">默认为空数组[]</font></p>
</li>
<li>
<p><strong><font o="4535">staticImports</font></strong><font o="4535"> - 应该包含在生成的测试中的静态导入的数组（例如['org.myorg.Matchers。*']）。</font><font o="4536">默认为空数组[]</font></p>
</li>
<li>
<p><strong><font o="4537">basePackageForTests</font></strong><font o="4537"> - 为所有生成的测试指定基础包。</font><font o="4538">默认设置为org.springframework.cloud.verifier.tests</font></p>
</li>
<li>
<p><strong><font o="4539">baseClassForTests</font></strong><font o="4539"> - 所有生成的测试的基类。</font><font o="4540">如果使用Spock测试，默认为<code i="2344">spock.lang.Specification</code>。</font></p>
</li>
<li>
<p><strong><font o="4541">packageWithBaseClasses</font></strong><font o="4541"> - 而不是为基类提供固定值，您可以提供一个所有基类放置的包。</font><font o="4542">优先于</font><strong><font o="4542">baseClassForTests</font></strong><font o="4542">。</font></p>
</li>
<li>
<p><strong><font o="4543">baseClassMappings</font></strong><font o="4543"> - 明确地将合约包映射到基类的FQN。</font><font o="4544">优先于</font><strong><font o="4544">packageWithBaseClasses</font></strong><font o="4544">和</font><strong><font o="4544">baseClassForTests</font></strong><font o="4544">。</font></p>
</li>
<li>
<p><strong><font o="4545">ruleClassForTests</font></strong><font o="4545"> - 指定应该添加到生成的测试类的规则。</font></p>
</li>
<li>
<p><strong><font o="4546">ignoredFiles</font></strong><font o="4546"> -  Ant匹配器，允许定义要跳过哪些处理的存根文件。</font><font o="4547">默认为空数组[]</font></p>
</li>
<li>
<p><strong><font o="4548">contractsDslDir</font></strong><font o="4548"> - 包含使用GroovyDSL编写的合同的目录。</font><font o="4549">默认<code i="2345">$rootDir/src/test/resources/contracts</code></font></p>
</li>
<li>
<p><strong><font o="4550">generatedTestSourcesDir</font></strong><font o="4550"> - 应该放置从Groovy DSL </font><strong><font o="4550">生成</font></strong><font o="4550">测试的测试源目录。</font><font o="4551">默认<code i="2346">$buildDir/generated-test-sources/contractVerifier</code></font></p>
</li>
<li>
<p><strong><font o="4552">stubsOutputDir</font></strong><font o="4552"> - 应该放置从Groovy DSL生成的WireMock存根的目录</font></p>
</li>
<li>
<p><strong><font o="4553">targetFramework</font></strong><font o="4553"> - 要使用的目标测试框架; </font><font o="4554">JUnit作为默认框架，目前支持Spock和JUnit</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4555">当您希望提供合同所在JAR的位置时，将使用以下属性</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font o="4556">contractDependency</font></strong><font o="4556"> - 提供<code i="2347">groupid:artifactid:version:classifier</code>坐标的依赖关系。</font><font o="4557">您可以使用<code i="2348">contractDependency</code>关闭来设置它</font></p>
</li>
<li>
<p><strong><font o="4558">contractPath</font></strong><font o="4558"> - 如果下载合同部分将默认为<code i="2349">groupid/artifactid</code>，其中<code i="2350">groupid</code>将被分隔。</font><font o="4559">否则将扫描提供的目录下的合同</font></p>
</li>
<li>
<p><strong><font o="4560">contractsWorkOffline</font></strong><font o="4560"> - 为了不下载依赖关系，每次下载一次，然后离线工作（重用本地Maven repo）</font></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_single_base_class_for_all_tests"><font o="4561">所有测试的单一基类</font></h6>
<div class="paragraph">
<p><font o="4562">在默认的MockMvc中使用Spring Cloud Contract验证器时，您需要为所有生成的验收测试创建一个基本规范。</font><font o="4563">在这个类中，您需要指向应验证的端点。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4564">在使用<code i="2351">Explicit</code>模式的情况下，您可以像普通集成测试一样使用基类来初始化整个测试的应用程序。</font><font o="4565">在<code i="2352">JAXRSCLIENT</code>模式的情况下，这个基类也应该包含<code i="2353">protected WebTarget webTarget</code>字段，现在测试JAX-RS API的唯一选项是启动Web服务器。</font></p>
</div>
</div>
<div class="sect5">
<h6 id="_different_base_classes_for_contracts"><font o="4566">不同的基础类别的合同</font></h6>
<div class="paragraph">
<p><font o="4567">如果您的基类在合同之间不同，您可以告诉Spring Cloud Contract插件哪个类应该由自动生成测试扩展。</font><font o="4568">你有两个选择：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4569">遵循约定，提供<code i="2354">packageWithBaseClasses</code></font></p>
</li>
<li>
<p><font o="4570">通过<code i="2355">baseClassMappings</code>提供显式映射</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><font o="4571">惯例</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4572">约定是这样的，如果你有合同，例如<code i="2356">src/test/resources/contract/foo/bar/baz/</code>，并将<code i="2357">packageWithBaseClasses</code>属性的值提供给<code i="2358">com.example.base</code>，那么我们将假设<code i="2360">com.example.base</code>下有一个<code i="2359">BarBazBase</code>类包。</font><font o="4573">换句话说，如果它们存在并且形成具有<code i="2361">Base</code>后缀的类，那么我们将使用最后两个包的部分。</font><font o="4574">优先于</font><strong><font o="4574">baseClassForTests</font></strong><font o="4574">。</font><font o="4575"><code i="2362">contracts</code>关闭中的使用示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">packageWithBaseClasses = 'com.example.base'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="4576">制图</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4577">您可以手动将合同包的正则表达式映射为匹配合同的基类的完全限定名称。</font><font o="4578">我们来看看下面的例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">baseClassForTests = "com.example.FooBase"
baseClassMappings {
	baseClassMapping('.*/com/.*', 'com.example.ComBase')
	baseClassMapping('.*/bar/.*':'com.example.BarBase')
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4579">我们假设你有合同 -  <code i="2363">src/test/resources/contract/com/</code>  -  <code i="2364">src/test/resources/contract/foo/</code></font></p>
</div>
<div class="paragraph">
<p><font o="4580">通过提供<code i="2365">baseClassForTests</code>，我们有一个后备案例，如果映射没有成功（您也可以提供<code i="2366">packageWithBaseClasses</code>作为备用）。</font><font o="4581">这样，从<code i="2367">src/test/resources/contract/com/</code>合同产生的测试将扩展<code i="2368">com.example.ComBase</code>，而其余的测试将扩展<code i="2369">com.example.FooBase</code>。</font></p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_invoking_generated_tests"><font o="4582">调用生成的测试</font></h5>
<div class="paragraph">
<p><font o="4583">为确保提供方对定义的合同进行投诉，您需要调用：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">./gradlew generateContractTests test</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spring_cloud_contract_verifier_on_consumer_side"><font o="4584">Spring Cloud Contract消费者验证者</font></h5>
<div class="paragraph">
<p><font o="4585">在消费者服务中，您需要以与提供商相同的方式配置Spring Cloud Contract验证器插件。</font><font o="4586">如果您不想使用Stub Runner，则需要复制存储在<code i="2370">src/test/resources/contracts</code>中的合同，并使用以下命令生成WireMock json存根：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">./gradlew generateClientStubs</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4587">请注意，必须为存根生成设置<code i="2371">stubsOutputDir</code>选项才能正常工作。</font></p>
</div>
<div class="paragraph">
<p><font o="4588">当存在时，json存根可用于消费者自动测试。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(loader == SpringApplicationContextLoader, classes == Application)
class LoanApplicationServiceSpec extends Specification {

 @ClassRule
 @Shared
 WireMockClassRule wireMockRule == new WireMockClassRule()

 @Autowired
 LoanApplicationService sut

 def 'should successfully apply for loan'() {
   given:
 	LoanApplication application =
			new LoanApplication(client: new Client(clientPesel: '12345678901'), amount: 123.123)
   when:
	LoanApplicationResult loanApplication == sut.loanApplication(application)
   then:
	loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLIED
	loanApplication.rejectionReason == null
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4589">在LoanApplication下面调用FraudDetection服务。</font><font o="4590">此请求由使用由Spring Cloud Contract验证器生成的存根配置的WireMock服务器处理。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_in_your_maven_project"><font o="4591">在您的Maven项目中使用</font></h4>
<div class="sect4">
<h5 id="_add_maven_plugin"><font o="4592">添加maven插件</font></h5>
<div class="paragraph">
<p><font o="4593">添加Spring Cloud Contract BOM</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4594">接下来，<code i="2372">Spring Cloud Contract Verifier</code> Maven插件</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4595">您可以在</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/"><font o="4595">Spring Cloud Contract Maven插件文档</font></a><font o="4595">中阅读更多内容</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/"><font></font></a></p>
</div>
<div class="sect5">
<h6 id="_snapshot_versions_for_maven"><font o="4596">Maven的快照版本</font></h6>
<div class="paragraph">
<p><font o="4597">对于快照/里程碑版本，您必须将以下部分添加到您的<code i="2373">pom.xml</code></font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_add_stubs_2"><font o="4598">添加存根</font></h5>
<div class="paragraph">
<p><font o="4599">默认情况下Spring Cloud Contract验证器正在<code i="2374">src/test/resources/contracts</code>目录中查找存根。</font><font o="4600">包含存根定义的目录被视为一个类名称，每个存根定义被视为单个测试。</font><font o="4601">我们假设它至少包含一个用作测试类名称的目录。</font><font o="4602">如果有多个级别的嵌套目录，除了最后一个级别将被用作包名称。</font><font o="4603">所以具有以下结构</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4604">Spring Cloud Contract验证者将使用两种方法创建测试类<code i="2375">defaultBasePackage.MyService</code>  -  <code i="2376">shouldCreateUser()</code>  -  <code i="2377">shouldReturnUser()</code></font></p>
</div>
</div>
<div class="sect4">
<h5 id="_run_plugin_2"><font o="4605">运行插件</font></h5>
<div class="paragraph">
<p><font o="4606">插件目标<code i="2378">generateTests</code>被分配为阶段<code i="2379">generate-test-sources</code>。</font><font o="4607">只要您希望它成为构建过程的一部分，您就无所事事。</font><font o="4608">如果您只想生成测试，请调用<code i="2380">generateTests</code>目标。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_configure_plugin_2"><font o="4609">配置插件</font></h5>
<div class="paragraph">
<p><font o="4610">要更改默认配置，只需将<code i="2381">configuration</code>部分添加到插件定义或<code i="2382">execution</code>定义。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
                &lt;goal&gt;generateTests&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;basePackageForTests&gt;org.springframework.cloud.verifier.twitter.place&lt;/basePackageForTests&gt;
        &lt;baseClassForTests&gt;org.springframework.cloud.verifier.twitter.place.BaseMockMvcSpec&lt;/baseClassForTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_important_configuration_options"><font o="4611">重要配置选项</font></h6>
<div class="ulist">
<ul>
<li>
<p><strong><font o="4612">testMode</font></strong><font o="4612"> - 定义接受测试的模式。</font><font o="4613">默认<code i="2383">MockMvc</code>，它基于Spring的MockMvc。</font><font o="4614">对于真正的HTTP呼叫，它也可以更改为<code i="2384">JaxRsClient</code>或<code i="2385">Explicit</code>。</font></p>
</li>
<li>
<p><strong><font o="4615">basePackageForTests</font></strong><font o="4615"> - 为所有生成的测试指定基础包。</font><font o="4616">默认设置为<code i="2386">org.springframework.cloud.verifier.tests</code>。</font></p>
</li>
<li>
<p><strong><font o="4617">ruleClassForTests</font></strong><font o="4617"> - 指定应该添加到生成的测试类的规则。</font></p>
</li>
<li>
<p><strong><font o="4618">baseClassForTests</font></strong><font o="4618"> - 生成测试的基类。</font><font o="4619">如果使用Spock测试，默认为<code i="2387">spock.lang.Specification</code>。</font></p>
</li>
<li>
<p><strong><font o="4620">contractDir</font></strong><font o="4620"> - 包含使用GroovyDSL编写的合同的目录。</font><font o="4621">默认<code i="2388">/src/test/resources/contracts</code>。</font></p>
</li>
<li>
<p><strong><font o="4622">testFramework</font></strong><font o="4622"> - 要使用的目标测试框架; </font><font o="4623">JUnit作为默认框架，目前支持Spock和JUnit</font></p>
</li>
<li>
<p><strong><font o="4624">packageWithBaseClasses</font></strong><font o="4624"> - 而不是为基类提供固定值，您可以提供一个所有基类放置的包。</font><font o="4625">约定是这样的，如果你有合同<code i="2389">src/test/resources/contract/foo/bar/baz/</code>，并提供这个属性的值到<code i="2390">com.example.base</code>，那么我们将假设<code i="2392">com.example.base</code>包含<code i="2392">com.example.base</code>类。</font><font o="4626">优先于</font><strong><font o="4626">baseClassForTests</font></strong></p>
</li>
<li>
<p><strong><font o="4627">baseClassMappings</font></strong><font o="4627"> - 您必须提供<code i="2393">contractPackageRegex</code>的基类映射列表，该列表根据合同所在的包进行检查，并且<code i="2394">baseClassFQN</code>映射到匹配合同的基类的完全限定名称。</font><font o="4628">如果您有合同<code i="2395">src/test/resources/contract/foo/bar/baz/</code>并映射了属性<code i="2396">.*</code>→<code i="2397">com.example.base.BaseClass</code>，则从这些合同生成的测试类将扩展<code i="2398">com.example.base.BaseClass</code>。</font><font o="4629">优先于</font><strong><font o="4629">packageWithBaseClasses</font></strong><font o="4629"> 
 和</font><strong><font o="4629">baseClassForTests</font></strong><font o="4629">。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4630">如果要从Maven存储库中下载合同定义，可以使用</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><font o="4631">contractsRepositoryUrl</font></strong><font o="4631"> - 具有合同的工件的repo的URL（如果没有提供）应使用当前的Maven</font></p>
</li>
<li>
<p><strong><font o="4632">contractDependency</font></strong><font o="4632"> - 包含所有打包合同的合同依赖关系</font></p>
</li>
<li>
<p><strong><font o="4633">contractPath</font></strong><font o="4633"> - 通过打包合同在JAR中具体合同的路径。</font><font o="4634">默认为<code i="2399">groupid/artifactid</code>，其中<code i="2400">gropuid</code>被斜杠分隔。</font></p>
</li>
<li>
<p><strong><font o="4635">contractWorkOffline</font></strong><font o="4635"> - 如果依赖关系应该被下载，或者本地Maven只能被重用</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4636">有关完整信息，请参阅</font><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/plugin-info.html"><font o="4636">插件文档</font></a></p>
</div>
</div>
<div class="sect5">
<h6 id="_single_base_class_for_all_tests_2"><font o="4637">所有测试的单一基类</font></h6>
<div class="paragraph">
<p><font o="4638">在默认的MockMvc中使用Spring Cloud Contract验证器时，您需要为所有生成的验收测试创建一个基本规范。</font><font o="4639">在这个类中，您需要指向应验证的端点。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.mycompany.tests

import org.mycompany.ExampleSpringController
import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc
import spock.lang.Specification

class  MvcSpec extends Specification {
  def setup() {
   RestAssuredMockMvc.standaloneSetup(new ExampleSpringController())
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4640">在使用<code i="2401">Explicit</code>模式的情况下，您可以像常规集成测试一样使用基类来初始化整个测试的应用程序。</font><font o="4641">在<code i="2402">JAXRSCLIENT</code>模式的情况下，这个基类也应该包含<code i="2403">protected WebTarget webTarget</code>字段，现在测试JAX-RS API的唯一选项是启动Web服务器。</font></p>
</div>
</div>
<div class="sect5">
<h6 id="_different_base_classes_for_contracts_2"><font o="4642">不同的基础类别的合同</font></h6>
<div class="paragraph">
<p><font o="4643">如果您的基类在合同之间不同，您可以告诉Spring Cloud Contract插件哪个类应该由自动生成测试扩展。</font><font o="4644">你有两个选择：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4645">遵循约定，提供<code i="2404">packageWithBaseClasses</code></font></p>
</li>
<li>
<p><font o="4646">通过<code i="2405">baseClassMappings</code>提供显式映射</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><font o="4647">惯例</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4648">约定是这样的，如果你有合同，例如<code i="2406">src/test/resources/contract/hello/v1/</code>，并将<code i="2407">packageWithBaseClasses</code>属性的值提供给<code i="2408">hello</code>，那么我们将假设在<code i="2410">hello</code>下有一个<code i="2409">HelloV1Base</code>类包。</font><font o="4649">换句话说，如果它们存在并且形成具有<code i="2411">Base</code>后缀的类，那么我们将使用最后两个包的部分。</font><font o="4650">优先于</font><strong><font o="4650">baseClassForTests</font></strong><font o="4650">。</font><font o="4651">使用示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;hello&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="4652">制图</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4653">您可以手动将合同包的正则表达式映射为匹配合同的基类的完全限定名称。</font><font o="4654">您必须提供<code i="2412">baseClassMappings</code> <code i="2413">baseClassMapping</code>的<code i="2414">contractPackageRegex</code>列表<code i="2414">contractPackageRegex</code>到<code i="2415">baseClassFQN</code>映射。</font><font o="4655">我们来看看下面的例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;baseClassForTests&gt;com.example.FooBase&lt;/baseClassForTests&gt;
		&lt;baseClassMappings&gt;
			&lt;baseClassMapping&gt;
				&lt;contractPackageRegex&gt;.*com.*&lt;/contractPackageRegex&gt;
				&lt;baseClassFQN&gt;com.example.TestBase&lt;/baseClassFQN&gt;
			&lt;/baseClassMapping&gt;
		&lt;/baseClassMappings&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4656">我们假设你有合同 -  <code i="2416">src/test/resources/contract/com/</code>  -  <code i="2417">src/test/resources/contract/foo/</code></font></p>
</div>
<div class="paragraph">
<p><font o="4657">通过提供<code i="2418">baseClassForTests</code>，我们有一个后备程序，如果映射没有成功（你也可以提供<code i="2419">packageWithBaseClasses</code>作为备用）。</font><font o="4658">这样，从<code i="2420">src/test/resources/contract/com/</code>合同生成的测试将扩展<code i="2421">com.example.ComBase</code>，而其余的测试将扩展<code i="2422">com.example.FooBase</code>。</font></p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_invoking_generated_tests_2"><font o="4659">调用生成的测试</font></h5>
<div class="paragraph">
<p><font o="4660">Spring Cloud Contract Maven插件将验证码生成到目录<code i="2423">/generated-test-sources/contractVerifier</code>中，并将此目录附加到<code i="2424">testCompile</code>目标。</font></p>
</div>
<div class="paragraph">
<p><font o="4661">对于Groovy Spock代码使用：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.codehaus.gmavenplus&lt;/groupId&gt;
	&lt;artifactId&gt;gmavenplus-plugin&lt;/artifactId&gt;
	&lt;version&gt;1.5&lt;/version&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;goals&gt;
				&lt;goal&gt;testCompile&lt;/goal&gt;
			&lt;/goals&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
	&lt;configuration&gt;
		&lt;testSources&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.basedir}/src/test/groovy&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
			&lt;testSource&gt;
				&lt;directory&gt;${project.build.directory}/generated-test-sources/contractVerifier&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.groovy&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/testSource&gt;
		&lt;/testSources&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4662">为了确保提供方对定义的合同进行投诉，您需要调用<code i="2425">mvn generateTest test</code></font></p>
</div>
</div>
<div class="sect4">
<h5 id="_faq_with_maven_plugin"><font o="4663">Maven插件常见问题</font></h5>
<div class="sect5">
<h6 id="_maven_plugin_and_sts"><font o="4664">Maven插件和STS</font></h6>
<div class="paragraph">
<p><font o="4665">如果在使用STS时看到以下异常</font></p>
</div>
<div class="imageblock">
<div class="content">
<img src="./Spring Cloud Dalston 中文文档 参考手册 中文版_files/sts_exception.png" alt="STS异常">
</div>
</div>
<div class="paragraph">
<p><font o="4666">当您点击标记时，您应该看到这样的sth</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash"> plugin:1.1.0.M1:convert:default-convert:process-test-resources) org.apache.maven.plugin.PluginExecutionException: Execution default-convert of goal org.springframework.cloud:spring-
 cloud-contract-maven-plugin:1.1.0.M1:convert failed. at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:145) at
 org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:331) at org.eclipse.m2e.core.internal.embedder.MavenImpl$11.call(MavenImpl.java:1362) at
...
 org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Caused by: java.lang.NullPointerException at
 org.eclipse.m2e.core.internal.builder.plexusbuildapi.EclipseIncrementalBuildContext.hasDelta(EclipseIncrementalBuildContext.java:53) at
 org.sonatype.plexus.build.incremental.ThreadBuildContext.hasDelta(ThreadBuildContext.java:59) at</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4667">为了解决这个问题，请在<code i="2426">pom.xml</code>中提供以下部分</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;pluginManagement&gt;
        &lt;plugins&gt;
            &lt;!--This plugin's configuration is used to store Eclipse m2e settings
                only. It has no influence on the Maven build itself. --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;
                &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;lifecycleMappingMetadata&gt;
                        &lt;pluginExecutions&gt;
                             &lt;pluginExecution&gt;
                                &lt;pluginExecutionFilter&gt;
                                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                                    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
                                    &lt;versionRange&gt;[1.0,)&lt;/versionRange&gt;
                                    &lt;goals&gt;
                                        &lt;goal&gt;convert&lt;/goal&gt;
                                    &lt;/goals&gt;
                                &lt;/pluginExecutionFilter&gt;
                                &lt;action&gt;
                                    &lt;execute /&gt;
                                &lt;/action&gt;
                             &lt;/pluginExecution&gt;
                        &lt;/pluginExecutions&gt;
                    &lt;/lifecycleMappingMetadata&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_spring_cloud_contract_verifier_on_consumer_side_2"><font o="4668">Spring Cloud Contract消费者验证者</font></h5>
<div class="paragraph">
<p><font o="4669">您实际上也可以为消费者使用Spring Cloud Contract验证器！</font><font o="4670">您可以使用插件，以便只转换合同并生成存根。</font><font o="4671">要实现这一点，您需要以与提供程序相同的方式配置Spring Cloud Contract验证程序插件。</font><font o="4672">您需要复制存储在<code i="2427">src/test/resources/contracts</code>中的合同，并使用以下命令生成WireMock json存根：<code i="2428">mvn generateStubs</code>命令。</font><font o="4673">默认生成的WireMock映射存储在目录<code i="2429">target/mappings</code>中。</font><font o="4674">您的项目应该从此生成的映射创建附加工件与分类器<code i="2430">stubs</code>，以便轻松部署到maven存储库。</font></p>
</div>
<div class="paragraph">
<p><font o="4675">样品配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${verifier-plugin.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;convert&lt;/goal&gt;
                &lt;goal&gt;generateStubs&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4676">当存在时，json存根可用于消费者自动测试。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureStubRunner
public class LoanApplicationServiceTests {

  @Autowired
  LoanApplicationService service;

  @Test
  public void shouldSuccessfullyApplyForLoan() {
    //given:
 	LoanApplication application =
			new LoanApplication(new Client("12345678901"), 123.123);
    //when:
	LoanApplicationResult loanApplication = service.loanApplication(application);
    // then:
	assertThat(loanApplication.loanApplicationStatus).isEqualTo(LoanApplicationStatus.LOAN_APPLIED);
	assertThat(loanApplication.rejectionReason).isNull();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4677"><code i="2431">LoanApplication</code>下方致电<code i="2432">FraudDetection</code>服务。</font><font o="4678">此请求由使用Spring Cloud Contract验证器生成的存根配置的WireMock服务器进行处理。</font></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_scenarios"><font o="4679">方案</font></h4>
<div class="paragraph">
<p><font o="4680">可以使用Spring Cloud Contract验证程序处理场景。</font><font o="4681">所有您需要做的是在创建合同时坚持正确的命名约定。</font><font o="4682">公约要求包括后面是下划线的订单号。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>my_contracts_dir\
  scenario1\
    1_login.groovy
    2_showCart.groovy
    3_logout.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4683">这样的树将导致Spring Cloud Contract验证器生成名为<code i="2433">scenario1</code>的WireMock场景和三个步骤：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4684">登录标记为<code i="2434">Started</code>，指向：</font></p>
</li>
<li>
<p><font o="4685">showCart标记为<code i="2435">Step1</code>指向：</font></p>
</li>
<li>
<p><font o="4686">注销标记为<code i="2436">Step2</code>，这将关闭场景。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4687">有关WireMock场景的更多详细信息，请参见</font><a href="http://wiremock.org/stateful-behaviour.html"><font o="4687">http://wiremock.org/stateful-behaviour.html</font></a></p>
</div>
<div class="paragraph">
<p><font o="4688">Spring Cloud Contract验证者还将生成具有保证执行顺序的测试。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_stubs_and_transitive_dependencies"><font o="4689">存根和传递依赖</font></h4>
<div class="paragraph">
<p><font o="4690">我们创建的Maven和Gradle插件是为您添加创建存根jar的任务。</font><font o="4691">可能有问题的是，当重用存根时，您可以错误地导入所有这些存根依赖关系！</font><font o="4692">即使你有几个不同的罐子，建造一个Maven的工件，他们都有一个pom：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075506-1-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar
├── github-webhook-0.0.1.BUILD-20160903.075655-2-stubs.jar.sha1
├── github-webhook-0.0.1.BUILD-SNAPSHOT.jar
├── github-webhook-0.0.1.BUILD-SNAPSHOT.pom
├── github-webhook-0.0.1.BUILD-SNAPSHOT-stubs.jar
├── ...
└── ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4693">使用这些依赖关系有三种可能性，以便不会对传递依赖性产生任何问题。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4694">将所有应用程序依赖项标记为可选</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4695">如果在<code i="2437">github-webhook</code>应用程序中，我们将所有的依赖项标记为可选的，当您将<code i="2438">github-webhook</code>存根包含在另一个应用程序中（或者当依赖关系由Stub Runner下载）时，因为所有的依赖关系是可选的，它们不会被下载。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4696">为存根创建一个单独的artifactid</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4697">如果你创建一个单独的artifactid，那么你可以设置任何你想要的方式。</font><font o="4698">例如通过没有依赖关系。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="4699">排除消费者方面的依赖关系</font></strong></p>
</div>
<div class="paragraph">
<p><font o="4700">作为消费者，如果将stub依赖关系添加到类路径中，则可以显式排除不需要的依赖关系。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_verifier_messaging"><font o="4701">Spring Cloud Contract验证器消息</font></h3>
<div class="paragraph">
<p><font o="4702">Spring Cloud Contract验证器允许您验证使用消息传递作为通信方式的应用程序。</font><font o="4703">我们所有的集成都使用Spring，但您也可以自己创建并使用它。</font></p>
</div>
<div class="sect3">
<h4 id="_integrations_2"><font o="4704">集成</font></h4>
<div class="paragraph">
<p><font o="4705">您可以使用四种集成配置之一：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4706">Apache Camel</font></p>
</li>
<li>
<p>Spring Integration</p>
</li>
<li>
<p><font o="4708">Spring Cloud Stream</font></p>
</li>
<li>
<p><font o="4709">Spring AMQP</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4710">由于我们使用Spring Boot，因此如果您已经将上述的一个库添加到类路径中，那么将自动设置所有的消息传递配置。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4711">重要</font></div>
</td>
<td class="content"><font o="4712">
记住将<code i="2439">@AutoConfigureMessageVerifier</code>放在生成的测试的基类上。</font><font o="4713">否则Spring Cloud Contract验证器的消息传递部分将无法正常工作。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_manual_integration_testing"><font o="4714">手动集成测试</font></h4>
<div class="paragraph">
<p><font o="4715">测试使用的主界面是<code i="2440">org.springframework.cloud.contract.verifier.messaging.MessageVerifier</code>。</font><font o="4716">它定义了如何发送和接收消息。</font><font o="4717">您可以创建自己的实现来实现相同的目标。</font></p>
</div>
<div class="paragraph">
<p><font o="4718">在测试中，您可以注册<code i="2441">ContractVerifierMessageExchange</code>发送和接收遵循合同的消息。</font><font o="4719">然后将<code i="2442">@AutoConfigureMessageVerifier</code>添加到您的测试中，例如</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureMessageVerifier
public static class MessagingContractTests {

  @Autowired
  private MessageVerifier verifier;
  ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4720">注意</font></div>
</td>
<td class="content"><font o="4721">
如果您的测试也需要存根，则<code i="2443">@AutoConfigureStubRunner</code>包括消息传递配置，因此您只需要一个注释。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_publisher_side_test_generation"><font o="4722">发行人端测试一代</font></h4>
<div class="paragraph">
<p><font o="4723">在您的DSL中拥有<code i="2444">input</code>或<code i="2445">outputMessage</code>部分将导致在发布商方面创建测试。</font><font o="4724">默认情况下，将创建JUnit测试，但是也可以创建Spock测试。</font></p>
</div>
<div class="paragraph">
<p><font o="4725">我们应该考虑三个主要场景：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4726">情况1：没有输入消息产生输出消息。</font><font o="4727">输出消息由应用程序内部的组件触发（例如调度程序）</font></p>
</li>
<li>
<p><font o="4728">情况2：输入消息触发输出消息</font></p>
</li>
<li>
<p><font o="4729">方案3：输入消息被消耗，没有输出消息</font></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message"><font o="4730">情景1（无输入讯息）</font></h5>
<div class="paragraph">
<p><font o="4731">对于给定的合同：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('activemq:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4732">将创建以下JUnit测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
 // when:
  bookReturnedTriggered();

 // then:
  ContractVerifierMessage response = contractVerifierMessaging.receive("activemq:output");
  assertThat(response).isNotNull();
  assertThat(response.getHeader("BOOK-NAME")).isEqualTo("foo");
 // and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4733">并且将创建以下Spock测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
 when:
  bookReturnedTriggered()

 then:
  ContractVerifierMessage response = contractVerifierMessaging.receive('activemq:output')
  assert response != null
  response.getHeader('BOOK-NAME')  == 'foo'
 and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
  assertThatJson(parsedJson).field("bookName").isEqualTo("foo")

'''</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input"><font o="4734">情景2（输入触发输出）</font></h5>
<div class="paragraph">
<p><font o="4735">对于给定的合同：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4736">将创建以下JUnit测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
  "{\\"bookName\\":\\"foo\\"}"
, headers()
  .header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:input");

// then:
 ContractVerifierMessage response = contractVerifierMessaging.receive("jms:output");
 assertThat(response).isNotNull();
 assertThat(response.getHeader("BOOK-NAME")).isEqualTo("foo");
// and:
 DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
 assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4737">并且将创建以下Spock测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">"""\
given:
   ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
    '''{"bookName":"foo"}''',
    ['sample': 'header']
  )

when:
   contractVerifierMessaging.send(inputMessage, 'jms:input')

then:
   ContractVerifierMessage response = contractVerifierMessaging.receive('jms:output')
   assert response !- null
   response.getHeader('BOOK-NAME')  == 'foo'
and:
   DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
   assertThatJson(parsedJson).field("bookName").isEqualTo("foo")
"""</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_no_output_message"><font o="4738">情景3（无输出讯息）</font></h5>
<div class="paragraph">
<p><font o="4739">对于给定的合同：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def contractDsl = Contract.make {
	label 'some_label'
	input {
		messageFrom('jms:delete')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
		assertThat('bookWasDeleted()')
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4740">将创建以下JUnit测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
// given:
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
	"{\\"bookName\\":\\"foo\\"}"
, headers()
	.header("sample", "header"));

// when:
 contractVerifierMessaging.send(inputMessage, "jms:delete");

// then:
 bookWasDeleted();
'''</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4741">并且将创建以下Spock测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
given:
	 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
		\'\'\'{"bookName":"foo"}\'\'\',
		['sample': 'header']
	)

when:
	 contractVerifierMessaging.send(inputMessage, 'jms:delete')

then:
	 noExceptionThrown()
	 bookWasDeleted()
'''</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_stub_side_generation"><font o="4742">消费者存根侧代</font></h4>
<div class="paragraph">
<p><font o="4743">与HTTP部分不同 - 在消息传递中，我们需要使用存根发布JAR中的Groovy DSL。</font><font o="4744">然后在消费者端进行解析，创建适当的stubbed路由。</font></p>
</div>
<div class="paragraph">
<p><font o="4745">有关更多信息，请参阅Stub Runner消息部分。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="4746">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
	&lt;/dependency&gt;

	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
		&lt;artifactId&gt;spring-cloud-stream-test-support&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;Dalston.BUILD-SNAPSHOT&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="4747">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner</h3>
<div class="paragraph">
<p><font o="4749">使用Spring Cloud Contract验证程序时可能遇到的一个问题是将生成的WireMock JSON存根从服务器端传递到客户端（或各种客户端）。</font><font o="4750">在消息传递的客户端生成方面也是如此。</font></p>
</div>
<div class="paragraph">
<p><font o="4751">复制JSON文件/手动设置客户端进行消息传递是不成问题的。</font></p>
</div>
<div class="paragraph">
<p><font o="4752">这就是为什么我们会介绍可以为您自动下载和运行存根的Spring Cloud Contract Stub Runner。</font></p>
</div>
<div class="sect3">
<h4 id="_snapshot_versions"><font o="4753">快照版本</font></h4>
<div class="paragraph">
<p><font o="4754">将其他快照存储库添加到您的build.gradle以使用快照版本，每次成功构建后都会自动上传：</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="4755">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
&lt;pluginRepositories&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshots&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;true&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
	&lt;pluginRepository&gt;
		&lt;id&gt;spring-releases&lt;/id&gt;
		&lt;name&gt;Spring Releases&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
		&lt;snapshots&gt;
			&lt;enabled&gt;false&lt;/enabled&gt;
		&lt;/snapshots&gt;
	&lt;/pluginRepository&gt;
&lt;/pluginRepositories&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="4756">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url "http://repo.spring.io/snapshot" }
		maven { url "http://repo.spring.io/milestone" }
		maven { url "http://repo.spring.io/release" }
	}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_publishing_stubs_as_jars"><font o="4757">将存根发布为JAR</font></h4>
<div class="paragraph">
<p><font o="4758">最简单的方法是集中保留存根的方式。</font><font o="4759">例如，您可以将它们作为JAR存储在Maven存储库中。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4760">提示</font></div>
</td>
<td class="content"><font o="4761">
对于Maven和Gradle来说，安装程序都是开箱即用的。</font><font o="4762">但是如果你想要的话可​​以自定义它。
</font></td>
</tr>
</tbody></table>
</div>
<div class="listingblock primary">
<div class="title"><font o="4763">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;!-- First disable the default jar setup in the properties section--&gt;
&lt;!-- we don't want the verifier to do a jar for us --&gt;
&lt;spring.cloud.contract.verifier.skip&gt;true&lt;/spring.cloud.contract.verifier.skip&gt;

&lt;!-- Next add the assembly plugin to your build --&gt;
&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;id&gt;stub&lt;/id&gt;
			&lt;phase&gt;prepare-package&lt;/phase&gt;
			&lt;goals&gt;
				&lt;goal&gt;single&lt;/goal&gt;
			&lt;/goals&gt;
			&lt;inherited&gt;false&lt;/inherited&gt;
			&lt;configuration&gt;
				&lt;attach&gt;true&lt;/attach&gt;
				&lt;descriptor&gt;$/Users/sgibb/workspace/spring/spring-cloud-samples/scripts/docs/../src/assembly/stub.xml&lt;/descriptor&gt;
			&lt;/configuration&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
&lt;/plugin&gt;

&lt;!-- Finally setup your assembly. Below you can find the contents of src/main/assembly/stub.xml --&gt;
&lt;assembly
	xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;stubs&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;src/main/java&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/classes&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**com/example/model/*.*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.build.directory}/snippets/stubs&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;$/Users/sgibb/workspace/spring/spring-cloud-samples/scripts/docs/../src/test/resources/contracts&lt;/directory&gt;
			&lt;outputDirectory&gt;META-INF/${project.groupId}/${project.artifactId}/${project.version}/contracts&lt;/outputDirectory&gt;
			&lt;includes&gt;
				&lt;include&gt;**/*.groovy&lt;/include&gt;
			&lt;/includes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="4764">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">ext {
	contractsDir = file("mappings")
	stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId "${project.name}-stubs"
			artifact verifierStubsJar
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modules"><font o="4765">模块</font></h4>

</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_core"><font o="4766">Stub Runner核心</font></h3>
<div class="paragraph">
<p><font o="4767">为服务合作者运行存根。</font><font o="4768">作为服务合同处理存根允许使用stub-runner作为
 </font><a href="http://martinfowler.com/articles/consumerDrivenContracts.html"><font o="4768">Consumer Driven Contracts的实现</font></a><font o="4768">。</font></p>
</div>
<div class="paragraph">
<p><font o="4769">Stub Runner允许您自动下载提供的依赖项的存根，为其启动WireMock服务器，并为其提供适当的存根定义。</font><font o="4770">对于消息传递，定义了特殊的存根路由。</font></p>
</div>
<div class="sect3">
<h4 id="_running_stubs"><font o="4771">运行存根</font></h4>
<div class="sect4">
<h5 id="_limitations"><font o="4772">限制</font></h5>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4773">重要</font></div>
</td>
<td class="content"><font o="4774">
StubRunner可能会在测试之间关闭端口时出现问题。</font><font o="4775">您可能会遇到您遇到端口冲突的情况。</font><font o="4776">只要您在测试中使用相同的上下文，一切正常。</font><font o="4777">但是当上下文不同（例如不同的存根或不同的配置文件）时，您必须使用<code i="2446">@DirtiesContext</code>关闭存根服务器，否则在每个测试的不同端口上运行它们。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_running_using_main_app"><font o="4778">运行使用主应用程序</font></h5>
<div class="paragraph">
<p><font o="4779">您可以将以下选项设置为主类：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">-c, --classifier                Suffix for the jar containing stubs (e.
                                  g. 'stubs' if the stub jar would
                                  have a 'stubs' classifier for stubs:
                                  foobar-stubs ). Defaults to 'stubs'
                                  (default: stubs)
--maxPort, --maxp &lt;Integer&gt;     Maximum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  15000 (default: 15000)
--minPort, --minp &lt;Integer&gt;     Minimum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  10000 (default: 10000)
-p, --password                  Password to user when connecting to
                                  repository
--phost, --proxyHost            Proxy host to use for repository
                                  requests
--pport, --proxyPort [Integer]  Proxy port to use for repository
                                  requests
-r, --root                      Location of a Jar containing server
                                  where you keep your stubs (e.g. http:
                                  //nexus.
                                  net/content/repositories/repository)
-s, --stubs                     Comma separated list of Ivy
                                  representation of jars with stubs.
                                  Eg. groupid:artifactid1,groupid2:
                                  artifactid2:classifier
-u, --username                  Username to user when connecting to
                                  repository
--wo, --workOffline             Switch to work offline. Defaults to
                                  'false'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_http_stubs"><font o="4780">HTTP存根</font></h5>
<div class="paragraph">
<p><font o="4781">存根在JSON文档中定义，其语法在</font><a href="http://wiremock.org/stubbing.html"><font o="4781">WireMock文档</font></a><font o="4781">中定义</font><a href="http://wiremock.org/stubbing.html"><font></font></a></p>
</div>
<div class="paragraph">
<p><font o="4782">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-javascript" data-lang="javascript">{
    "request": {
        "method": "GET",
        "url": "/ping"
    },
    "response": {
        "status": 200,
        "body": "pong",
        "headers": {
            "Content-Type": "text/plain"
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_viewing_registered_mappings"><font o="4783">查看注册的映射</font></h5>
<div class="paragraph">
<p><font o="4784">每个stubbed协作者公开<code i="2447">__/admin/</code>端点下定义的映射列表。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_messaging_stubs"><font o="4785">消息存根</font></h5>
<div class="paragraph">
<p><font o="4786">根据提供的Stub Runner依赖关系和DSL，消息路由将自动设置。</font></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_junit_rule"><font o="4787">Stub Runner JUnit规则</font></h3>
<div class="paragraph">
<p><font o="4788">Stub Runner附带一个JUnit规则，感谢您可以轻松地下载和运行给定组和工件ID的存根：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer");</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4789">该规则执行后Stub Runner连接到您的Maven存储库，给定的依赖关系列表尝试：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4790">下载它们</font></p>
</li>
<li>
<p><font o="4791">在本地缓存</font></p>
</li>
<li>
<p><font o="4792">将它们解压缩到临时文件夹</font></p>
</li>
<li>
<p><font o="4793">从提供的端口/提供的端口范围的随机端口上为每个Maven依赖关系启动WireMock服务器</font></p>
</li>
<li>
<p><font o="4794">为WireMock服务器提供所有具有有效WireMock定义的JSON文件</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4795">Stub Runner使用</font><a href="https://wiki.eclipse.org/Aether"><font o="4795">Eclipse Aether</font></a><font o="4795">机制下载Maven依赖关系。</font><font o="4796">查看他们的</font><a href="https://wiki.eclipse.org/Aether"><font o="4796">文档</font></a><font o="4796">了解更多信息。</font></p>
</div>
<div class="paragraph">
<p><font o="4797">由于<code i="2448">StubRunnerRule</code>实现了<code i="2449">StubFinder</code>，它允许您找到已启动的存根：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.net.URL;
import java.util.Collection;
import java.util.Map;

import org.springframework.cloud.contract.spec.Contract;

public interface StubFinder extends StubTrigger {
	/**
	 * For the given groupId and artifactId tries to find the matching
	 * URL of the running stub.
	 *
	 * @param groupId - might be null. In that case a search only via artifactId takes place
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String groupId, String artifactId) throws StubNotFoundException;

	/**
	 * For the given Ivy notation {@code [groupId]:artifactId:[version]:[classifier]} tries to
	 * find the matching URL of the running stub. You can also pass only {@code artifactId}.
	 *
	 * @param ivyNotation - Ivy representation of the Maven artifact
	 * @return URL of a running stub or throws exception if not found
	 */
	URL findStubUrl(String ivyNotation) throws StubNotFoundException;

	/**
	 * Returns all running stubs
	 */
	RunningStubs findAllRunningStubs();

	/**
	 * Returns the list of Contracts
	 */
	Map&lt;StubConfiguration, Collection&lt;Contract&gt;&gt; getContracts();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4798">Spock测试中使用示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@ClassRule @Shared StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(StubRunnerRuleSpec.getResource("/m2repo/repository").toURI().toString())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")

def 'should start WireMock servers'() {
	expect: 'WireMocks are running'
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
		rule.findStubUrl('loanIssuance') != null
		rule.findStubUrl('loanIssuance') == rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
		rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
	and:
		rule.findAllRunningStubs().isPresent('loanIssuance')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
		rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
	and: 'Stubs were registered'
		"${rule.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${rule.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4799">JUnit测试中的使用示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Test
public void should_start_wiremock_servers() throws Exception {
	// expect: 'WireMocks are running'
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isNotNull();
		then(rule.findStubUrl("loanIssuance")).isEqualTo(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs", "loanIssuance"));
		then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isNotNull();
	// and:
		then(rule.findAllRunningStubs().isPresent("loanIssuance")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs", "fraudDetectionServer")).isTrue();
		then(rule.findAllRunningStubs().isPresent("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")).isTrue();
	// and: 'Stubs were registered'
		then(httpGet(rule.findStubUrl("loanIssuance").toString() + "/name")).isEqualTo("loanIssuance");
		then(httpGet(rule.findStubUrl("fraudDetectionServer").toString() + "/name")).isEqualTo("fraudDetectionServer");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4800">有关如何应用Stub Runner的全局配置的更多信息，</font><font o="4800">请查看</font><strong><font o="4800">JUnit和Spring</font></strong><font o="4800">的</font><strong><font o="4800">公共属性</font></strong><font o="4800">。</font></p>
</div>
<div class="sect3">
<h4 id="_maven_settings"><font o="4801">Maven设置</font></h4>
<div class="paragraph">
<p><font o="4802">存根下载器为不同的本地存储库文件夹授予Maven设置。</font><font o="4803">目前没有考虑存储库和配置文件的身份验证详细信息，因此您需要使用上述属性进行指定。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_providing_fixed_ports"><font o="4804">提供固定端口</font></h4>
<div class="paragraph">
<p><font o="4805">您还可以在固定端口上运行您的存根。</font><font o="4806">你可以通过两种不同的方法来实现。</font><font o="4807">一个是在属性中传递它，另一个是通过JUnit规则的流畅API。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_fluent_api"><font o="4808">流畅的API</font></h4>
<div class="paragraph">
<p><font o="4809">使用<code i="2450">StubRunnerRule</code>时，您可以添加一个存根下载，然后通过上次下载的存根的端口。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@ClassRule public static StubRunnerRule rule = new StubRunnerRule()
		.repoRoot(repoRoot())
		.downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
		.withPort(12345)
		.downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer:12346");</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4810">您可以看到，对于此示例，以下测试是有效的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">then(rule.findStubUrl("loanIssuance")).isEqualTo(URI.create("http://localhost:12345").toURL());
then(rule.findStubUrl("fraudDetectionServer")).isEqualTo(URI.create("http://localhost:12346").toURL());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stub_runner_with_spring"><font o="4811">Stub Runner与Spring</font></h4>
<div class="paragraph">
<p><font o="4812">设置Stub Runner项目的Spring配置。</font></p>
</div>
<div class="paragraph">
<p><font o="4813">通过在配置文件中提供存根列表，Stub Runner自动下载并注册WireMock中所选择的存根。</font></p>
</div>
<div class="paragraph">
<p><font o="4814">如果要查找stubbed依赖关系的URL，您可以自动连接<code i="2451">StubFinder</code>接口并使用其方法，如下所示：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = [" stubrunner.cloud.enabled=false",
		"stubrunner.camel.enabled=false",
		'foo=${stubrunner.runningstubs.fraudDetectionServer.port}'])
@AutoConfigureStubRunner
@DirtiesContext
@ActiveProfiles("test")
class StubRunnerConfigurationSpec extends Specification {

	@Autowired StubFinder stubFinder
	@Autowired Environment environment
	@Value('${foo}') Integer foo

	@BeforeClass
	@AfterClass
	void setupProps() {
		System.clearProperty("stubrunner.repository.root")
		System.clearProperty("stubrunner.classifier")
	}

	def 'should start WireMock servers'() {
		expect: 'WireMocks are running'
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') != null
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
			stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs')
			stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
		and:
			stubFinder.findAllRunningStubs().isPresent('loanIssuance')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
			stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
		and: 'Stubs were registered'
			"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
			"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	}

	def 'should throw an exception when stub is not found'() {
		when:
			stubFinder.findStubUrl('nonExistingService')
		then:
			thrown(StubNotFoundException)
		when:
			stubFinder.findStubUrl('nonExistingGroupId', 'nonExistingArtifactId')
		then:
			thrown(StubNotFoundException)
	}

	def 'should register started servers as environment variables'() {
		expect:
			environment.getProperty("stubrunner.runningstubs.loanIssuance.port") != null
			stubFinder.findAllRunningStubs().getPort("loanIssuance") == (environment.getProperty("stubrunner.runningstubs.loanIssuance.port") as Integer)
		and:
			environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") != null
			stubFinder.findAllRunningStubs().getPort("fraudDetectionServer") == (environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") as Integer)
	}

	def 'should be able to interpolate a running stub in the passed test property'() {
		given:
			int fraudPort = stubFinder.findAllRunningStubs().getPort("fraudDetectionServer")
		expect:
			fraudPort &gt; 0
			environment.getProperty("foo", Integer) == fraudPort
			foo == fraudPort
	}

	@Configuration
	@EnableAutoConfiguration
	static class Config {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4815">对于以下配置文件：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yml" data-lang="yml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids:
    - org.springframework.cloud.contract.verifier.stubs:loanIssuance
    - org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer
    - org.springframework.cloud.contract.verifier.stubs:bootService
  cloud:
    enabled: false
  camel:
    enabled: false

spring.cloud:
  consul.enabled: false
  service-registry.enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4816">您也可以使用<code i="2452">@AutoConfigureStubRunner</code>内的属性代替使用属性。</font><font o="4817">下面您可以通过设置注释的值来找到实现相同结果的示例。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@AutoConfigureStubRunner(
		ids = ["org.springframework.cloud.contract.verifier.stubs:loanIssuance",
		"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer",
		"org.springframework.cloud.contract.verifier.stubs:bootService"],
		repositoryRoot = "classpath:m2repo/repository/")</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4818">Stub Runner Spring为每个注册的WireMock服务器以以下方式注册环境变量。</font><font o="4819">Stub Runner ids <code i="2453">com.example:foo</code>，<code i="2454">com.example:bar</code>的示例。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stubrunner.runningstubs.foo.port</code></p>
</li>
<li>
<p><code>stubrunner.runningstubs.bar.port</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4820">你可以在你的代码中引用它。</font></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_spring_cloud">Stub Runner Spring Cloud</h3>
<div class="paragraph">
<p><font o="4822">Stub Runner可以与Spring Cloud整合。</font></p>
</div>
<div class="paragraph">
<p><font o="4823">对于现实生活中的例子，你可以检查</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/producer"><font o="4824">制作人应用程式样本</font></a></p>
</li>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/master/consumer_with_discovery"><font o="4825">消费者应用程序样本</font></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_stubbing_service_discovery"><font o="4826">Stubbing服务发现</font></h4>
<div class="paragraph">
<p><font o="4827"><code i="2455">Stub Runner Spring Cloud</code>的最重要的特征就是它的存在</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscoveryClient</code></p>
</li>
<li>
<p><code>Ribbon</code> <code>ServerList</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4828">这意味着无论您是否使用Zookeeper，Consul，Eureka或其他任何事情，您都不需要在测试中。</font><font o="4829">我们正在启动您的依赖项的WireMock实例，只要您直接使用<code i="2456">Feign</code>，负载平衡<code i="2457">RestTemplate</code>或<code i="2458">DiscoveryClient</code>，我们会告诉您的应用程序来调用这些stubbed服务器，而不是调用真实的服务发现工具。</font></p>
</div>
<div class="paragraph">
<p><font o="4830">例如这个测试将通过</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def 'should make service discovery work'() {
	expect: 'WireMocks are running'
		"${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
		"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
	and: 'Stubs can be reached via load service discovery'
		restTemplate.getForObject('http://loanIssuance/name', String) == 'loanIssuance'
		restTemplate.getForObject('http://someNameThatShouldMapFraudDetectionServer/name', String) == 'fraudDetectionServer'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4831">对于以下配置文件</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yml" data-lang="yml">spring.cloud:
  zookeeper.enabled: false
  consul.enabled: false
eureka.client.enabled: false
stubrunner:
  camel.enabled: false
  idsToServiceIds:
    ivyNotation: someValueInsideYourCode
    fraudDetectionServer: someNameThatShouldMapFraudDetectionServer</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_test_profiles_and_service_discovery"><font o="4832">测试配置文件和服务发现</font></h5>
<div class="paragraph">
<p><font o="4833">在集成测试中，您通常不想既不调用发现服务（例如Eureka）或调用服务器。</font><font o="4834">这就是为什么你创建一个额外的测试配置，你要禁用这些功能。</font></p>
</div>
<div class="paragraph">
<p><font o="4835">由于</font><a href="https://github.com/spring-cloud/spring-cloud-commons/issues/156"><code>spring-cloud-commons</code></a><font o="4835">实现这一点的</font><font o="4835">某些限制，</font><font o="4835">您可以通过下面的静态块来禁用这些属性（例如Eureka）</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">    //Hack to work around https://github.com/spring-cloud/spring-cloud-commons/issues/156
    static {
        System.setProperty("eureka.client.enabled", "false");
        System.setProperty("spring.cloud.config.failFast", "false");
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_additional_configuration"><font o="4836">附加配置</font></h4>
<div class="paragraph">
<p><font o="4837">您可以使用<code i="2459">stubrunner.idsToServiceIds:</code>地图将存根的artifactId与应用程序的名称进行匹配。</font><font o="4838">提供：<code i="2460">stubrunner.cloud.ribbon.enabled</code>等于<code i="2461">false</code>，您可以禁用Stub Runner Ribbon支持。您可以通过提供<code i="2462">stubrunner.cloud.enabled</code>等于<code i="2463">false</code>来禁用Stub Runner支持</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4839">提示</font></div>
</td>
<td class="content"><font o="4840">
默认情况下，所有服务发现都将被删除。</font><font o="4841">这意味着不管事实如果你有一个现有的<code i="2464">DiscoveryClient</code>，它的结果将被忽略。</font><font o="4842">但是，如果要重用它，只需将<code i="2465">stubrunner.cloud.delegate.enabled</code>设置为<code i="2466">true</code>，然后将现有的<code i="2467">DiscoveryClient</code>结果与已存在的结果合并。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_boot_application"><font o="4843">Stub Runner启动应用程序</font></h3>
<div class="paragraph">
<p><font o="4844">Spring Cloud Contract验证者Stub Runner Boot是一个Spring Boot应用程序，它暴露了REST端点来触发邮件标签并访问启动的WireMock服务器。</font></p>
</div>
<div class="paragraph">
<p><font o="4845">其中一个用例是在部署的应用程序上运行一些烟雾（端到端）测试。</font><font o="4846">您可以</font><a href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/"><font o="4846">在Too Much Coding博客</font></a><font o="4846">的</font><a href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/"><font o="4846">“Microservice部署”文章中</font></a><font o="4846">阅读更多信息   </font><a href="http://toomuchcoding.com/blog/2015/09/27/microservice-deployment/"><font o="4846">。</font></a></p>
</div>
<div class="sect3">
<h4 id="_how_to_use_it"><font o="4847">如何使用它？</font></h4>
<div class="paragraph">
<p><font o="4848">只需添加</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">compile "org.springframework.cloud:spring-cloud-starter-stub-runner"</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4849">用<code i="2468">@EnableStubRunnerServer</code>注释一个课程，建一个胖子，你准备好了！</font></p>
</div>
<div class="paragraph">
<p><font o="4850">对于属性，请检查</font><strong><font o="4850">Stub Runner Spring</font></strong><font o="4850">部分。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_endpoints_2"><font o="4851">端点</font></h4>
<div class="sect4">
<h5 id="_http_2"><font o="4852">HTTP</font></h5>
<div class="ulist">
<ul>
<li>
<p><font o="4853">GET <code i="2469">/stubs</code>  - 返回<code i="2470">ivy:integer</code>表示法中所有运行存根的列表</font></p>
</li>
<li>
<p><font o="4854">GET <code i="2471">/stubs/{ivy}</code>  - 返回给定的<code i="2472">ivy</code>符号的端口（当调用端点<code i="2473">ivy</code>也可以是<code i="2474">artifactId</code>）</font></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_messaging_2"><font o="4855">消息</font></h5>
<div class="paragraph">
<p><font o="4856">消息传递</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4857">GET <code i="2475">/triggers</code>  - 返回<code i="2476">ivy : [ label1, label2 …​]</code>表示法中所有正在运行的标签的列表</font></p>
</li>
<li>
<p><font o="4858">POST <code i="2477">/triggers/{label}</code>  - 执行<code i="2478">label</code>的触发器</font></p>
</li>
<li>
<p><font o="4859">POST <code i="2479">/triggers/{ivy}/{label}</code>  - 对于给定的<code i="2481">ivy</code>符号（当调用端点<code i="2482">ivy</code>也可以是<code i="2483">artifactId</code>）时，执行具有<code i="2480">label</code>的触发器）</font></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example_2"><font o="4860">例</font></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">@ContextConfiguration(classes = StubRunnerBoot, loader = SpringBootContextLoader)
@SpringBootTest(properties = "spring.cloud.zookeeper.enabled=false")
@ActiveProfiles("test")
class StubRunnerBootSpec extends Specification {

	@Autowired StubRunning stubRunning

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning),
				new TriggerController(stubRunning))
	}

	def 'should return a list of running stub servers in "full ivy:port" notation'() {
		when:
			String response = RestAssuredMockMvc.get('/stubs').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs' instanceof Integer
	}

	def 'should return a port on which a [#stubId] stub is running'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/${stubId}")
		then:
			response.statusCode == 200
			response.body.as(Integer) &gt; 0
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:+:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs',
					   'org.springframework.cloud.contract.verifier.stubs:bootService:+',
					   'org.springframework.cloud.contract.verifier.stubs:bootService',
					   'bootService']
	}

	def 'should return 404 when missing stub was called'() {
		when:
			def response = RestAssuredMockMvc.get("/stubs/a:b:c:d")
		then:
			response.statusCode == 404
	}

	def 'should return a list of messaging labels that can be triggered when version and classifier are passed'() {
		when:
			String response = RestAssuredMockMvc.get('/triggers').body.asString()
		then:
			def root = new JsonSlurper().parseText(response)
			root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'?.containsAll(["delete_book","return_book_1","return_book_2"])
	}

	def 'should trigger a messaging label'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger('delete_book')
	}

	def 'should trigger a messaging label for a stub with [#stubId] ivy notation'() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post("/triggers/$stubId/delete_book")
		then:
			response.statusCode == 200
		and:
			1 * stubRunning.trigger(stubId, 'delete_book')
		where:
			stubId &lt;&lt; ['org.springframework.cloud.contract.verifier.stubs:bootService:stubs', 'org.springframework.cloud.contract.verifier.stubs:bootService', 'bootService']
	}

	def 'should throw exception when trigger is missing'() {
		when:
			RestAssuredMockMvc.post("/triggers/missing_label")
		then:
			Exception e = thrown(Exception)
			e.message.contains("Exception occurred while trying to return [missing_label] label.")
			e.message.contains("Available labels are")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs=[]")
			e.message.contains("org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs=")
	}

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stub_runner_boot_with_service_discovery"><font o="4861">Stub Runner启动服务发现</font></h4>
<div class="paragraph">
<p><font o="4862">使用Stub Runner Boot的可能性之一就是将其用作“烟雾测试”的存根。</font><font o="4863">这是什么意思？</font><font o="4864">假设您不想将50个微服务部署到测试环境中，以检查您的应用程序是否正常工作。</font><font o="4865">您在构建过程中已经执行了一系列测试，但您也希望确保应用程序的打包正常。</font><font o="4866">您可以做的是将应用程序部署到环境中，启动并运行一些测试，以确定它是否正常工作。</font><font o="4867">我们可以将这些测试称为烟雾测试，因为他们的想法只是检查一些测试场景。</font></p>
</div>
<div class="paragraph">
<p><font o="4868">这种方法的问题是，如果您正在执行微服务，则很可能您正在使用服务发现工具。</font><font o="4869">Stub Runner引导允许您通过启动所需的存根并将其注册到服务发现工具中来解决此问题。</font><font o="4870">让我们来看看一个这样一个设置的例子Eureka。</font><font o="4871">假设Eureka已经在运行。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableStubRunnerServer
@EnableEurekaClient
@AutoConfigureStubRunner
public class StubRunnerBootEurekaExample {

	public static void main(String[] args) {
		SpringApplication.run(StubRunnerBootEurekaExample.class, args);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4872">如您所见，我们希望启动一个Stub Runner引导服务器<code i="2484">@EnableStubRunnerServer</code>，启用Eureka客户端<code i="2485">@EnableEurekaClient</code>，并且我们想要使存根转移功能打开<code i="2486">@AutoConfigureStubRunner</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="4873">现在我们假设我们要启动这个应用程序，以便自动注册存根。</font><font o="4874">我们可以通过运行应用程序<code i="2487">java -jar ${SYSTEM_PROPS} stub-runner-boot-eureka-example.jar</code>来执行此操作，其中<code i="2488">${SYSTEM_PROPS}</code>将包含以下属性列表</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">-Dstubrunner.repositoryRoot=http://repo.spring.io/snapshots (1)
-Dstubrunner.cloud.stubbed.discovery.enabled=false (2)
-Dstubrunner.ids=org.springframework.cloud.contract.verifier.stubs:loanIssuance,org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer,org.springframework.cloud.contract.verifier.stubs:bootService (3)
-Dstubrunner.idsToServiceIds.fraudDetectionServer=someNameThatShouldMapFraudDetectionServer (4)

(1) - we tell Stub Runner where all the stubs reside
(2) - we don't want the default behaviour where the discovery service is stubbed. That's why the stub registration will be picked
(3) - we provide a list of stubs to download
(4) - we provide a list of artifactId to serviceId mapping</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4875">这样您的部署应用程序可以通过服务发现将请求发送到启动的WireMock服务器。</font><font o="4876">默认情况下，<code i="2489">application.yml</code>可能会设置1-3，因为它们不太可能改变。</font><font o="4877">这样，只要您启动Stub Runner引导，您只能提供要下载的存根列表。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_common_properties_for_junit_and_spring"><font o="4878">JUnit和Spring的常用属性</font></h4>
<div class="paragraph">
<p><font o="4879">可以使用系统属性或配置属性（对于Spring）设置重复的某些属性。</font><font o="4880">以下是他们的名称及其默认值：</font></p>
</div>
<table class="tableblock frame-topbot grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><font o="4881">物业名称</font></th>
<th class="tableblock halign-left valign-top"><font o="4882">默认值</font></th>
<th class="tableblock halign-left valign-top"><font o="4883">描述</font></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.minPort</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4884">具有存根的起始WireMock端口的最小值</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.maxPort</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4885">具有存根的起始WireMock端口的最小值</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.repositoryRoot</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4886">Maven repo网址 </font><font o="4887">如果空白，那么将调用本地的maven repo</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.classifier</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4888">stub工件的默认分类器</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.workOffline</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4889">如果为true，则不会联系任何远程存储库以下载存根</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.ids</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4890">数组的常春藤符号存根下载</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.username</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4891">可选的用户名访问使用存根存储JAR的工具</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">stubrunner.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="4892">访问使用存根存储JAR的工具的可选密码</font></p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_stub_runner_stubs_ids"><font o="4893">存根运动员短桩ids</font></h5>
<div class="paragraph">
<p><font o="4894">您可以通过<code i="2490">stubrunner.ids</code>系统属性提供存根下载。</font><font o="4895">他们遵循以下模式：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">groupId:artifactId:version:classifier:port</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4896"><code i="2491">version</code>，<code i="2492">classifier</code>和<code i="2493">port</code>是可选的。</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="4897">如果您不提供<code i="2494">port</code>，则会选择一个随机的</font></p>
</li>
<li>
<p><font o="4898">如果您不提供<code i="2495">classifier</code>，那么将采用默认值。</font><font o="4899">（注意，你可以传递这样一个空的分类器<code i="2496">groupId:artifactId:version:</code>）</font></p>
</li>
<li>
<p><font o="4900">如果您不提供<code i="2497">version</code>，则将通过<code i="2498">+</code>，最新的将被下载</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4901">其中<code i="2499">port</code>表示WireMock服务器的端口。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4902">重要</font></div>
</td>
<td class="content"><font o="4903">
从版本1.0.4开始，您可以提供一系列您希望Stub Runner考虑的版本。</font><font o="4904">您可以</font><a href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges"><font o="4904">在这里</font></a><font o="4904">阅读有关</font><a href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges"><font o="4904">Aether版本控制范围的</font></a><font o="4904">更多信息</font><font o="4904">。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="4905">取自</font><a href="http://download.eclipse.org/aether/aether-core/0.9.0/apidocs/org/eclipse/aether/util/version/GenericVersionScheme.html"><font o="4905">Aether文件</font></a><font o="4905">：</font></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><font o="4906">该方案接受任何形式的版本，将版本解释为数字和字母段的序列。</font><font o="4907">字符' - '，'_'和'。' </font><font o="4908">以及从数字到字母的转换，反之亦然分隔版本段。</font><font o="4909">分隔符被视为等同物。</font></p>
</div>
<div class="paragraph">
<p><font o="4910">数字段在数学上进行比较，字母段被字典和区分大小写比较。</font><font o="4911">但是，以下限定字符串被特别识别和处理：“alpha”=“a”&lt;“beta”=“b”&lt;“milestone”=“m”&lt;“cr”=“rc”&lt;“snapshot”&lt;“final “=”ga“&lt;”sp“。</font><font o="4912">所有这些知名的限定词被认为比其他字符串更小/更老。</font><font o="4913">空的段/字符串等于0。</font></p>
</div>
<div class="paragraph">
<p><font o="4914">除了上述限定符之外，令牌“min”和“max”可以用作最终版本段，以表示具有给定前缀的最小/最大版本。</font><font o="4915">例如，“1.2.min”表示1.2行中的最小版本，“1.2.max”表示1.2行中最大的版本。</font><font o="4916">形式“[MN *]”的版本范围是“[MNmin，MNmax]”的缩写。</font></p>
</div>
<div class="paragraph">
<p><font o="4917">数字和字符串被认为是无法比拟的。</font><font o="4918">在不同类型的版本段会相互冲突的情况下，比较将假定以前的段分别以0或“ga”段的形式进行填充，直到种类不一致被解决为止，例如“1-alpha”=“1.0.0-alpha “&lt;”1.0.1-ga“=”1.0.1“。</font></p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_for_messaging"><font o="4919">Stub Runner用于消息传递</font></h3>
<div class="paragraph">
<p><font o="4920">Stub Runner具有在内存中运行已发布存根的功能。</font><font o="4921">它可以与开箱即用的以下框架集成</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Integration</p>
</li>
<li>
<p><font o="4923">Spring Cloud Stream</font></p>
</li>
<li>
<p><font o="4924">Apache Camel</font></p>
</li>
<li>
<p><font o="4925">Spring AMQP</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="4926">它还提供了与市场上任何其他解决方案集成的入口点。</font></p>
</div>
<div class="sect3">
<h4 id="_stub_triggering"><font o="4927">存根触发</font></h4>
<div class="paragraph">
<p><font o="4928">要触发消息，只需使用<code i="2500">StubTrigger</code>接口即可：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.util.Collection;
import java.util.Map;

public interface StubTrigger {

	/**
	 * Triggers an event by a given label for a given {@code groupid:artifactid} notation. You can use only {@code artifactId} too.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String ivyNotation, String labelName);

	/**
	 * Triggers an event by a given label.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger(String labelName);

	/**
	 * Triggers all possible events.
	 *
	 * Feature related to messaging.
	 *
	 * @return true - if managed to run a trigger
	 */
	boolean trigger();

	/**
	 * Returns a mapping of ivy notation of a dependency to all the labels it has.
	 *
	 * Feature related to messaging.
	 */
	Map&lt;String, Collection&lt;String&gt;&gt; labels();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4929">为了方便起见，<code i="2501">StubFinder</code>接口扩展了<code i="2502">StubTrigger</code>，所以只需要在你的测试中使用一个。</font></p>
</div>
<div class="paragraph">
<p><font o="4930"><code i="2503">StubTrigger</code>提供以下选项来触发邮件：</font></p>
</div>
<div class="sect4">
<h5 id="_trigger_by_label"><font o="4931">按标签触发</font></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_trigger_by_group_and_artifact_ids"><font o="4932">按组和人工制品ids触发</font></h6>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('org.springframework.cloud.contract.verifier.stubs:camelService', 'return_book_1')</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_trigger_by_artifact_ids"><font o="4933">通过人工制品ids触发</font></h6>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('camelService', 'return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trigger_all_messages"><font o="4934">触发所有消息</font></h5>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_camel"><font o="4935">Stub Runner Camel</font></h3>
<div class="paragraph">
<p><font o="4936">Spring Cloud Contract验证器Stub Runner的消息传递模块为您提供了与Apache Camel集成的简单方法。</font><font o="4937">对于提供的工件，它将自动下载存根并注册所需的路由。</font></p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project"><font o="4938">将其添加到项目中</font></h4>
<div class="paragraph">
<p><font o="4939">在类路径上同时拥有Apache Camel和Spring Cloud Contract Stub Runner就足够了。</font><font o="4940">记住使用<code i="2504">@AutoConfigureMessageVerifier</code>注释你的测试类。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_examples"><font o="4941">例子</font></h4>
<div class="sect4">
<h5 id="_stubs_structure"><font o="4942">桩结构</font></h5>
<div class="paragraph">
<p><font o="4943">让我们假设我们拥有以下Maven资源库，并为<code i="2505">camelService</code>应用程序配置了一个存根。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── camelService
                            ├── 0.0.1-SNAPSHOT
                            │&nbsp;&nbsp; ├── camelService-0.0.1-SNAPSHOT.pom
                            │&nbsp;&nbsp; ├── camelService-0.0.1-SNAPSHOT-stubs.jar
                            │&nbsp;&nbsp; └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4944">并且存根包含以下结构：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── META-INF
│&nbsp;&nbsp; └── MANIFEST.MF
└── repository
    ├── accurest
    │&nbsp;&nbsp; ├── bookDeleted.groovy
    │&nbsp;&nbsp; ├── bookReturned1.groovy
    │&nbsp;&nbsp; └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4945">让我们考虑以下合同（让我们用</font><strong><font o="4945">1来表示</font></strong><font o="4945">）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('jms:output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4946">和</font><strong><font o="4946">2</font></strong><font o="4946">号</font><strong><font></font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('jms:input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('jms:output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_2"><font o="4947">情景1（无输入讯息）</font></h5>
<div class="paragraph">
<p><font o="4948">为了通过<code i="2506">return_book_1</code>标签触发消息，我们将使用<code i="2507">StubTigger</code>接口，如下所示</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4949">接下来，我们将要收听发送到<code i="2508">jms:output</code>的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4950">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_2"><font o="4951">情景2（输入触发输出）</font></h5>
<div class="paragraph">
<p><font o="4952">由于路由是为您设置的，只需向<code i="2509">jms:output</code>目的地发送消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:input', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4953">接下来我们将要收听发送到<code i="2510">jms:output</code>的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Exchange receivedMessage = camelContext.createConsumerTemplate().receive('jms:output', 5000)</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4954">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output"><font o="4955">情景3（无输出输入）</font></h5>
<div class="paragraph">
<p><font o="4956">由于路由是为您设置的，只需向<code i="2511">jms:output</code>目的地发送消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">camelContext.createProducerTemplate().sendBodyAndHeaders('jms:delete', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_integration"><font o="4957">Stub Runner整合</font></h3>
<div class="paragraph">
<p><font o="4958">Spring Cloud Contract验证器Stub Runner的消息传递模块为您提供了一种简单的与Spring Integration集成的方法。</font><font o="4959">对于提供的工件，它将自动下载存根并注册所需的路由。</font></p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_2"><font o="4960">将其添加到项目中</font></h4>
<div class="paragraph">
<p><font o="4961">在类路径上同时拥有Apache Camel和Spring Cloud Contract Stub Runner就足够了。</font><font o="4962">记住使用<code i="2512">@AutoConfigureMessageVerifier</code>注释测试类。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_2"><font o="4963">例子</font></h4>
<div class="sect4">
<h5 id="_stubs_structure_2"><font o="4964">桩结构</font></h5>
<div class="paragraph">
<p><font o="4965">让我们假设我们拥有以下Maven仓库，并为<code i="2513">integrationService</code>应用程序配置了一个存根。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── integrationService
                            ├── 0.0.1-SNAPSHOT
                            │&nbsp;&nbsp; ├── integrationService-0.0.1-SNAPSHOT.pom
                            │&nbsp;&nbsp; ├── integrationService-0.0.1-SNAPSHOT-stubs.jar
                            │&nbsp;&nbsp; └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4966">并且存根包含以下结构：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── META-INF
│&nbsp;&nbsp; └── MANIFEST.MF
└── repository
    ├── accurest
    │&nbsp;&nbsp; ├── bookDeleted.groovy
    │&nbsp;&nbsp; ├── bookReturned1.groovy
    │&nbsp;&nbsp; └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4967">让我们考虑以下合同（让我们用</font><strong><font o="4967">1来表示</font></strong><font o="4967">）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input {
		triggeredBy('bookReturnedTriggered()')
	}
	outputMessage {
		sentTo('output')
		body('''{ "bookName" : "foo" }''')
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4968">和</font><strong><font o="4968">2</font></strong><font o="4968">号</font><strong><font></font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('input')
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
				bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4969">和以下Spring Integration路由：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/integration"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xmlns:beans="http://www.springframework.org/schema/beans"
			 xsi:schemaLocation="http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/integration
			http://www.springframework.org/schema/integration/spring-integration.xsd"&gt;


	&lt;!-- REQUIRED FOR TESTING --&gt;
	&lt;bridge input-channel="output"
			output-channel="outputTest"/&gt;

	&lt;channel id="outputTest"&gt;
		&lt;queue/&gt;
	&lt;/channel&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_3"><font o="4970">情景1（无输入讯息）</font></h5>
<div class="paragraph">
<p><font o="4971">为了通过<code i="2514">return_book_1</code>标签触发一条消息，我们将使用<code i="2515">StubTigger</code>接口，如下所示</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4972">接下来我们将要收听发送到<code i="2516">output</code>的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4973">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_3"><font o="4974">情景2（输入触发输出）</font></h5>
<div class="paragraph">
<p><font o="4975">由于路由是为您设置的，只需向<code i="2517">output</code>目的地发送一条消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'input')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4976">接下来，我们将要收听发送到<code i="2518">output</code>的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4977">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output_2"><font o="4978">情景3（无输出输入）</font></h5>
<div class="paragraph">
<p><font o="4979">由于路由是为您设置的，只需向<code i="2519">input</code>目的地发送消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_stream"><font o="4980">Stub Runner流</font></h3>
<div class="paragraph">
<p><font o="4981">Spring Cloud Contract验证器Stub Runner的消息传递模块为您提供了与Spring Stream集成的简单方式。</font><font o="4982">对于提供的工件，它将自动下载存根并注册所需的路由。</font></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="4983">警告</font></div>
</td>
<td class="content"><font o="4984">
在Stub Runner与Stream的集成中，<code i="2520">messageFrom</code>或<code i="2521">sentTo</code>字符串首先被解析为一个<code i="2522">destination</code>的频道，然后如果没有这样的<code i="2523">destination</code>，它被解析为频道名称。
</font></td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_3"><font o="4985">将其添加到项目中</font></h4>
<div class="paragraph">
<p><font o="4986">在类路径上同时拥有Apache Camel和Spring Cloud Contract Stub Runner就足够了。</font><font o="4987">记住用<code i="2524">@AutoConfigureMessageVerifier</code>注释你的测试类。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_3"><font o="4988">例子</font></h4>
<div class="sect4">
<h5 id="_stubs_structure_3"><font o="4989">桩结构</font></h5>
<div class="paragraph">
<p><font o="4990">让我们假设我们拥有以下Maven仓库，并为<code i="2525">streamService</code>应用程序配置了一个存根。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── streamService
                            ├── 0.0.1-SNAPSHOT
                            │&nbsp;&nbsp; ├── streamService-0.0.1-SNAPSHOT.pom
                            │&nbsp;&nbsp; ├── streamService-0.0.1-SNAPSHOT-stubs.jar
                            │&nbsp;&nbsp; └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4991">并且存根包含以下结构：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── META-INF
│&nbsp;&nbsp; └── MANIFEST.MF
└── repository
    ├── accurest
    │&nbsp;&nbsp; ├── bookDeleted.groovy
    │&nbsp;&nbsp; ├── bookReturned1.groovy
    │&nbsp;&nbsp; └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4992">让我们考虑以下合同（让我们用</font><strong><font o="4992">1来表示</font></strong><font o="4992">）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_1'
	input { triggeredBy('bookReturnedTriggered()') }
	outputMessage {
		sentTo('returnBook')
		body('''{ "bookName" : "foo" }''')
		headers { header('BOOK-NAME', 'foo') }
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4993">和</font><strong><font o="4993">2</font></strong><font o="4993">号</font><strong><font></font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'return_book_2'
	input {
		messageFrom('bookStorage')
		messageBody([
			bookName: 'foo'
		])
		messageHeaders { header('sample', 'header') }
	}
	outputMessage {
		sentTo('returnBook')
		body([
			bookName: 'foo'
		])
		headers { header('BOOK-NAME', 'foo') }
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4994">和以下Spring配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">stubrunner.repositoryRoot: classpath:m2repo/repository/
stubrunner.ids: org.springframework.cloud.contract.verifier.stubs:streamService:0.0.1-SNAPSHOT:stubs

spring:
  cloud:
    stream:
      bindings:
        output:
          destination: returnBook
        input:
          destination: bookStorage

server:
  port: 0

debug: true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_1_no_input_message_4"><font o="4995">情景1（无输入讯息）</font></h5>
<div class="paragraph">
<p><font o="4996">为了通过<code i="2526">return_book_1</code>标签触发一条消息，我们将使用<code i="2527">StubTrigger</code>接口，如下所示</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4997">接下来，我们将要收听发送到<code i="2528">destination</code>为<code i="2529">returnBook</code>的频道的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="4998">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_2_output_triggered_by_input_4"><font o="4999">情景2（输入触发输出）</font></h5>
<div class="paragraph">
<p><font o="5000">由于路由是为您设置的，只需向<code i="2530">bookStorage</code> <code i="2531">destination</code>发送消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'bookStorage')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5001">接下来我们将要收听发送到<code i="2532">returnBook</code>的消息的输出</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Message&lt;?&gt; receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5002">接收到的消息将通过以下断言</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scenario_3_input_with_no_output_3"><font o="5003">情景3（无输出输入）</font></h5>
<div class="paragraph">
<p><font o="5004">由于路由是为您设置的，只需向<code i="2533">output</code>目的地发送消息即可。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stub_runner_spring_amqp"><font o="5005">Stub Runner Spring AMQP</font></h3>
<div class="paragraph">
<p><font o="5006">Spring Cloud Contract验证器Stub Runner的消息传递模块提供了一种简单的方法来与Spring AMQP的Rabbit模板集成。</font><font o="5007">对于提供的工件，它将自动下载存根并注册所需的路由。</font></p>
</div>
<div class="paragraph">
<p><font o="5008">集成尝试独立运行，即不与运行的RabbitMQ消息代理交互。</font><font o="5009">它期望在应用程序上下文中使用<code i="2534">RabbitTemplate</code>，并将其用作spring boot测试<code i="2535">@SpyBean</code>。</font><font o="5010">因此，它可以使用mockito间谍功能来验证和内省应用程序发送的消息。</font></p>
</div>
<div class="paragraph">
<p><font o="5011">在消费消费者方面，它考虑了所有<code i="2536">@RabbitListener</code>注释端点以及应用程序上下文中的所有“SimpleMessageListenerContainer”。</font></p>
</div>
<div class="paragraph">
<p><font o="5012">由于消息通常发送到AMQP中的交换机，消息合同中包含交换机名称作为目标。</font><font o="5013">另一方的消息侦听器绑定到队列。</font><font o="5014">绑定将交换机连接到队列。</font><font o="5015">如果触发消息合约，Spring AMQP存根转移器集成将在与该交换机匹配的应用程序上下文中查找绑定。</font><font o="5016">然后它从Spring交换机收集队列，并尝试查找绑定到这些队列的消息侦听器。</font><font o="5017">消息被触发到所有匹配的消息监听器。</font></p>
</div>
<div class="sect3">
<h4 id="_adding_it_to_the_project_4"><font o="5018">将其添加到项目中</font></h4>
<div class="paragraph">
<p><font o="5019">在类路径上同时拥有Spring AMQP和Spring Cloud Contract Stub Runner就足够了，并设置属性<code i="2537">stubrunner.amqp.enabled=true</code>。</font><font o="5020">记住用<code i="2538">@AutoConfigureMessageVerifier</code>注释你的测试类。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_examples_4"><font o="5021">例子</font></h4>
<div class="sect4">
<h5 id="_stubs_structure_4"><font o="5022">桩结构</font></h5>
<div class="paragraph">
<p><font o="5023">让我们假设我们拥有以下Maven资源库，并为<code i="2539">spring-cloud-contract-amqp-test</code>应用程序配置了一个存根。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">└── .m2
    └── repository
        └── com
            └── example
                └── spring-cloud-contract-amqp-test
                    ├── 0.4.0-SNAPSHOT
                    │&nbsp;&nbsp; ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT.pom
                    │&nbsp;&nbsp; ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT-stubs.jar
                    │&nbsp;&nbsp; └── maven-metadata-local.xml
                    └── maven-metadata-local.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5024">并且存根包含以下结构：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-bash" data-lang="bash">├── META-INF
│&nbsp;&nbsp; └── MANIFEST.MF
└── contracts
    └── shouldProduceValidPersonData.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5025">让我们考虑下列合约：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
    // Human readable description
    description 'Should produce valid person data'
    // Label by means of which the output message can be triggered
    label 'contract-test.person.created.event'
    // input to the contract
    input {
        // the contract will be triggered by a method
        triggeredBy('createPerson()')
    }
    // output message of the contract
    outputMessage {
        // destination to which the output message will be sent
        sentTo 'contract-test.exchange'
        headers {
            header('contentType': 'application/json')
            header('__TypeId__': 'org.springframework.cloud.contract.stubrunner.messaging.amqp.Person')
        }
        // the body of the output message
        body ([
                id: $(consumer(9), producer(regex("[0-9]+"))),
                name: "me"
        ])
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5026">和以下Spring配置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids: org.springframework.cloud.contract.verifier.stubs.amqp:spring-cloud-contract-amqp-test:0.4.0-SNAPSHOT:stubs
  amqp:
    enabled: true
server:
  port: 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_triggering_the_message"><font o="5027">触发消息</font></h5>
<div class="paragraph">
<p><font o="5028">因此，为了触发使用上述合同的消息，我们将使用<code i="2540">StubTrigger</code>界面如下。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">stubTrigger.trigger("contract-test.person.created.event")</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5029">消息的目的地为<code i="2541">contract-test.exchange</code>，所以Spring AMQP存根转移器集成查找与此交换相关的绑定。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
public Binding binding() {
	return BindingBuilder.bind(new Queue("test.queue")).to(new DirectExchange("contract-test.exchange")).with("#");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5030">绑定定义绑定队列<code i="2542">test.queue</code>。</font><font o="5031">因此，以下监听器定义是一个匹配，并使用合同消息进行调用。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Bean
public SimpleMessageListenerContainer simpleMessageListenerContainer(ConnectionFactory connectionFactory,
																		MessageListenerAdapter listenerAdapter) {
	SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
	container.setConnectionFactory(connectionFactory);
	container.setQueueNames("test.queue");
	container.setMessageListener(listenerAdapter);

	return container;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5032">此外，以下注释的监听器表示一个匹配并将被调用。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@RabbitListener(bindings = @QueueBinding(
		value = @Queue(value = "test.queue"),
		exchange = @Exchange(value = "contract-test.exchange", ignoreDeclarationExceptions = "true")))
public void handlePerson(Person person) {
	this.person = person;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5033">注意</font></div>
</td>
<td class="content"><font o="5034">
该消息直接交给<code i="2544">MessageListener</code>与<code i="2545">SimpleMessageListenerContainer</code>匹配的<code i="2544">MessageListener</code>方法。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_spring_amqp_test_configuration"><font o="5035">Spring AMQP测试配置</font></h5>
<div class="paragraph">
<p><font o="5036">为了避免Spring AMQP在测试期间尝试连接到运行的代理，我们配置了一个模拟<code i="2546">ConnectionFactory</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="5037">要禁用嘲弄的ConnectionFactory设置属性<code i="2547">stubrunner.amqp.mockConnection=false</code></font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yaml" data-lang="yaml">stubrunner:
  amqp:
    mockConnection: false</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_contract_dsl">Contract DSL</h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5039">重要</font></div>
</td>
<td class="content"><font o="5040">
请记住，在合同文件中，您必须向<code i="2548">Contract</code>类和<code i="2549">make</code>静态导入ie <code i="2550">org.springframework.cloud.spec.Contract.make { …​ }</code>提供完全限定名称。</font><font o="5041">您还可以向<code i="2551">Contract</code>类<code i="2552">import org.springframework.cloud.spec.Contract</code>提供导入，然后调用<code i="2553">Contract.make { …​ }</code>
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="5042">Contract DSL是用Groovy写的，但是如果以前没有使用Groovy，不要惊慌。</font><font o="5043">语言的知识并不是真正需要的，因为我们的DSL只使用它的一小部分（即文字，方法调用和闭包）。</font><font o="5044">DSL还被设计为程序员可读，而不需要DSL本身的知识 - 它是静态类型的。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5045">提示</font></div>
</td>
<td class="content"><font o="5046">
Spring Cloud Contract支持在单个文件中定义多个合同！
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="5047">合同存在于Spring Cloud Contract验证器存储库的<code i="2554">spring-cloud-contract-spec</code>模块中。</font></p>
</div>
<div class="paragraph">
<p><font o="5048">我们来看一下合同定义的完整例子。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url '/api/12'
		headers {
			header 'Content-Type': 'application/vnd.org.springframework.cloud.contract.verifier.twitter-places-analyzer.v1+json'
		}
		body '''\
		[{
			"created_at": "Sat Jul 26 09:38:57 +0000 2014",
			"id": 492967299297845248,
			"id_str": "492967299297845248",
			"text": "Gonna see you at Warsaw",
			"place":
			{
				"attributes":{},
				"bounding_box":
				{
					"coordinates":
						[[
							[-77.119759,38.791645],
							[-76.909393,38.791645],
							[-76.909393,38.995548],
							[-77.119759,38.995548]
						]],
					"type":"Polygon"
				},
				"country":"United States",
				"country_code":"US",
				"full_name":"Washington, DC",
				"id":"01fbe706f872cb32",
				"name":"Washington",
				"place_type":"city",
				"url": "http://api.twitter.com/1/geo/id/01fbe706f872cb32.json"
			}
		}]
	'''
	}
	response {
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5049">不是DSL的所有功能都在上面的例子中使用。</font><font o="5050">如果您找不到您想要的内容，请查看本页下面的段落。</font></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><font o="5051">您可以使用独立的maven命令<code i="2555">mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert</code>轻松地将Contracts编译为WireMock存根映射。</font></p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_limitations_2"><font o="5052">限制</font></h4>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5053">警告</font></div>
</td>
<td class="content"><font o="5054">
Spring Cloud Contract验证器不正确支持XML。</font><font o="5055">请使用JSON或帮助我们实现此功能。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5056">警告</font></div>
</td>
<td class="content"><font o="5057">
对JSON数组的大小的验证的支持是实验性的。</font><font o="5058">如果要打开它，请提供等于<code i="2557">true</code>的系统属性<code i="2556">spring.cloud.contract.verifier.assert.size</code>的值。</font><font o="5059">默认情况下，此功能设置为<code i="2558">false</code>。</font><font o="5060">您还可以在插件配置中提供<code i="2559">assertJsonSize</code>属性。
</font></td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5061">警告</font></div>
</td>
<td class="content"><font o="5062">
由于JSON结构可以有任何形式，因此在GString中使用时使用<code i="2560">value(consumer(…​), producer(…​))</code>符号时，有时无法正确解析它。</font><font o="5063">这就是为什么我们强烈推荐使用Groovy Map符号。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_common_top_level_elements"><font o="5064">常见的顶级元素</font></h4>
<div class="sect4">
<h5 id="_description"><font o="5065">描述</font></h5>
<div class="paragraph">
<p><font o="5066">您可以添加一个<code i="2561">description</code>到您的合同，除了一个任意的文本。</font><font o="5067">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">		org.springframework.cloud.contract.spec.Contract.make {
			description('''
given:
	An input
when:
	Sth happens
then:
	Output
''')
		}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_name"><font o="5068">名称</font></h5>
<div class="paragraph">
<p><font o="5069">您可以提供您的合同名称。</font><font o="5070">假设您提供了一个名称<code i="2562">should register a user</code>。</font><font o="5071">如果这样做，则自动生成测试的名称将等于<code i="2563">validate_should_register_a_user</code>。</font><font o="5072">如果是WireMock存根，存根的名称也将为<code i="2564">should_register_a_user.json</code>。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5073">重要</font></div>
</td>
<td class="content"><font o="5074">
请确保该名称不包含任何会使生成的测试无法编译的字符。</font><font o="5075">还要记住，如果您为多个合同提供相同的名称，那么您的自动生成测试将无法编译，并且生成的存根将会相互覆盖。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_ignoring_contracts"><font o="5076">忽略合同</font></h5>
<div class="paragraph">
<p><font o="5077">如果您想忽略合同，您可以在插件配置中设置忽略合同的值，或者仅在合同本身设置<code i="2565">ignored</code>属性：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	ignored()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_http_top_level_elements"><font o="5078">HTTP顶级元素</font></h4>
<div class="paragraph">
<p><font o="5079">可以在合同定义的顶层关闭中调用以下方法。</font><font o="5080">请求和响应是强制性的，优先级是可选的。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	// Definition of HTTP request part of the contract
	// (this can be a valid request or invalid depending
	// on type of contract being specified).
	request {
		//...
	}

	// Definition of HTTP response part of the contract
	// (a service implementing this contract should respond
	// with following response after receiving request
	// specified in "request" part above).
	response {
		//...
	}

	// Contract priority, which can be used for overriding
	// contracts (1 is highest). Priority is optional.
	priority 1
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_request"><font o="5081">请求</font></h4>
<div class="paragraph">
<p><font o="5082">HTTP协议只需要</font><font o="5082">在请求中指定</font><strong><font o="5082">方法和地址</font></strong><font o="5082">。</font><font o="5083">在合同的请求定义中，相同的信息是强制性的。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		// HTTP request method (GET/POST/PUT/DELETE).
		method 'GET'

		// Path component of request URL is specified as follows.
		urlPath('/users')
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5084">可以指定整个<code i="2566">url</code>而不是路径，但是<code i="2567">urlPath</code>是测试与</font><strong><font o="5084">主机无关的推荐方法</font></strong><font o="5084">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'

		// Specifying `url` and `urlPath` in one contract is illegal.
		url('http://localhost:8888/users')
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5085">请求可能包含</font><strong><font o="5085">查询参数</font></strong><font o="5085">，这些参数在嵌套在<code i="2568">urlPath</code>或<code i="2569">url</code>的调用中的闭包中指定。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		urlPath('/users') {

			// Each parameter is specified in form
			// `'paramName' : paramValue` where parameter value
			// may be a simple literal or one of matcher functions,
			// all of which are used in this example.
			queryParameters {

				// If a simple literal is used as value
				// default matcher function is used (equalTo)
				parameter 'limit': 100

				// `equalTo` function simply compares passed value
				// using identity operator (==).
				parameter 'filter': equalTo("email")

				// `containing` function matches strings
				// that contains passed substring.
				parameter 'gender': value(consumer(containing("[mf]")), producer('mf'))

				// `matching` function tests parameter
				// against passed regular expression.
				parameter 'offset': value(consumer(matching("[0-9]+")), producer(123))

				// `notMatching` functions tests if parameter
				// does not match passed regular expression.
				parameter 'loginStartsWith': value(consumer(notMatching(".{0,2}")), producer(3))
			}
		}

		//...
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5086">它可能包含其他</font><strong><font o="5086">请求标头</font></strong><font o="5086"> ...</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Each header is added in form `'Header-Name' : 'Header-Value'`.
		// there are also some helper methods
		headers {
			header 'key': 'value'
			contentType(applicationJson())
		}

		//...
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5087">...和</font><strong><font o="5087">请求机构</font></strong><font o="5087">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...

		// Currently only JSON format of request body is supported.
		// Format will be determined from a header or body's content.
		body '''{ "login" : "john", "name": "John The Contract" }'''
	}

	response {
		//...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_response"><font o="5088">响应</font></h4>
<div class="paragraph">
<p><font o="5089">最小响应必须包含</font><strong><font o="5089">HTTP状态代码</font></strong><font o="5089">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		//...
	}
	response {
		// Status code sent by the server
		// in response to request specified above.
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5090">除了状态响应可能包含</font><strong><font o="5090">标头</font></strong><font o="5090">和</font><strong><font o="5090">正文</font></strong><font o="5090">之外，它们与请求中的方式相同（参见前一段）。</font></p>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_properties"><font o="5091">动态属性</font></h4>
<div class="paragraph">
<p><font o="5092">合同可以包含一些动态属性 - 时间戳/ ids等。您不想强制使用者将其时钟保留为始终返回相同的时间值，以便与存根匹配。</font><font o="5093">这就是为什么我们允许您以两种方式在合同中提供动态部分。</font><font o="5094">一个是将它们直接传递到体内，一个将它们设置在另一部分，称为<code i="2570">testMatchers</code>和<code i="2571">stubMatchers</code>。</font></p>
</div>
<div class="sect4">
<h5 id="_dynamic_properties_inside_the_body"><font o="5095">体内动态属性</font></h5>
<div class="paragraph">
<p><font o="5096">您可以通过<code i="2572">value</code>方法设置体内的属性</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5097">或者如果您正在使用Groovy地图符号，您可以使用<code i="2573">$()</code>方法</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5098">所有上述方法都是相同的。</font><font o="5099">这意味着<code i="2574">stub</code>和<code i="2575">client</code>方法是<code i="2576">consumer</code>方法的别名。</font><font o="5100">我们来仔细看看我们可以在后续章节中对这些值做些什么。</font></p>
</div>
<div class="sect5">
<h6 id="_regular_expressions"><font o="5101">正则表达式</font></h6>
<div class="paragraph">
<p><font o="5102">您可以使用正则表达式在Contract DSL中写入请求。</font><font o="5103">当您想要指出给定的响应应该被提供给遵循给定模式的请求时，这是特别有用的。</font><font o="5104">此外，当您需要使用模式，而不是测试和服务器端测试时，您可以使用它。</font></p>
</div>
<div class="paragraph">
<p><font o="5105">请看下面的例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method('GET')
		url $(consumer(~/\/[0-9]{2}/), producer('/12'))
	}
	response {
		status 200
		body(
				id: $(anyNumber()),
				surname: $(
						consumer('Kowalsky'),
						producer(regex('[a-zA-Z]+'))
				),
				name: 'Jan',
				created: $(consumer('2014-02-02 12:23:43'), producer(execute('currentDate(it)'))),
				correlationId: value(consumer('5d1f9fef-e0dc-4f3d-a7e4-72d2220dd827'),
						producer(regex('[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'))
				)
		)
		headers {
			header 'Content-Type': 'text/plain'
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5106">您还可以使用正则表达式仅提供通信的一方。</font><font o="5107">如果这样做，那么我们将自动提供与提供的正则表达式匹配的生成的字符串。</font><font o="5108">例如：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url value(consumer(regex('/foo/[0-9]{5}')))
		body([
			requestElement: $(consumer(regex('[0-9]{5}')))
		])
		headers {
			header('header', $(consumer(regex('application\\/vnd\\.fraud\\.v1\\+json;.*'))))
		}
	}
	response {
		status 200
		body([
			responseElement: $(producer(regex('[0-9]{7}')))
		])
		headers {
			contentType("application/vnd.fraud.v1+json")
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5109">在该示例中，对于请求和响应，通信的相对侧将具有生成的相应数据。</font></p>
</div>
<div class="paragraph">
<p><font o="5110">Spring Cloud Contract附带一系列预定义的正则表达式，您可以在合同中使用。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">protected static final Pattern TRUE_OR_FALSE = Pattern.compile(/(true|false)/)
protected static final Pattern ONLY_ALPHA_UNICODE = Pattern.compile(/[\p{L}]*/)
protected static final Pattern NUMBER = Pattern.compile('-?\\d*(\\.\\d+)?')
protected static final Pattern IP_ADDRESS = Pattern.compile('([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])')
protected static final Pattern HOSTNAME_PATTERN = Pattern.compile('((http[s]?|ftp):\\/)\\/?([^:\\/\\s]+)(:[0-9]{1,5})?')
protected static final Pattern EMAIL = Pattern.compile('[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}');
protected static final Pattern URL = Pattern.compile('((www\\.|(http|https|ftp|news|file)+\\:\\/\\/)[_.a-z0-9-]+\\.[a-z0-9\\/_:@=.+?,##%&amp;~-]*[^.|\\\'|\\# |!|\\(|?|,| |&gt;|&lt;|;|\\)])')
protected static final Pattern UUID = Pattern.compile('[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}')
protected static final Pattern ANY_DATE = Pattern.compile('(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])')
protected static final Pattern ANY_DATE_TIME = Pattern.compile('([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')
protected static final Pattern ANY_TIME = Pattern.compile('(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])')
protected static final Pattern NON_EMPTY = Pattern.compile(/.+/)
protected static final Pattern NON_BLANK = Pattern.compile(/.*(\S+|\R).*|!^\R*$/)
protected static final Pattern ISO8601_WITH_OFFSET = Pattern.compile(/([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.\d{3})?(Z|[+-][01]\d:[0-5]\d)/)

protected static Pattern anyOf(String... values){
	return Pattern.compile(values.collect({"^$it\$"}).join("|"))
}

String onlyAlphaUnicode() {
	return ONLY_ALPHA_UNICODE.pattern()
}

String number() {
	return NUMBER.pattern()
}

String anyBoolean() {
	return TRUE_OR_FALSE.pattern()
}

String ipAddress() {
	return IP_ADDRESS.pattern()
}

String hostname() {
	return HOSTNAME_PATTERN.pattern()
}

String email() {
	return EMAIL.pattern()
}

String url() {
	return URL.pattern()
}

String uuid(){
	return UUID.pattern()
}

String isoDate() {
	return ANY_DATE.pattern()
}

String isoDateTime() {
	return ANY_DATE_TIME.pattern()
}

String isoTime() {
	return ANY_TIME.pattern()
}

String iso8601WithOffset() {
	return ISO8601_WITH_OFFSET.pattern()
}

String nonEmpty() {
	return NON_EMPTY.pattern()
}

String nonBlank() {
	return NON_BLANK.pattern()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5111">所以在你的合同中你可以这样使用它</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract dslWithOptionalsInString = Contract.make {
	priority 1
	request {
		method POST()
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			contentType(applicationJson())
		}
		body(
				code: value(consumer("123123"), producer(optional("123123"))),
				message: "User not found by email = [${value(producer(regex(email())), consumer('not.existing@user.com'))}]"
		)
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_passing_optional_parameters"><font o="5112">传递可选参数</font></h6>
<div class="paragraph">
<p><font o="5113">可以在您的合同中提供可选参数。</font><font o="5114">只能有可选参数：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><em><font o="5115">STUB</font></em><font o="5115">侧请求</font></p>
</li>
<li>
<p><em><font></font></em><font o="5116">响应的</font><em><font o="5116">TEST</font></em><font o="5116">侧</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="5117">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	priority 1
	request {
		method 'POST'
		url '/users/password'
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
				callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
		)
	}
	response {
		status 404
		headers {
			header 'Content-Type': 'application/json'
		}
		body(
				code: value(consumer("123123"), producer(optional("123123")))
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5118">通过使用<code i="2577">optional()</code>方法包装身体的一部分，您实际上正在创建一个应该存在0次或更多次的正则表达式。</font></p>
</div>
<div class="paragraph">
<p><font o="5119">如果您选择Spock，那么上述示例将会生成以下测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">"""
 given:
  def request = given()
    .header("Content-Type", "application/json")
    .body('''{"email":"abc@abc.com","callback_url":"http://partners.com"}''')

 when:
  def response = given().spec(request)
    .post("/users/password")

 then:
  response.statusCode == 404
  response.header('Content-Type')  == 'application/json'
 and:
  DocumentContext parsedJson = JsonPath.parse(response.body.asString())
  assertThatJson(parsedJson).field("code").matches("(123123)?")
"""</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5120">和以下存根：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
{
  "request" : {
    "url" : "/users/password",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.email =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,4})?/)]"
    }, {
      "matchesJsonPath" : "$[?(@.callback_url =~ /((http[s]?|ftp):\\\\/)\\\\/?([^:\\\\/\\\\s]+)(:[0-9]{1,5})?/)]"
    } ],
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/json"
      }
    }
  },
  "response" : {
    "status" : 404,
    "body" : "{\\"code\\":\\"123123\\",\\"message\\":\\"User not found by email == [not.existing@user.com]\\"}",
    "headers" : {
      "Content-Type" : "application/json"
    }
  },
  "priority" : 1
}
'''</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_executing_custom_methods_on_server_side"><font o="5121">在服务器端执行自定义方法</font></h6>
<div class="paragraph">
<p><font o="5122">也可以在测试期间定义要在服务器端执行的方法调用。</font><font o="5123">这样的方法可以添加到在配置中定义为“baseClassForTests”的类中。</font><font o="5124">例：</font></p>
</div>
<div class="paragraph">
<p><strong><font o="5125">合同</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'PUT'
		url $(consumer(regex('^/api/[0-9]{2}$')), producer('/api/12'))
		headers {
			header 'Content-Type': 'application/json'
		}
		body '''\
				[{
					"text": "Gonna see you at Warsaw"
				}]
			'''
	}
	response {
		body (
				path: $(consumer('/api/12'), producer(regex('^/api/[0-9]{2}$'))),
				correlationId: $(consumer('1223456'), producer(execute('isProperCorrelationId($it)')))
		)
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="5126">基础班</font></strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(new PairIdController())
	}

	void isProperCorrelationId(Integer correlationId) {
		assert correlationId == 123456
	}

	void isEmpty(String value) {
		assert value == null
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5127">重要</font></div>
</td>
<td class="content"><font o="5128">
您不能同时使用String和<code i="2578">execute</code>来执行连接。</font><font o="5129">例如呼叫<code i="2579">header('Authorization', 'Bearer ' + execute('authToken()'))</code>将导致不正确的结果。</font><font o="5130">要使此工作只需调用<code i="2580">header('Authorization', execute('authToken()'))</code>，并确保<code i="2581">authToken()</code>方法返回您需要的所有内容。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_referencing_request_from_response"><font o="5131">从响应引用请求</font></h5>
<div class="paragraph">
<p><font o="5132">最好的情况是提供固定值，但有时您需要在响应中引用请求。</font><font o="5133">为了做到这一点，您可以从<code i="2582">fromRequest()</code>方法中获利，从而允许您从HTTP请求中引用一堆元素。</font><font o="5134">您可以使用以下选项：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5135"><code i="2583">fromRequest().url()</code>  - 返回请求URL</font></p>
</li>
<li>
<p><font o="5136"><code i="2584">fromRequest().query(String key)</code>  - 返回具有给定名称的第一个查询参数</font></p>
</li>
<li>
<p><font o="5137"><code i="2585">fromRequest().query(String key, int index)</code>  - 返回具有给定名称的第n个查询参数</font></p>
</li>
<li>
<p><font o="5138"><code i="2586">fromRequest().header(String key)</code>  - 返回具有给定名称的第一个标题</font></p>
</li>
<li>
<p><font o="5139"><code i="2587">fromRequest().header(String key, int index)</code>  - 返回具有给定名称的第n个标题</font></p>
</li>
<li>
<p><font o="5140"><code i="2588">fromRequest().body()</code>  - 返回完整的请求体</font></p>
</li>
<li>
<p><font o="5141"><code i="2589">fromRequest().body(String jsonPath)</code>  - 从与JSON路径匹配的请求中返回元素</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="5142">我们来看看下面的合同</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		url('/api/v1/xxxx') {
			queryParameters {
				parameter("foo", "bar")
				parameter("foo", "bar2")
			}
		}
		headers {
			header(authorization(), "secret")
			header(authorization(), "secret2")
		}
		body(foo: "bar", baz: 5)
	}
	response {
		status 200
		headers {
			header(authorization(), "foo ${fromRequest().header(authorization())} bar")
		}
		body(
				url: fromRequest().url(),
				param: fromRequest().query("foo"),
				paramIndex: fromRequest().query("foo", 1),
				authorization: fromRequest().header("Authorization"),
				authorization2: fromRequest().header("Authorization", 1),
				fullBody: fromRequest().body(),
				responseFoo: fromRequest().body('$.foo'),
				responseBaz: fromRequest().body('$.baz'),
				responseBaz2: "Bla bla ${fromRequest().body('$.foo')} bla bla"
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5143">运行JUnit测试代码将导致创建一个或多或少这样的测试</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Authorization", "secret")
   .header("Authorization", "secret2")
   .body("{\"foo\":\"bar\",\"baz\":5}");

// when:
 ResponseOptions response = given().spec(request)
   .queryParam("foo","bar")
   .queryParam("foo","bar2")
   .get("/api/v1/xxxx");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Authorization")).isEqualTo("foo secret bar");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("url").isEqualTo("/api/v1/xxxx");
 assertThatJson(parsedJson).field("fullBody").isEqualTo("{\"foo\":\"bar\",\"baz\":5}");
 assertThatJson(parsedJson).field("paramIndex").isEqualTo("bar2");
 assertThatJson(parsedJson).field("responseFoo").isEqualTo("bar");
 assertThatJson(parsedJson).field("authorization2").isEqualTo("secret2");
 assertThatJson(parsedJson).field("responseBaz").isEqualTo(5);
 assertThatJson(parsedJson).field("responseBaz2").isEqualTo("Bla bla bar bla bla");
 assertThatJson(parsedJson).field("param").isEqualTo("bar");
 assertThatJson(parsedJson).field("authorization").isEqualTo("secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5144">您可以看到请求中的元素在响应中已被正确引用。</font></p>
</div>
<div class="paragraph">
<p><font o="5145">生成的WireMock存根将看起来或多或少是这样的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
  "request" : {
    "urlPath" : "/api/v1/xxxx",
    "method" : "POST",
    "headers" : {
      "Authorization" : {
        "equalTo" : "secret2"
      }
    },
    "queryParameters" : {
      "foo" : {
        "equalTo" : "bar2"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.baz == 5)]"
    }, {
      "matchesJsonPath" : "$[?(@.foo == 'bar')]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"url\":\"{{{request.url}}}\",\"param\":\"{{{request.query.foo.[0]}}}\",\"paramIndex\":\"{{{request.query.foo.[1]}}}\",\"authorization\":\"{{{request.headers.Authorization.[0]}}}\",\"authorization2\":\"{{{request.headers.Authorization.[1]}}}\",\"fullBody\":\"{{{escapejsonbody}}}\",\"responseFoo\":\"{{{jsonpath this '$.foo'}}}\",\"responseBaz\":{{{jsonpath this '$.baz'}}} ,\"responseBaz2\":\"Bla bla {{{jsonpath this '$.foo'}}} bla bla\"}",
    "headers" : {
      "Authorization" : "{{{request.headers.Authorization.[0]}}}"
    },
    "transformers" : [ "response-template" ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5146">因此，发送请求作为合同<code i="2590">request</code>部分提出的请求将导致发送以下响应主体</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">{
  "url" : "/api/v1/xxxx?foo=bar&amp;foo=bar2",
  "param" : "bar",
  "paramIndex" : "bar2",
  "authorization" : "secret",
  "authorization2" : "secret2",
  "fullBody" : "{\"foo\":\"bar\",\"baz\":5}",
  "responseFoo" : "bar",
  "responseBaz" : 5,
  "responseBaz2" : "Bla bla bar bla bla"
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5147">重要</font></div>
</td>
<td class="content"><font o="5148">
此功能仅适用于版本大于或等于2.5.1的WireMock。</font><font o="5149">我们正在使用WireMock的<code i="2591">response-template</code>响应变压器。</font><font o="5150">它使用Handlebars将Mustache <code i="2592">{{{ }}}</code>模板转换成正确的值。</font><font o="5151">另外我们正在注册2个帮助函数。</font><font o="5152"><code i="2593">escapejsonbody</code>  - 以可嵌入JSON的格式转义请求正文。</font><font o="5153">另一个是<code i="2594">jsonpath</code>对于给定的参数知道如何在请求体中查找对象。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_dynamic_properties_in_matchers_sections"><font o="5154">匹配部分的动态属性</font></h5>
<div class="paragraph">
<p><font o="5155">如果您一直在使用</font><a href="https://docs.pact.io/"><font o="5155">Pact，</font></a><font o="5155">这似乎很熟悉。</font><font o="5156">很多用户习惯于在身体和设定合约的动态部分之间进行分隔。</font></p>
</div>
<div class="paragraph">
<p><font o="5157">这就是为什么你可以从两个不同的部分获利。</font><font o="5158">一个称为<code i="2595">stubMatchers</code>，您可以在其中定义应该存在于存根中的动态值。</font><font o="5159">您可以在合同的<code i="2596">request</code>或<code i="2597">inputMessage</code>部分设置。</font><font o="5160">另一个称为<code i="2598">testMatchers</code>，它存在于合同的<code i="2599">response</code>或<code i="2600">outputMessage</code>方面。</font></p>
</div>
<div class="paragraph">
<p><font o="5161">目前，我们仅支持具有以下匹配可能性的基于JSON路径的匹配器。</font><font o="5162">对于<code i="2601">stubMatchers</code>：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5163"><code i="2602">byEquality()</code>  - 通过提供的JSON路径从响应中获取的值需要等于合同中提供的值</font></p>
</li>
<li>
<p><font o="5164"><code i="2603">byRegex(…​)</code>  - 通过提供的JSON路径从响应中获取的值需要与正则表达式匹配</font></p>
</li>
<li>
<p><font o="5165"><code i="2604">byDate()</code>  - 通过提供的JSON路径从响应中获取的值需要与ISO Date的正则表达式匹配</font></p>
</li>
<li>
<p><font o="5166"><code i="2605">byTimestamp()</code>  - 通过提供的JSON路径从响应中获取的值需要与ISO DateTime的正则表达式匹配</font></p>
</li>
<li>
<p><font o="5167"><code i="2606">byTime()</code>  - 通过提供的JSON路径从响应中获取的值需要匹配ISO时间的正则表达式</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="5168">对于<code i="2607">testMatchers</code>：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5169"><code i="2608">byEquality()</code>  - 通过提供的JSON路径从响应中获取的值需要等于合同中提供的值</font></p>
</li>
<li>
<p><font o="5170"><code i="2609">byRegex(…​)</code>  - 通过提供的JSON路径从响应中获取的值需要与正则表达式匹配</font></p>
</li>
<li>
<p><font o="5171"><code i="2610">byDate()</code>  - 通过提供的JSON路径从响应中获取的值需要与ISO Date的正则表达式匹配</font></p>
</li>
<li>
<p><font o="5172"><code i="2611">byTimestamp()</code>  - 通过提供的JSON路径从响应中获取的值需要匹配ISO DateTime的正则表达式</font></p>
</li>
<li>
<p><font o="5173"><code i="2612">byTime()</code>  - 通过提供的JSON路径从响应中获取的值需要匹配ISO时间的正则表达式</font></p>
</li>
<li>
<p><font o="5174"><code i="2613">byType()</code>  - 通过提供的JSON路径从响应中获取的值需要与合同中的响应正文中定义的类型相同。</font><font o="5175"><code i="2614">byType</code>可以关闭，您可以设置<code i="2615">minOccurrence</code>和<code i="2616">maxOccurrence</code>。</font><font o="5176">这样你可以断定集合的大小。</font></p>
</li>
<li>
<p><font o="5177"><code i="2617">byCommand(…​)</code>  - 通过提供的JSON路径从响应中获取的值将作为您提供的自定义方法的输入传递。</font><font o="5178">例如<code i="2618">byCommand('foo($it)')</code>将导致调用匹配JSON路径的值将被通过的<code i="2619">foo</code>方法。</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="5179">我们来看看下面的例子：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract contractDsl = Contract.make {
	request {
		method 'GET'
		urlPath '/get'
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string"
		])
		stubMatchers {
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			jsonPath('$.duck', byEquality())
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
		}
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body([
				duck: 123,
				alpha: "abc",
				number: 123,
				aBoolean: true,
				date: "2017-01-01",
				dateTime: "2017-01-01T01:23:45",
				time: "01:02:34",
				valueWithoutAMatcher: "foo",
				valueWithTypeMatch: "string",
				valueWithMin: [
					1,2,3
				],
				valueWithMax: [
					1,2,3
				],
				valueWithMinMax: [
					1,2,3
				],
				valueWithMinEmpty: [],
				valueWithMaxEmpty: [],
		])
		testMatchers {
			// asserts the jsonpath value against manual regex
			jsonPath('$.duck', byRegex("[0-9]{3}"))
			// asserts the jsonpath value against the provided value
			jsonPath('$.duck', byEquality())
			// asserts the jsonpath value against some default regex
			jsonPath('$.alpha', byRegex(onlyAlphaUnicode()))
			jsonPath('$.alpha', byEquality())
			jsonPath('$.number', byRegex(number()))
			jsonPath('$.aBoolean', byRegex(anyBoolean()))
			// asserts vs inbuilt time related regex
			jsonPath('$.date', byDate())
			jsonPath('$.dateTime', byTimestamp())
			jsonPath('$.time', byTime())
			// asserts that the resulting type is the same as in response body
			jsonPath('$.valueWithTypeMatch', byType())
			jsonPath('$.valueWithMin', byType {
				// results in verification of size of array (min 1)
				minOccurrence(1)
			})
			jsonPath('$.valueWithMax', byType {
				// results in verification of size of array (max 3)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinMax', byType {
				// results in verification of size of array (min 1 &amp; max 3)
				minOccurrence(1)
				maxOccurrence(3)
			})
			jsonPath('$.valueWithMinEmpty', byType {
				// results in verification of size of array (min 0)
				minOccurrence(0)
			})
			jsonPath('$.valueWithMaxEmpty', byType {
				// results in verification of size of array (max 0)
				maxOccurrence(0)
			})
			// will execute a method `assertThatValueIsANumber`
			jsonPath('$.duck', byCommand('assertThatValueIsANumber($it)'))
		}
		headers {
			contentType(applicationJson())
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5180">在这个例子中，我们在匹配器部分提供合同的动态部分。</font><font o="5181">对于请求部分，您可以看到对于所有字段，但是<code i="2620">valueWithoutAMatcher</code>我们正在明确地设置我们希望存根包含的正则表达式的值。</font><font o="5182">对于<code i="2621">valueWithoutAMatcher</code>，验证将以与不使用匹配器相同的方式进行 - 在这种情况下，测试将执行相等检查。</font></p>
</div>
<div class="paragraph">
<p><font o="5183">对于<code i="2622">testMatchers</code>部分的响应方面，我们以类似的方式定义所有的动态部分。</font><font o="5184">唯一的区别是我们也有<code i="2623">byType</code>匹配器。</font><font o="5185">在这种情况下，我们正在检查4个字段，我们正在验证测试的响应是否具有一个值，其JSON路径与给定字段匹配的类型与响应主体中定义的相同，</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5186">对于<code i="2624">$.valueWithTypeMatch</code>  - 我们只是检查类型是否相同</font></p>
</li>
<li>
<p><font o="5187">对于<code i="2625">$.valueWithMin</code>  - 我们正在检查类型，并声明大小是否大于或等于最小出现次数</font></p>
</li>
<li>
<p><font o="5188">对于<code i="2626">$.valueWithMax</code>  - 我们正在检查类型，并声明大小是否小于或等于最大值</font></p>
</li>
<li>
<p><font o="5189">对于<code i="2627">$.valueWithMinMax</code>  - 我们正在检查类型，并确定大小是否在最小和最大值之间</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font o="5190">所得到的测试或多或少会看起来像这样（请注意，我们将自动生成的断言与匹配器与<code i="2628">and</code>部分分开）：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Content-Type", "application/json")
   .body("{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\"}");

// when:
 ResponseOptions response = given().spec(request)
   .get("/get");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Content-Type")).matches("application/json.*");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("valueWithoutAMatcher").isEqualTo("foo");
// and:
 assertThat(parsedJson.read("$.duck", String.class)).matches("[0-9]{3}");
 assertThat(parsedJson.read("$.duck", Integer.class)).isEqualTo(123);
 assertThat(parsedJson.read("$.alpha", String.class)).matches("[\\p{L}]*");
 assertThat(parsedJson.read("$.alpha", String.class)).isEqualTo("abc");
 assertThat(parsedJson.read("$.number", String.class)).matches("-?\\d*(\\.\\d+)?");
 assertThat(parsedJson.read("$.aBoolean", String.class)).matches("(true|false)");
 assertThat(parsedJson.read("$.date", String.class)).matches("(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])");
 assertThat(parsedJson.read("$.dateTime", String.class)).matches("([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat(parsedJson.read("$.time", String.class)).matches("(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat((Object) parsedJson.read("$.valueWithTypeMatch")).isInstanceOf(java.lang.String.class);
 assertThat((Object) parsedJson.read("$.valueWithMin")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMin", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(1);
 assertThat((Object) parsedJson.read("$.valueWithMax")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMax", java.util.Collection.class)).hasSizeLessThanOrEqualTo(3);
 assertThat((Object) parsedJson.read("$.valueWithMinMax")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMinMax", java.util.Collection.class)).hasSizeBetween(1, 3);
 assertThat((Object) parsedJson.read("$.valueWithMinEmpty")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMinEmpty", java.util.Collection.class)).hasSizeGreaterThanOrEqualTo(0);
 assertThat((Object) parsedJson.read("$.valueWithMaxEmpty")).isInstanceOf(java.util.List.class);
 assertThat(parsedJson.read("$.valueWithMaxEmpty", java.util.Collection.class)).hasSizeLessThanOrEqualTo(0);
 assertThatValueIsANumber(parsedJson.read("$.duck"));</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5191">和WireMock这样的stub：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-json" data-lang="json">				'''
{
  "request" : {
    "urlPath" : "/get",
    "method" : "GET",
    "headers" : {
      "Content-Type" : {
        "matches" : "application/json.*"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.valueWithoutAMatcher == 'foo')]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithTypeMatch == 'string')]"
    }, {
      "matchesJsonPath" : "$.list.some.nested[?(@.anothervalue == 4)]"
    }, {
      "matchesJsonPath" : "$.list.someother.nested[?(@.anothervalue == 4)]"
    }, {
      "matchesJsonPath" : "$.list.someother.nested[?(@.json == 'with value')]"
    }, {
      "matchesJsonPath" : "$[?(@.duck =~ /([0-9]{3})/)]"
    }, {
      "matchesJsonPath" : "$[?(@.duck == 123)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha =~ /([\\\\p{L}]*)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha == 'abc')]"
    }, {
      "matchesJsonPath" : "$[?(@.number =~ /(-?\\\\d*(\\\\.\\\\d+)?)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.aBoolean =~ /((true|false))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.date =~ /((\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.dateTime =~ /(([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.time =~ /((2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$.list.some.nested[?(@.json =~ /(.*)/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\\"duck\\":123,\\"alpha\\":\\"abc\\",\\"number\\":123,\\"aBoolean\\":true,\\"date\\":\\"2017-01-01\\",\\"dateTime\\":\\"2017-01-01T01:23:45\\",\\"time\\":\\"01:02:34\\",\\"valueWithoutAMatcher\\":\\"foo\\",\\"valueWithTypeMatch\\":\\"string\\",\\"valueWithMin\\":[1,2,3],\\"valueWithMax\\":[1,2,3],\\"valueWithMinMax\\":[1,2,3]}",
    "headers" : {
      "Content-Type" : "application/json"
    }
  }
}
'''</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jax_rs_support"><font o="5192">JAX-RS支持</font></h4>
<div class="paragraph">
<p><font o="5193">我们支持JAX-RS 2 Client API。</font><font o="5194">基类需要定义<code i="2629">protected WebTarget webTarget</code>和服务器初始化，现在唯一的选择如何测试JAX-RS API是启动一个Web服务器。</font></p>
</div>
<div class="paragraph">
<p><font o="5195">使用身体的请求需要设置内容类型，否则将使用<code i="2630">application/octet-stream</code>。</font></p>
</div>
<div class="paragraph">
<p><font o="5196">为了使用JAX-RS模式，请使用以下设置：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">testMode === 'JAXRSCLIENT'</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5197">生成测试API的示例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">'''
 // when:
  Response response = webTarget
    .path("/users")
    .queryParam("limit", "10")
    .queryParam("offset", "20")
    .queryParam("filter", "email")
    .queryParam("sort", "name")
    .queryParam("search", "55")
    .queryParam("age", "99")
    .queryParam("name", "Denis.Stepanov")
    .queryParam("email", "bob@email.com")
    .request()
    .method("GET");

  String responseAsString = response.readEntity(String.class);

 // then:
  assertThat(response.getStatus()).isEqualTo(200);
 // and:
  DocumentContext parsedJson = JsonPath.parse(responseAsString);
  assertThatJson(parsedJson).field("property1").isEqualTo("a");
'''</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_async_support"><font o="5198">异步支持</font></h4>
<div class="paragraph">
<p><font o="5199">如果您在服务器端使用异步通信（您的控制器正在返回<code i="2631">Callable</code>，<code i="2632">DeferredResult</code>等等，然后在合同中您必须在<code i="2633">response</code>部分中提供<code i="2634">async()</code>方法。 ：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        async()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_context_paths"><font o="5200">使用上下文路径</font></h4>
<div class="paragraph">
<p><font o="5201">Spring Cloud Contract支持上下文路径。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5202">重要</font></div>
</td>
<td class="content"><font o="5203">
为了完全支持上下文路径，唯一改变的是在</font><strong><font o="5203">PRODUCER</font></strong><font o="5203">端</font><font o="5203">的切换</font><font o="5203">。</font><font o="5204">自动生成测试需要使用</font><strong><font o="5204">EXPLICIT</font></strong><font o="5204">模式。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="5205">消费者方面保持不变，为了让生成的测试通过，您必须切换</font><strong><font o="5205">EXPLICIT</font></strong><font o="5205">模式。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="5206">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;testMode&gt;EXPLICIT&lt;/testMode&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="5207">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">contracts {
		testMode = 'EXPLICIT'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5208">这样就可以生成</font><strong><font o="5208">不</font></strong><font o="5208">使用MockMvc </font><font o="5208">的测试</font><font o="5208">。</font><font o="5209">这意味着您正在生成真实的请求，您需要设置生成的测试的基类以在真正的套接字上工作。</font></p>
</div>
<div class="paragraph">
<p><font o="5210">让我们想象下面的合同：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method 'GET'
		url '/my-context-path/url'
	}
	response {
		status 200
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5211">以下是一个如何设置基类和Rest Assured的示例，以使所有操作都正常工作。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">import com.jayway.restassured.RestAssured;
import org.junit.Before;
import org.springframework.boot.context.embedded.LocalServerPort;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(classes = ContextPathTestingBaseClass.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ContextPathTestingBaseClass {

	@LocalServerPort int port;

	@Before
	public void setup() {
		RestAssured.baseURI = "http://localhost";
		RestAssured.port = this.port;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5212">这样一来：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5213">您自动生成测试中的所有请求都将发送到包含上下文路径的实际端点（例如<code i="2635">/my-context-path/url</code>）</font></p>
</li>
<li>
<p><font o="5214">您的合同反映出您具有上下文路径，因此您生成的存根也将具有该信息（例如，在存根中您将看到您也调用了<code i="2636">/my-context-path/url</code>）</font></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_messaging_top_level_elements"><font o="5215">消息传递顶级元素</font></h4>
<div class="paragraph">
<p><font o="5216">消息传递的DSL与重点在HTTP上的DSL有点不同。</font></p>
</div>
<div class="sect4">
<h5 id="_output_triggered_by_a_method"><font o="5217">由方法触发的输出</font></h5>
<div class="paragraph">
<p><font o="5218">可以通过调用方法来触发输出消息（例如，调度程序启动并发送消息）</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def dsl = Contract.make {
	// Human readable description
	description 'Some description'
	// Label by means of which the output message can be triggered
	label 'some_label'
	// input to the contract
	input {
		// the contract will be triggered by a method
		triggeredBy('bookReturnedTriggered()')
	}
	// output message of the contract
	outputMessage {
		// destination to which the output message will be sent
		sentTo('output')
		// the body of the output message
		body('''{ "bookName" : "foo" }''')
		// the headers of the output message
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5219">在这种情况下，如果将执行一个称为<code i="2638">bookReturnedTriggered</code>的方法，输出消息将被发送到<code i="2637">output</code>。</font><font o="5220">在消息</font><strong><font o="5220">发布者的</font></strong><font o="5220">一方，我们将生成一个测试，该测试将调用该方法来触发该消息。</font><font o="5221">在</font><strong><font o="5221">消费者</font></strong><font o="5221">端，您可以使用<code i="2639">some_label</code>触发消息。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_output_triggered_by_a_message"><font o="5222">由消息触发的输出</font></h5>
<div class="paragraph">
<p><font o="5223">可以通过接收消息来触发输出消息。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">def dsl = Contract.make {
	description 'Some Description'
	label 'some_label'
	// input is a message
	input {
		// the message was received from this destination
		messageFrom('input')
		// has the following body
		messageBody([
		        bookName: 'foo'
		])
		// and the following headers
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo('output')
		body([
		        bookName: 'foo'
		])
		headers {
			header('BOOK-NAME', 'foo')
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5224">在这种情况下，如果<code i="2641">input</code>目的地收到正确的消息，则输出消息将被发送到<code i="2640">output</code>。</font><font o="5225">在消息</font><strong><font o="5225">发布者的</font></strong><font o="5225">一方，我们将生成一个测试，它将输入消息发送到定义的目的地。</font><font o="5226">在</font><strong><font o="5226">消费者</font></strong><font o="5226">端，您可以向输入目的地发送消息，也可以使用<code i="2642">some_label</code>触发消息。</font></p>
</div>
</div>
<div class="sect4">
<h5 id="_consumer_producer"><font o="5227">消费者/生产者</font></h5>
<div class="paragraph">
<p><font o="5228">在HTTP中，您有一个概念<code i="2643">client</code> / <code i="2644">stub and `server</code> / <code i="2645">test</code>符号。</font><font o="5229">您也可以在消息中使用它们，但是我们还提供了下面提供的<code i="2646">consumer</code>和<code i="2647">produer</code>方法（请注意，您可以使用<code i="2648">$</code>或<code i="2649">value</code>方法来提供<code i="2650">consumer</code>和<code i="2651">producer</code>部分）</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">Contract.make {
	label 'some_label'
	input {
		messageFrom value(consumer('jms:output'), producer('jms:input'))
		messageBody([
				bookName: 'foo'
		])
		messageHeaders {
			header('sample', 'header')
		}
	}
	outputMessage {
		sentTo $(consumer('jms:input'), producer('jms:output'))
		body([
				bookName: 'foo'
		])
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_contracts_in_one_file"><font o="5230">一个文件中的多个合同</font></h4>
<div class="paragraph">
<p><font o="5231">可以在一个文件中定义多个合同。</font><font o="5232">这样的合同的例子可以这样看</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

[
        Contract.make {
            name("should post a user")
            request {
                method 'POST'
                url('/users/1')
            }
            response {
                status 200
            }
        },
        Contract.make {
            request {
                method 'POST'
                url('/users/2')
            }
            response {
                status 200
            }
        }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5233">在这个例子中，一个合同有<code i="2652">name</code>字段，另一个没有。</font><font o="5234">这将导致生成两个或多或少这样的测试：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

	@Test
	public void validate_should_post_a_user() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

	@Test
	public void validate_withList_1() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.post("/users/2");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5235">请注意，对于具有<code i="2653">name</code>字段的合同，生成的测试方法名为<code i="2654">validate_should_post_a_user</code>。</font><font o="5236">对于没有名称的人<code i="2655">validate_withList_1</code>。</font><font o="5237">它对应于文件<code i="2656">WithList.groovy</code>的名称和列表中的合同索引。</font></p>
</div>
<div class="paragraph">
<p><font o="5238">生成的存根将看起来像这样</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>should post a user.json
1_WithList.json</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5239">您可以看到第一个文件从合同中获取了<code i="2657">name</code>参数。</font><font o="5240">第二个获得了以索引为前缀的合同文件<code i="2658">WithList.groovy</code>的名称（在这种情况下，合同在文件中的合同列表中具有索引<code i="2659">1</code>）。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5241">提示</font></div>
</td>
<td class="content"><font o="5242">
正如你可以看到，如果您的合同名称更好，那么您的测试更有意义。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customization"><font o="5243">定制</font></h3>
<div class="sect3">
<h4 id="_extending_the_dsl"><font o="5244">扩展DSL</font></h4>
<div class="paragraph">
<p><font o="5245">可以向DSL提供自己的功能。</font><font o="5246">此功能的关键要求是保持静态兼容性。</font><font o="5247">下面你可以看到一个例子：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><font o="5248">创建具有可重用类的JAR</font></p>
</li>
<li>
<p><font o="5249">在DSL中引用这些类</font></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><font></font><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples"><font o="5250">这里</font></a><font o="5250">可以找到完整的例子</font><font o="5250">。</font></p>
</div>
<div class="sect4">
<h5 id="_common_jar"><font o="5251">普通JAR</font></h5>
<div class="paragraph">
<p><font o="5252">下面你可以找到我们将在DSL中重用的三个类。</font></p>
</div>
<div class="paragraph">
<p><strong><font o="5253">PatternUtils</font></strong><font o="5253">包含</font><strong><font o="5253">消费者</font></strong><font o="5253">和</font><strong><font o="5253">制作者使用的功能</font></strong><font o="5253">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.example;

import java.util.regex.Pattern;

/**
 * If you want to use {@link Pattern} directly in your tests
 * then you can create a class resembling this one. It can
 * contain all the {@link Pattern} you want to use in the DSL.
 *
 * &lt;pre&gt;
 * {@code
 * request {
 *     body(
 *         [ age: $(c(PatternUtils.oldEnough()))]
 *     )
 * }
 * &lt;/pre&gt;
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */
public class PatternUtils {
	public static String tooYoung() {
		return "[0-1][0-9]";
	}

	public static Pattern oldEnough() {
		return Pattern.compile("[2-9][0-9]");
	}

	public static Pattern anyName() {
		return Pattern.compile("[a-zA-Z]+");
	}

	/**
	 * Makes little sense but it's just an example ;)
	 */
	public static Pattern ok() {
		return Pattern.compile("OK");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="5254">ConsumerUtils</font></strong><font o="5254">包含由使用功能的</font><strong><font o="5254">消费者</font></strong><font o="5254">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ClientDslProperty;
import org.springframework.cloud.contract.spec.internal.DslProperty;

/**
 * DSL Properties passed to the DSL from the consumer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you can have a regular expression.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you have to have a concrete value.
 *
 * @author Marcin Grzejszczak
 */
public class ConsumerUtils {
	/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ age: $(ConsumerUtils.oldEnough())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the consumer side value of age field will be
	 * a regular expression and the producer side will be generated.
	 *
	 * @author Marcin Grzejszczak
	 */
	public static ClientDslProperty oldEnough() {
		return new ClientDslProperty(PatternUtils.oldEnough());
	}

	/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ name: $(ConsumerUtils.anyName())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the consumer will be a regular expression and the
	 * producer side value will be equal to {@code marcin}
	 */
	public static DslProperty anyName() {
		return new DslProperty&lt;&gt;(PatternUtils.anyName(), "marcin");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong><font o="5255">ProducerUtils</font></strong><font o="5255">包含由使用的功能</font><strong><font o="5255">制片人</font></strong><font o="5255">。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ServerDslProperty;

/**
 * DSL Properties passed to the DSL from the producer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you have to have a concrete value.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you can have a regular expression.
 *
 * @author Marcin Grzejszczak
 */
public class ProducerUtils {

	/**
	 * Producer side property. By using the {@link ProducerUtils}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * response {
	 *     body(
	 *         [ status: $(ProducerUtils.ok())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way the producer side value of age field will be
	 * a regular expression and the consumer side will be generated.
	 */
	public static ServerDslProperty ok() {
		return new ServerDslProperty(PatternUtils.ok());
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adding_the_dependency_to_project"><font o="5256">将依赖项添加到项目中</font></h5>
<div class="paragraph">
<p><font o="5257">为了使插件和IDE能够引用常见的JAR类，您需要将依赖关系传递给您的项目。</font></p>
</div>
<div class="sect5">
<h6 id="_test_dependency_in_project_s_dependencies"><font o="5258">测试依赖项目的依赖关系</font></h6>
<div class="paragraph">
<p><font o="5259">首先将常见的jar依赖项添加为测试依赖关系。</font><font o="5260">这样，由于您的合同文件在测试资源路径中可用，所以公用的jar类将自动显示在您的Groovy文件中。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="5261">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="5262">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">testCompile("com.example:beer-common:0.0.1-SNAPSHOT")</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_test_dependency_in_plugin_s_dependencies"><font o="5263">测试插件依赖关系</font></h6>
<div class="paragraph">
<p><font o="5264">现在你必须添加插件的依赖关系，以便在运行时重用。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="5265">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-contract-verifier&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.example&lt;/groupId&gt;
			&lt;artifactId&gt;beer-common&lt;/artifactId&gt;
			&lt;version&gt;${project.version}&lt;/version&gt;
			&lt;scope&gt;compile&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="5266">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">classpath "com.example:beer-common:0.0.1-SNAPSHOT"</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_referencing_classes_in_dsls"><font o="5267">在DSL中引用类</font></h6>
<div class="paragraph">
<p><font o="5268">现在您可以参考DSL中的课程。</font><font o="5269">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package contracts.beer.rest

import org.springframework.cloud.contract.spec.Contract

import static com.example.ConsumerUtils.oldEnough
import static com.example.ProducerUtils.ok

Contract.make {
	request {
		description("""
Represents a successful scenario of getting a beer

given:
	client is old enough
when:
	he applies for a beer
then:
	we'll grant him the beer
""")
		method 'POST'
		url '/check'
		body(
				age: $(oldEnough())
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status 200
		body("""
			{
				"status": "${value(ok())}"
			}
			""")
		headers {
			contentType(applicationJson())
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pluggable_architecture"><font o="5270">可插拔架构</font></h3>
<div class="paragraph">
<p><font o="5271">在某些情况下，您将合同定义为其他格式，如YAML，RAML或PACT。</font><font o="5272">另一方面，您希望从测试和存根生成中获利。</font><font o="5273">添加自己的任何一个实现是很容易的。</font><font o="5274">此外，您还可以自定义测试生成的方式（例如，您可以为其他语言生成测试），并且可以对存根生成执行相同操作（可为其他存根http服务器实现生成存根）。</font></p>
</div>
<div class="sect3">
<h4 id="_custom_contract_converter"><font o="5275">定制合同转换器</font></h4>
<div class="paragraph">
<p><font o="5276">我们假设您的合同是用YAML文件写成的：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-yml" data-lang="yml">request:
  url: /foo
  method: PUT
  headers:
    foo: bar
  body:
    foo: bar
response:
  status: 200
  headers:
    foo2: bar
  body:
    foo2: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5277">感谢界面</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.spec

/**
 * Converter to be used to convert FROM {@link File} TO {@link Contract}
 * and from {@link Contract} to {@code T}
 *
 * @param &lt;T&gt; - type to which we want to convert the contract
 *
 * @author Marcin Grzejszczak
 * @since 1.1.0
 */
interface ContractConverter&lt;T&gt; {

	/**
	 * Should this file be accepted by the converter. Can use the file extension
	 * to check if the conversion is possible.
	 *
	 * @param file - file to be considered for conversion
	 * @return - {@code true} if the given implementation can convert the file
	 */
	boolean isAccepted(File file)

	/**
	 * Converts the given {@link File} to its {@link Contract} representation
	 *
	 * @param file - file to convert
	 * @return - {@link Contract} representation of the file
	 */
	Collection&lt;Contract&gt; convertFrom(File file)

	/**
	 * Converts the given {@link Contract} to a {@link T} representation
	 *
	 * @param contract - the parsed contract
	 * @return - {@link T} the type to which we do the conversion
	 */
	T convertTo(Collection&lt;Contract&gt; contract)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5278">您可以注册自己的合同结构转换器的实现。</font><font o="5279">您的实现需要说明开始转换的条件。</font><font o="5280">此外，您必须定义如何以两种方式执行转换。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5281">重要</font></div>
</td>
<td class="content"><font o="5282">
创建实施后，您必须创建一个<code i="2660">/META-INF/spring.factories</code>文件，您可以在其中提供实施的完全限定名称。
</font></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><font o="5283"><code i="2661">spring.factories</code>文件的示例</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code># Converters
org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.verifier.converter.YamlContractConverter</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5284">和YAML实现</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.converter

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.spec.Contract
import org.springframework.cloud.contract.spec.ContractConverter
import org.springframework.cloud.contract.spec.internal.Headers
import org.yaml.snakeyaml.Yaml

/**
 * Simple converter from and to a {@link YamlContract} to a collection of {@link Contract}
 */
@CompileStatic
class YamlContractConverter implements ContractConverter&lt;List&lt;YamlContract&gt;&gt; {

	@Override
	public boolean isAccepted(File file) {
		String name = file.getName()
		return name.endsWith(".yml") || name.endsWith(".yaml")
	}

	@Override
	public Collection&lt;Contract&gt; convertFrom(File file) {
		try {
			YamlContract yamlContract = new Yaml().loadAs(new FileInputStream(file), YamlContract.class)
			return [Contract.make {
				request {
					method(yamlContract?.request?.method)
					url(yamlContract?.request?.url)
					headers {
						yamlContract?.request?.headers?.each { String key, Object value -&gt;
							header(key, value)
						}
					}
					body(yamlContract?.request?.body)
				}
				response {
					status(yamlContract?.response?.status)
					headers {
						yamlContract?.response?.headers?.each { String key, Object value -&gt;
							header(key, value)
						}
					}
					body(yamlContract?.response?.body)
				}
			}]
		}
		catch (FileNotFoundException e) {
			throw new IllegalStateException(e)
		}
	}

	@Override
	public List&lt;YamlContract&gt; convertTo(Collection&lt;Contract&gt; contracts) {
		return contracts.collect { Contract contract -&gt;
			YamlContract yamlContract = new YamlContract()
			yamlContract.request.with {
				method = contract?.request?.method?.clientValue
				url = contract?.request?.url?.clientValue
				headers = (contract?.request?.headers as Headers)?.asStubSideMap()
				body = contract?.request?.body?.clientValue as Map
			}
			yamlContract.response.with {
				status = contract?.response?.status?.clientValue as Integer
				headers = (contract?.response?.headers as Headers)?.asStubSideMap()
				body = contract?.response?.body?.clientValue as Map
			}
			return yamlContract
		}
	}
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_pact_converter"><font o="5285">契约转换器</font></h5>
<div class="paragraph">
<p><font o="5286">Spring Cloud Contract提供了</font><a href="https://docs.pact.io/"><font o="5286">协议</font></a><font o="5286">代表合同的开箱</font><font o="5286">即用支持</font><font o="5286">。</font><font o="5287">换句话说，而不是使用Groovy DSL，您可以使用Pact文件。</font><font o="5288">在本节中，我们将介绍如何为您的项目添加此类支持。</font></p>
</div>
<div class="sect5">
<h6 id="_pact_contract"><font o="5289">契约契约</font></h6>
<div class="paragraph">
<p><font o="5290">我们将在下面的一个契约契约的例子中工作。</font><font o="5291">我们将此文件放在<code i="2662">src/test/resources/contracts</code>文件夹下。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-javascript" data-lang="javascript">{
  "provider": {
    "name": "Provider"
  },
  "consumer": {
    "name": "Consumer"
  },
  "interactions": [
    {
      "description": "",
      "request": {
        "method": "PUT",
        "path": "/fraudcheck",
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json"
        },
        "body": {
          "clientId": "1234567890",
          "loanAmount": 99999
        },
        "matchingRules": {
          "$.body.clientId": {
            "match": "regex",
            "regex": "[0-9]{10}"
          }
        }
      },
      "response": {
        "status": 200,
        "headers": {
          "Content-Type": "application/vnd.fraud.v1+json;charset=UTF-8"
        },
        "body": {
          "fraudCheckStatus": "FRAUD",
          "rejectionReason": "Amount too high"
        },
        "matchingRules": {
          "$.body.fraudCheckStatus": {
            "match": "regex",
            "regex": "FRAUD"
          }
        }
      }
    }
  ],
  "metadata": {
    "pact-specification": {
      "version": "2.0.0"
    },
    "pact-jvm": {
      "version": "2.4.18"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_pact_for_producers"><font o="5292">生产者契约</font></h6>
<div class="paragraph">
<p><font o="5293">在生产者方面，您可以添加两个附加依赖关系的插件配置。</font><font o="5294">一个是Spring Cloud Contract Pact支持，另一个表示您正在使用的当前Pact版本。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="5295">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
	&lt;extensions&gt;true&lt;/extensions&gt;
	&lt;configuration&gt;
		&lt;packageWithBaseClasses&gt;com.example.fraud&lt;/packageWithBaseClasses&gt;
	&lt;/configuration&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
			&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
			&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
			&lt;version&gt;2.4.18&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="5296">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">classpath "org.springframework.cloud:spring-cloud-contract-spec-pact:${findProperty('verifierVersion') ?: verifierVersion}"
classpath 'au.com.dius:pact-jvm-model:2.4.18'</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5297">当您执行应用程序的构建时，将会产生一个或多或少的这样的测试</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
	// given:
		MockMvcRequestSpecification request = given()
				.header("Content-Type", "application/vnd.fraud.v1+json")
				.body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

	// when:
		ResponseOptions response = given().spec(request)
				.put("/fraudcheck");

	// then:
		assertThat(response.statusCode()).isEqualTo(200);
		assertThat(response.header("Content-Type")).isEqualTo("application/vnd.fraud.v1+json;charset=UTF-8");
	// and:
		DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
		assertThatJson(parsedJson).field("rejectionReason").isEqualTo("Amount too high");
	// and:
		assertThat(parsedJson.read("$.fraudCheckStatus", String.class)).matches("FRAUD");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5298">并且这样的存根看起来像这样</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-javascript" data-lang="javascript">{
  "uuid" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "request" : {
    "url" : "/fraudcheck",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/vnd.fraud.v1+json"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.loanAmount == 99999)]"
    }, {
      "matchesJsonPath" : "$[?(@.clientId =~ /([0-9]{10})/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}",
    "headers" : {
      "Content-Type" : "application/vnd.fraud.v1+json;charset=UTF-8"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_pact_for_consumers"><font o="5299">消费者契约</font></h6>
<div class="paragraph">
<p><font o="5300">在生产者方面，您可以添加项目依赖关系两个附加依赖关系。</font><font o="5301">一个是Spring Cloud Contract Pact支持，另一个表示您正在使用的当前Pact版本。</font></p>
</div>
<div class="listingblock primary">
<div class="title"><font o="5302">Maven的</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-spec-pact&lt;/artifactId&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;au.com.dius&lt;/groupId&gt;
	&lt;artifactId&gt;pact-jvm-model&lt;/artifactId&gt;
	&lt;version&gt;2.4.18&lt;/version&gt;
	&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title"><font o="5303">摇篮</font></div>
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">testCompile "org.springframework.cloud:spring-cloud-contract-spec-pact"
testCompile 'au.com.dius:pact-jvm-model:2.4.18'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_test_generator"><font o="5304">定制测试发生器</font></h4>
<div class="paragraph">
<p><font o="5305">如果您想为Java生成不同语言的测试，或者您不满意我们为您建立Java测试的方式，那么您可以注册自己的实现来做到这一点。</font></p>
</div>
<div class="paragraph">
<p><font o="5306">感谢界面</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.builder

import org.springframework.cloud.contract.verifier.config.ContractVerifierConfigProperties
import org.springframework.cloud.contract.verifier.file.ContractMetadata
/**
 * Builds a single test.
 *
 * @since 1.1.0
 */
interface SingleTestGenerator {

	/**
	 * Creates contents of a single test class in which all test scenarios from
	 * the contract metadata should be placed.
	 *
	 * @param properties - properties passed to the plugin
	 * @param listOfFiles - list of parsed contracts with additional metadata
	 * @param className - the name of the generated test class
	 * @param classPackage - the name of the package in which the test class should be stored
	 * @param includedDirectoryRelativePath - relative path to the included directory
	 * @return contents of a single test class
	 */
	String buildClass(ContractVerifierConfigProperties properties, Collection&lt;ContractMetadata&gt; listOfFiles,
					  String className, String classPackage, String includedDirectoryRelativePath)

	/**
	 * Extension that should be appended to the generated test class. E.g. {@code .java} or {@code .php}
	 *
	 * @param properties - properties passed to the plugin
	 */
	String fileExtension(ContractVerifierConfigProperties properties)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5307">您可以注册自己的生成测试的实现。</font><font o="5308">再次提供一个合适的<code i="2663">spring.factories</code>文件就足够了。</font><font o="5309">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code>org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_generator"><font o="5310">自定义存根发生器</font></h4>
<div class="paragraph">
<p><font o="5311">如果要为WireMock生成其他存根服务器的存根，就可以插入您自己的此接口的实现：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.verifier.converter

import groovy.transform.CompileStatic
import org.springframework.cloud.contract.spec.Contract
import org.springframework.cloud.contract.verifier.file.ContractMetadata

/**
 * Converts contracts into their stub representation.
 *
 * @since 1.1.0
 */
@CompileStatic
interface StubGenerator {

	/**
	 * Returns {@code true} if the converter can handle the file to convert it into a stub.
	 */
	boolean canHandleFileName(String fileName)

	/**
	 * Returns the collection of converted contracts into stubs. One contract can
	 * result in multiple stubs.
	 */
	Map&lt;Contract, String&gt; convertContents(String rootName, ContractMetadata content)

	/**
	 * Returns the name of the converted stub file. If you have multiple contracts
	 * in a single file then a prefix will be added to the generated file. If you
	 * provide the {@link Contract#name} field then that field will override the
	 * generated file name.
	 *
	 * Example: name of file with 2 contracts is {@code foo.groovy}, it will be
	 * converted by the implementation to {@code foo.json}. The recursive file
	 * converter will create two files {@code 0_foo.json} and {@code 1_foo.json}
	 */
	String generateOutputFileNameForInput(String inputFileName)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5312">您可以注册自己的生成存根的实现。</font><font o="5313">再次提供一个合适的<code i="2664">spring.factories</code>文件就足够了。</font><font o="5314">例：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code># Stub converters
org.springframework.cloud.contract.verifier.converter.StubGenerator=\
org.springframework.cloud.contract.verifier.wiremock.DslToWireMockClientConverter</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5315">默认实现是WireMock存根生成。</font></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5316">提示</font></div>
</td>
<td class="content"><font o="5317">
您可以提供多个存根生成器实现。</font><font o="5318">这样，例如从单个DSL作为输入，您可以例如生成WireMock存根和Pact文件！
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_runner"><font o="5319">自定义Stub Runner</font></h4>
<div class="paragraph">
<p><font o="5320">如果您决定使用自定义存根生成器，则还需要使用不同的存根提供程序来运行存根的自定义方式。</font></p>
</div>
<div class="paragraph">
<p><font o="5321">让我们假设您正在使用</font><a href="https://github.com/dreamhead/moco"><font o="5321">Moco</font></a><font o="5321">来构建您的存根。</font><font o="5322">你写了一个正确的存根生成器，你的存根被放在一个JAR文件中。</font></p>
</div>
<div class="paragraph">
<p><font o="5323">为了Stub Runner知道如何运行存根，您必须定义一个自定义的HTTP Stub服务器实现。</font><font o="5324">它可以看起来像这样：</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-groovy" data-lang="groovy">package org.springframework.cloud.contract.stubrunner.provider.moco

import com.github.dreamhead.moco.bootstrap.arg.HttpArgs
import com.github.dreamhead.moco.runner.JsonRunner
import org.springframework.cloud.contract.stubrunner.HttpServerStub
import org.springframework.util.SocketUtils

class MocoHttpServerStub implements HttpServerStub {

	private boolean started
	private JsonRunner runner
	private int port

	@Override
	int port() {
		if (!isRunning()) {
			return -1
		}
		return port
	}

	@Override
	boolean isRunning() {
		return started
	}

	@Override
	HttpServerStub start() {
		return start(SocketUtils.findAvailableTcpPort())
	}

	@Override
	HttpServerStub start(int port) {
		this.port = port
		return this
	}

	@Override
	HttpServerStub stop() {
		if (!isRunning()) {
			return this
		}
		this.runner.stop()
		return this
	}

	@Override
	HttpServerStub registerMappings(Collection&lt;File&gt; stubFiles) {
		List&lt;InputStream&gt; streams = stubFiles.collect { it.newInputStream() }
		this.runner = JsonRunner.newJsonRunnerWithStreams(streams,
				HttpArgs.httpArgs().withPort(this.port).build())
		this.runner.run()
		this.started = true
		return this
	}

	@Override
	boolean isAccepted(File file) {
		return file.name.endsWith(".json")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5325">并将其注册到您的<code i="2665">spring.factories</code>文件中</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code># Example of a custom HTTP Server Stub
org.springframework.cloud.contract.stubrunner.HttpServerStub=\
org.springframework.cloud.contract.stubrunner.provider.moco.MocoHttpServerStub</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5326">这样你就可以使用Moco来运行存根。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5327">重要</font></div>
</td>
<td class="content"><font o="5328">
如果您不提供任何实现，那么将选择默认的 - 基于WireMock的。</font><font o="5329">如果您提供多个，那么列表中的第一个将被选中。
</font></td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_stub_downloader"><font o="5330">自定义存根下载器</font></h4>
<div class="paragraph">
<p><font o="5331">您可以自定义存根的下载方式。</font><font o="5332">如果您不想以默认方式从Nexus / Artifactory下载JAR，您可以设置自己的实现。</font><font o="5333">下面您可以找到一个Stub Downloader Provider示例，它从classpath的测试资源获取<code i="2666">json</code>文件，将它们复制到临时文件，然后将该临时文件夹作为存根的根传递。</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code class="language-java" data-lang="java">package org.springframework.cloud.contract.stubrunner.provider.moco

import org.springframework.cloud.contract.stubrunner.StubConfiguration
import org.springframework.cloud.contract.stubrunner.StubDownloader
import org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder
import org.springframework.cloud.contract.stubrunner.StubRunnerOptions
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.Resource
import org.springframework.core.io.support.PathMatchingResourcePatternResolver

import java.nio.file.Files

/**
 * Poor man's version of taking stubs from classpath. It needs much more
 * love and attention to go to the main sources.
 *
 * @author Marcin Grzejszczak
 */
class ClasspathStubProvider implements StubDownloaderBuilder {

	private static final int TEMP_DIR_ATTEMPTS = 10000

	@Override
	public StubDownloader build(StubRunnerOptions stubRunnerOptions) {
		final StubConfiguration configuration = stubRunnerOptions.getDependencies().first()
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(
				new DefaultResourceLoader())
		try {
			String rootFolder = repoRoot(stubRunnerOptions) ?: "**/" + separatedArtifact(configuration) + "/**/*.json"
			Resource[] resources = resolver.getResources(rootFolder)
			final File tmp = createTempDir()
			tmp.deleteOnExit()
			// you'd have to write an impl to maintain the folder structure
			// this is just for demo
			resources.each { Resource resource -&gt;
				Files.copy(resource.getInputStream(), new File(tmp, resource.getFile().getName()).toPath())
			}
			return new StubDownloader() {
				@Override
				public Map.Entry&lt;StubConfiguration, File&gt; downloadAndUnpackStubJar(
						StubConfiguration stubConfiguration) {
					return new AbstractMap.SimpleEntry(configuration, tmp)
				}
			}
		} catch (IOException e) {
			throw new IllegalStateException(e)
		}
	}

	private String repoRoot(StubRunnerOptions stubRunnerOptions) {
		switch (stubRunnerOptions.stubRepositoryRoot) {
			case { !it }:
				return ""
			case { String root -&gt; root.endsWith("**/*.json") }:
				return stubRunnerOptions.stubRepositoryRoot
			default:
				return stubRunnerOptions.stubRepositoryRoot + "/**/*.json"
		}
	}

	private String separatedArtifact(StubConfiguration configuration) {
		return configuration.getGroupId().replace(".", File.separator) +
				File.separator + configuration.getArtifactId()
	}

	// Taken from Guava
	private File createTempDir() {
		File baseDir = new File(System.getProperty("java.io.tmpdir"))
		String baseName = System.currentTimeMillis() + "-"
		for (int counter = 0; counter &lt; TEMP_DIR_ATTEMPTS; counter++) {
			File tempDir = new File(baseDir, baseName + counter)
			if (tempDir.mkdir()) {
				return tempDir
			}
		}
		throw new IllegalStateException(
				"Failed to create directory within " + TEMP_DIR_ATTEMPTS + " attempts (tried " + baseName + "0 to " + baseName + (
						TEMP_DIR_ATTEMPTS - 1) + ")")
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5334">并将其注册到您的<code i="2667">spring.factories</code>文件中</font></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight notranslate"><code># Example of a custom Stub Downloader Provider
org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder=\
org.springframework.cloud.contract.stubrunner.provider.moco.ClasspathStubProvider</code></pre>
</div>
</div>
<div class="paragraph">
<p><font o="5335">这样你就可以选择一个文件夹与你的存根的来源。</font></p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title"><font o="5336">重要</font></div>
</td>
<td class="content"><font o="5337">
如果您没有提供任何实现，那么将选择从远程备份中下载存根的默认Aether。</font><font o="5338">如果您提供多个，那么列表中的第一个将被选中。
</font></td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_links"><font o="5339">链接</font></h3>
<div class="paragraph">
<p><font o="5340">在这里，您可以找到有关Spring Cloud Contract验证器的有趣链接：</font></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud/spring-cloud-contract/"><font o="5341">Spring Cloud Contract Github Repository</font></a></p>
</li>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/"><font o="5342">Spring Cloud Contract样本</font></a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html"><font o="5343">Spring Cloud Contract文档</font></a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/deprecated"><font o="5344">Accurest遗产文件</font></a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#spring-cloud-contract-stub-runner"><font o="5345">Spring Cloud Contract Stub Runner文档</font></a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html/#stub-runner-for-messaging"><font o="5346">Spring Cloud Contract Stub Runner消息传递文档</font></a></p>
</li>
<li>
<p><a href="https://gitter.im/spring-cloud/spring-cloud-contract"><font o="5347">Spring Cloud Contract Gitter</font></a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/"><font o="5348">Spring Cloud Contract Maven插件</font></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="_appendix_compendium_of_configuration_properties" class="sect0"><font o="5349">附录：配置纲要Properties</font></h1>
<div class="openblock partintro">
<div class="content">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><font o="5350">名称</font></th>
<th class="tableblock halign-left valign-top"><font o="5351">默认</font></th>
<th class="tableblock halign-left valign-top"><font o="5352">描述</font></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.fail-on-error</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5353">标记说，如果存在加密或解密错误，进程将失败。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.key</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5354">对称密钥。</font><font o="5355">作为一个更强大的替代方案，考虑使用密钥库。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.key-store.alias</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5356">商店中的钥匙别名</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.key-store.location</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5357">密钥存储文件的位置，例如classpath：/keystore.jks。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.key-store.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5358">锁定密钥库的密码。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.key-store.secret</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5359">秘密保护密钥（默认为密码相同）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.rsa.algorithm</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5360">使用RSA算法（DEFAULT或OEAP）。</font><font o="5361">一旦设置不改变它（或现有的密码将不可解密）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.rsa.salt</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">deadbeef</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5362">Salt用于加密密文的随机秘密。</font><font o="5363">一旦设置不改变它（或现有的密码将不可解密）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">encrypt.rsa.strong</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5364">标志表示应该在内部使用“强”AES加密。</font><font o="5365">如果为真，则将GCM算法应用于AES加密字节。</font><font o="5366">默认值为false（在这种情况下使用“标准”CBC代替）。</font><font o="5367">一旦设置不改变它（或现有的密码将不可解密）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.bus.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.bus.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.bus.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.consul.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.consul.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.consul.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.env.post.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5368">通过POST将环境更改为/ env。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.features.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.features.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.features.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.pause.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5369">启用/暂停端点（发送Lifecycle.stop（））。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.pause.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.pause.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.refresh.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5370">启用/ refresh端点刷新配置并重新初始化刷新作用域bean。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.refresh.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.refresh.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5371">启用/ restart端点重新启动应用程序上下文。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.pause-endpoint.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.pause-endpoint.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.pause-endpoint.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.resume-endpoint.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.resume-endpoint.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.resume-endpoint.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.restart.timeout</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.resume.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5372">启用/ resume端点（发送Lifecycle.start（））。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.resume.id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.resume.sensitive</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">endpoints.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5373">启用/ zookeeper端点来检查zookeeper的状态。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.allow-redirects</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5374">指示服务器是否可以将客户端请求重定向到备份服务器/集群。</font><font o="5375">如果设置为false，服务器将直接处理请求，如果设置为true，则可能会向客户端发送HTTP重定向，并具有新的服务器位置。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.availability-zones</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5376">获取此实例所在区域的可用性区域列表（用于AWS数据中心）。
</font></p><p class="tableblock"><font o="5377"> 更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.backup-registry-impl</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5378">获取执行BackupRegistry的实现的名称，以便仅在eureka客户端启动时首次将注册表信息作为回退选项提取。
</font></p><p class="tableblock"><font o="5379"> 对于需要额外的弹性的注册表信息的应用程序可能需要这一点，而无法运行它们。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.cache-refresh-executor-exponential-back-off-bound</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5380">缓存刷新执行者指数退出相关属性。</font><font o="5381">在发生超时序列的情况下，它是重试延迟的最大乘数值。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.cache-refresh-executor-thread-pool-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5382">cacheRefreshExecutor初始化的线程池大小</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.client-data-accept</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5383">EurekaAccept客户端数据接受名称</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.decoder-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5384">这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.disable-delta</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5385">指示eureka客户端是否应该禁用提取delta，而应该诉诸于获取完整的注册表信息。
</font></p><p class="tableblock"><font o="5386"> 请注意，增量获取可以极大地减少流量，因为尤利卡服务器的更改速率通常远低于提取速率。
</font></p><p class="tableblock"><font o="5387"> 更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.dollar-replacement</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">_-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5388">在eureka服务器的序列化/反序列化信息期间，获取Dollar符号&lt;code&gt; $ &lt;/ code&gt;的替换字符串。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5389">标记以指示启用Eureka客户端。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.encoder-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5390">这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.escape-char-replacement</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">__</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5391">在eureka服务器的序列化/反序列化信息期间获取下划线符号&lt;code&gt; _ &lt;/ code&gt;的替换字符串。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-connection-idle-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5392">表示到eureka服务器的HTTP连接可以在关闭之前保持空闲状态的时间（以秒为单位）。
</font></p><p class="tableblock"><font o="5393"> 在AWS环境中，建议值为30秒或更短，因为防火墙在几分钟内清除连接信息，将连接挂在空中</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-connect-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5394">指示在连接到eureka服务器需要超时之前等待（以秒为单位）的时间。</font><font o="5395">请注意，客户端中的连接由org.apache.http.client.HttpClient汇集，此设置会影响实际的连接创建以及从池中获取连接的等待时间。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-d-n-s-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5396">获取要查询的DNS名称以获取eureka服务器的列表。如果合同通过实现serviceUrls返回服务URL，则不需要此信息。
</font></p><p class="tableblock"><font o="5397"> 当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。
</font></p><p class="tableblock"><font o="5398"> 更改在运行时有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-port</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5399">获取用于构建服务url的端口，以在eureka服务器列表来自DNS时联系eureka服务器。如果合同返回服务url eurekaServerServiceUrls（String），则不需要此信息。
</font></p><p class="tableblock"><font o="5400"> 当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。
</font></p><p class="tableblock"><font o="5401"> 更改在运行时有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-read-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5402">指示从eureka服务器读取之前需要等待（秒）多久才能超时。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-total-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5403">获取从eureka客户端到所有eureka服务器允许的总连接数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-total-connections-per-host</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5404">获取从eureka客户端到eureka服务器主机允许的总连接数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-server-u-r-l-context</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5405">获取用于构建服务网址的URL上下文，以便在eureka服务器列表来自DNS时联系eureka服务器。</font><font o="5406">如果合同从eurekaServerServiceUrls返回服务网址，则不需要此信息。
</font></p><p class="tableblock"><font o="5407">当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。</font><font o="5408">更改在运行时有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.eureka-service-url-poll-interval-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5409">表示轮询对eureka服务器信息进行更改的频率（以秒为单位）。</font><font o="5410">可以添加或删除Eureka服务器，此设置控制eureka客户端应该知道的时间。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.fetch-registry</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5411">指示该客户端是否应从eureka服务器获取eureka注册表信息。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.fetch-remote-regions-registry</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5412">逗号分隔将获取eureka注册表信息的区域列表。</font><font o="5413">必须为availabilityZones返回的每个区域定义可用性区域。</font><font o="5414">否则，将导致发现客户端启动失败。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.filter-only-up-instances</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5415">指示是否在仅具有InstanceStatus UP状态的实例的过滤应用程序之后获取应用程序。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.g-zip-content</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5416">指示从服务器支持时，是否必须压缩从eureka服务器提取的内容。</font><font o="5417">来自eureka服务器的注册表信息被压缩以获得最佳的网络流量。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.heartbeat-executor-exponential-back-off-bound</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5418">心跳执行者指数回撤相关财产。</font><font o="5419">在发生超时序列的情况下，它是重试延迟的最大乘数值。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.heartbeat-executor-thread-pool-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5420">heartbeat执行器初始化的线程池大小</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.initial-instance-info-replication-interval-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5421">指示将实例信息复制到eureka服务器的开始时间（以秒为单位）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.instance-info-replication-interval-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5422">指示复制要复制到eureka服务器的实例更改的频率（以秒为单位）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.log-delta-diff</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5423">指示在注册表信息方面是否记录eureka服务器和eureka客户端之间的差异。
</font></p><p class="tableblock"><font o="5424">Eureka客户端尝试仅从欧莱雅服务器检索增量更改以最小化网络流量。</font><font o="5425">收到三角形后，eureka客户端将从服务器的信息进行协调，以验证它是否已经没有漏掉一些信息。</font><font o="5426">当客户端发生网络问题与服务器通信时，可能会发生调解失败。如果对帐失败，eureka客户端将获得完整的注册表信息。
</font></p><p class="tableblock"><font o="5427"> 在获取完整的注册表信息的同时，eureka客户端可以记录客户端和服务器之间的差异，并且此设置控制它。
</font></p><p class="tableblock"><font o="5428"> 更改在运行时在registryFetchIntervalSecondsr指定的下一个注册表提取周期中有效</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.on-demand-update-status-change</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5429">如果设置为true，则通过ApplicationInfoManager进行的本地状态更新将触发对远程eureka服务器的按需（但限速）注册/更新</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.prefer-same-zone-eureka</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5430">指示此实例是否应尝试在同一区域中使用尤里卡服务器延迟和/或其他原因。
</font></p><p class="tableblock"><font o="5431"> 理想情况下，eureka客户端配置为与同一区域中的服务器通信
</font></p><p class="tableblock"><font o="5432"> 更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.property-resolver</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.proxy-host</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5433">获取代理主机到eureka服务器（如果有的话）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.proxy-password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5434">获取代理密码（如果有）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.proxy-port</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5435">获取代理端口到eureka服务器（如果有的话）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.proxy-user-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5436">获取代理用户名（如果有）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.region</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">us-east-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5437">获取此实例所在的区域（用于AWS数据中心）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.register-with-eureka</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5438">指示此实例是否应将其信息注册到eureka服务器以供其他人发现。
</font></p><p class="tableblock"><font o="5439"> 在某些情况下，您不希望发现实例，而您只想发现其他实例。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.registry-fetch-interval-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5440">指示从eureka服务器获取注册表信息的频率（以秒为单位）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.registry-refresh-single-vip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5441">指示客户端是否只对单个VIP的注册表信息感兴趣。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.service-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5442">可用性区域映射到与eureka服务器通信的完全限定URL的列表。</font><font o="5443">每个值可以是单个URL或逗号分隔的替代位置列表。
</font></p><p class="tableblock"><font o="5444">通常，尤里卡服务器URL携带协议，主机，端口，上下文和版本信息（如果有的话）。</font><font o="5445">示例：</font><a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" class="bare"><font o="5445">http</font></a><font o="5445"> : </font><a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" class="bare"><font o="5445">//ec2-256-156-243-129.compute-1.amazonaws.com</font></a><font o="5445"> :
  </font><a href="http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/" class="bare"><font o="5445">7001/eureka/</font></a>
</p><p class="tableblock"><font o="5446"> 更改在运行时在eurekaServiceUrlPollIntervalSeconds指定的下一个服务网址刷新周期中有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.transport</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.client.use-dns-for-fetching-service-urls</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5447">指示eureka客户端是否应该使用DNS机制来获取要与之通信的eureka服务器列表。</font><font o="5448">当DNS名称更新为具有其他服务器时，该信息将在eureka客户端轮询该eurka​​ServiceUrlPollIntervalSeconds中指定的信息之后立即使用。
</font></p><p class="tableblock"><font o="5449"> 或者，服务urls可以返回serviceUrls，但用户应该实现自己的机制来返回更新的列表，以防发生更改。
</font></p><p class="tableblock"><font o="5450"> 更改在运行时有效。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.dashboard.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5451">标志以启用Eureka仪表板。</font><font o="5452">默认值为true。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.dashboard.path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5453">到Eureka仪表板（相对于servlet路径）的路径。</font><font o="5454">默认为“/”。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.a-s-g-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5455">获取与此实例关联的AWS自动缩放组名称。</font><font o="5456">该信息在AWS环境中专门用于在实例启动后自动将实例停止运行，并且已将其禁用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.app-group-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5457">获取要在eureka中注册的应用程序组的名称。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.appname</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">unknown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5458">获取要在eureka注册的应用程序的名称。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.data-center-info</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5459">返回此实例部署的数据中心。</font><font o="5460">如果实例部署在AWS中，则此信息用于获取一些AWS特定实例信息。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.default-address-resolution-order</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.environment</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.health-check-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5461">获取此实例的绝对运行状况检查页面URL。</font><font o="5462">如果运行状况检查页面驻留在与eureka通话的同一个实例中，用户可以提供healthCheckUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。</font><font o="5463">如果提供完整的URL，则优先。
</font></p><p class="tableblock"><font o="5464">&lt;p&gt;它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。</font><font o="5465">完整的URL应遵循格式</font><a href="http://%24%7Beureka.hostname%7D:7001/" class="bare"><font o="5465">http：// $ {eureka.hostname}：7001 /</font></a><font o="5465">其中值$ {eureka.hostname}在运行时被替换。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.health-check-url-path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/health</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5466">获取此实例的相对运行状况检查URL路径。</font><font o="5467">然后，健康检查页面URL由主机名和通信类型构建，如securePort和nonSecurePort中指定的安全或不安全。
</font></p><p class="tableblock"><font o="5468"> 它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.home-page-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5469">获取此实例的绝对主页URL。</font><font o="5470">如果主页位于与eureka通话的同一个实例中，用户可以提供homePageUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。</font><font o="5471">如果提供完整的URL，则优先。
</font></p><p class="tableblock"><font o="5472">它通常用于其他服务的信息目的，以将其用作着陆页。</font><font o="5473">完整的URL应遵循格式</font><a href="http://%24%7Beureka.hostname%7D:7001/" class="bare"><font o="5473">http：// $ {eureka.hostname}：7001 /</font></a><font o="5473"> 
 其中值$ {eureka.hostname}在运行时被替换。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.home-page-url-path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5474">获取此实例的相对主页URL路径。</font><font o="5475">然后，主页URL由hostName和通信类型构建 - 安全或不安全。
</font></p><p class="tableblock"><font o="5476"> 它通常用于其他服务的信息目的，以将其用作着陆页。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.host-info</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.hostname</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5477">如果可以在配置时确定主机名（否则将从操作系统原语中猜出）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.inet-utils</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.initial-status</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5478">使用rmeote Eureka服务器注册的初始状态。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.instance-enabled-onit</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5479">指示在eureka注册后，实例是否应该启用流量。</font><font o="5480">有时候，应用程序可能需要做一些预处理，才能准备好交通。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.instance-id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5481">获取要在eureka注册的此实例的唯一ID（在appName的范围内）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.ip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5482">获取实例的IPAdress。</font><font o="5483">此信息仅用于学术目的，因为来自其他实例的通信主要发生在使用</font><font o="5483">{@link #getHostName（boolean）}中提供的信息。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.lease-expiration-duration-in-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">90</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5484">指示eureka服务器在接收到最后一个心跳之后等待的时间（秒），然后才能从此视图中删除此实例，并禁止此实例的流量。
</font></p><p class="tableblock"><font o="5485">将此值设置得太长可能意味着流量可以路由到实例，即使实例不存在。</font><font o="5486">设置此值太小可能意味着，由于临时网络故障，实例可能会被取消流量。此值将设置为至少高于leaseRenewalIntervalInSeconds中指定的值。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.lease-renewal-interval-in-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5487">指示eureka客户端需要向eureka服务器发送心跳以指示它仍然存在的频率（以秒为单位）。</font><font o="5488">如果在leaseExpirationDurationInSeconds中指定的时间段内未收到心跳线，则eureka服务器将从其视图中删除该实例，因此不允许此实例的流量。
</font></p><p class="tableblock"><font o="5489"> 请注意，如果该实例实现HealthCheckCallback，然后决定使其本身不可用，则该实例仍然可能无法访问流量。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.metadata-map</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5490">获取与此实例关联的元数据名称/值对。</font><font o="5491">该信息发送到eureka服务器，可以被其他实例使用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.namespace</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5492">获取用于查找属性的命名空间。</font><font o="5493">忽略Spring Cloud。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.non-secure-port</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5494">获取实例应该接收流量的非安全端口。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.non-secure-port-enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5495">指示是否应启用非安全端口的流量。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.prefer-ip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5496">标示说，当猜测主机名时，服务器的IP地址应该在操作系统报告的主机名中使用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.registry.default-open-for-traffic-count</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5497">用于确定租赁期间取消的价值，独立时默认为1。</font><font o="5498">应该为对等复制的eurekas设置为0</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.registry.expected-number-of-renews-per-min</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.secure-health-check-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5499">获取此实例的绝对安全运行状况检查页面URL。</font><font o="5500">如果健康检查页面驻留在与eureka通话的同一个实例中，用户可以提供secureHealthCheckUrl，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。</font><font o="5501">如果提供完整的URL，则优先。
</font></p><p class="tableblock"><font o="5502">&lt;p&gt;它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。</font><font o="5503">完整的URL应遵循格式</font><a href="http://%24%7Beureka.hostname%7D:7001/" class="bare"><font o="5503">http：// $ {eureka.hostname}：7001 /</font></a><font o="5503">其中值$ {eureka.hostname}在运行时被替换。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.secure-port</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5504">获取实例应该接收流量的安全端口。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.secure-port-enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5505">指示安全端口是否应启用流量。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.secure-virtual-host-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">unknown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5506">获取为此实例定义的安全虚拟主机名。
</font></p><p class="tableblock"><font o="5507"> 这通常是其他实例通过使用安全虚拟主机名找到此实例的方式。这与完全限定域名相似，您的服务的用户将需要找到此实例。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.status-page-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5508">获取此实例的绝对状态页面URL路径。</font><font o="5509">如果状态页面驻留在与eureka通话的同一个实例中，用户可以提供statusPageUrlPath，否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。</font><font o="5510">如果提供完整的URL，则优先。
</font></p><p class="tableblock"><font o="5511">它通常用于其他服务的信息目的，以查找此实例的状态。</font><font o="5512">用户可以提供一个简单的HTML来指示实例的当前状态。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.status-page-url-path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/info</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5513">获取此实例的相对状态页面URL路径。</font><font o="5514">然后，状态页面URL由安全端口和非安全端口中指定的hostName和通信类型构建 - 安全或不安全。
</font></p><p class="tableblock"><font o="5515">它通常用于其他服务的信息目的，以查找此实例的状态。</font><font o="5516">用户可以提供一个简单的HTML来指示实例的当前状态。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.instance.virtual-host-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">unknown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5517">获取为此实例定义的虚拟主机名。
</font></p><p class="tableblock"><font o="5518"> 这通常是其他实例通过使用虚拟主机名找到此实例的方式。这与完全限定域名相似，您的服务的用户将需要找到此实例。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.a-s-g-cache-expiry-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.a-s-g-query-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">300</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.a-s-g-update-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.a-w-s-access-id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.a-w-s-secret-key</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.batch-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.binding-strategy</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.delta-retention-timer-interval-in-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.disable-delta</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.disable-delta-for-remote-regions</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.disable-transparent-fallback-to-other-region</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.e-i-p-bind-rebind-retries</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.e-i-p-binding-retry-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.e-i-p-binding-retry-interval-ms-when-unbound</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.enable-replicated-request-compression</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.enable-self-preservation</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.eviction-interval-timer-in-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.g-zip-content-from-remote-region</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.json-codec-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.list-auto-scaling-groups-role-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">ListAutoScalingGroups</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.log-identity-headers</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-elements-in-peer-replication-pool</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-elements-in-status-replication-pool</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-idle-thread-age-in-minutes-for-peer-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-idle-thread-in-minutes-age-for-status-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-threads-for-peer-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-threads-for-status-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.max-time-for-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.min-threads-for-peer-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.min-threads-for-status-replication</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.number-of-replication-retries</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-eureka-nodes-update-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-eureka-status-refresh-time-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-node-connect-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-node-connection-idle-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-node-read-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-node-total-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.peer-node-total-connections-per-host</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.prime-aws-replica-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.property-resolver</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-burst-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-full-fetch-average-rate</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-privileged-clients</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-registry-fetch-average-rate</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.rate-limiter-throttle-standard-clients</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.registry-sync-retries</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.registry-sync-retry-wait-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-app-whitelist</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-connect-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-connection-idle-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-fetch-thread-pool-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-read-timeout-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-registry-fetch-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-total-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-total-connections-per-host</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-trust-store</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-trust-store-password</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">changeit</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-urls</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.remote-region-urls-with-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.renewal-percent-threshold</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0.85</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.renewal-threshold-update-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.response-cache-auto-expiration-in-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">180</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.response-cache-update-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.retention-time-in-m-s-in-delta-queue</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.route53-bind-rebind-retries</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.route53-binding-retry-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.route53-domain-t-t-l</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.sync-when-timestamp-differs</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.use-read-only-response-cache</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.wait-time-in-ms-when-sync-empty</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">eureka.server.xml-codec-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">feign.compression.request.mime-types</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[text/xml, application/xml, application/json]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5519">支持的MIME类型列表。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">feign.compression.request.min-request-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2048</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5520">最小阈值内容大小。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">health.config.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5521">标记以指示应安装配置服务器运行状况指示器。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">health.config.time-to-live</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5522">生成缓存结果的时间，以毫秒为单位。</font><font o="5523">默认300000（5分钟）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">hystrix.metrics.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5524">启用Hystrix指标轮询。</font><font o="5525">默认为true。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">hystrix.metrics.polling-interval-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5526">后续轮询度量之间的间隔。</font><font o="5527">默认为2000 ms。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">management.health.refresh.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5528">启用刷新范围的运行状况端点。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">management.health.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5529">启用zookeeper的健康端点。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">netflix.atlas.batch-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">netflix.atlas.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">netflix.atlas.uri</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">netflix.metrics.servo.cache-warning-threshold</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5530">当<code i="2668">ServoMonitorCache</code>达到这个大小时，会记录一个警告。</font><font o="5531">如果您在RestTemplate url中使用字符串连接，这将非常有用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">netflix.metrics.servo.registry-class</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">com.netflix.servo.BasicMonitorRegistry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5532">Servo使用的监视器注册表的完全限定类名。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">proxy.auth.load-balanced</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">proxy.auth.routes</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5533">每个路由的认证策略。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.ack.destination-service</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5534">想要听ack的服务。</font><font o="5535">默认为null（表示所有服务）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.ack.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5536">标志关闭acks（默认打开）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.destination</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">springCloudBus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5537">名称Spring Cloud消息的流目的地。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5538">标志表示总线已启用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.env.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5539">标志关闭环境变化事件（默认为开）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.refresh.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5540">关闭刷新事件的标志（默认为开）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.bus.trace.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5541">打开acks跟踪的标志（默认关闭）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5542">标记以指示启用发现。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.heartbeat-frequency</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5543">心跳次数以毫秒为单位的频率。</font><font o="5544">客户端将轮询该频率并广播服务ID列表。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.org</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5545">要进行身份验证的组织名称（默认为用户默认值）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5546">用户验证和获取令牌的密码。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.space</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5547">要进行身份验证的空间名称（默认为用户默认值）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.url</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock"><a href="https://api.run.pivotal.io/" class="bare">https://api.run.pivotal.io</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5548">Cloud Foundry API（云控制器）的URL。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.cloudfoundry.discovery.username</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5549">验证用户名（通常是电子邮件地址）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.allow-override</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5550">标记以指示可以使用</font><font o="5550">{@link #isSystemPropertiesOverride（）systemPropertiesOverride}。</font><font o="5551">设置为false以防止用户意外更改默认值。</font><font o="5552">默认值为true。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.authorization</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5553">客户端使用的授权令牌连接到服务器。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5554">标记以指示启用配置服务器发现（配置服务器URL将通过发现查找）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.discovery.service-id</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">configserver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5555">服务ID来定位配置服务器。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5556">标记说远程配置启用。</font><font o="5557">默认为true;</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.fail-fast</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5558">标记表示无法连接到服务器是致命的（默认为false）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.label</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5559">用于拉取远程配置属性的标签名称。</font><font o="5560">默认设置在服务器上（通常是基于git的服务器的“主”）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5561">用于获取远程属性的应用程序名称。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.override-none</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5562">标志表示当</font><font o="5562">{@link #setAllowOverride（boolean）allowOverride}为true时，外部属性应该采用最低优先级，并且不覆盖任何现有的属性源（包括本地配置文件）。</font><font o="5563">默认为false。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.override-system-properties</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5564">标记以指示外部属性应覆盖系统属性。</font><font o="5565">默认值为true。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5566">联系远程服务器时使用的密码（HTTP Basic）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.profile</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5567">获取远程配置时使用的默认配置文件（逗号分隔）。</font><font o="5568">默认为“默认”。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.retry.initial-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5569">初始重试间隔（以毫秒为单位）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.retry.max-attempts</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5570">最大尝试次数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.retry.max-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5571">退避的最大间隔</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.retry.multiplier</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5572">下一个间隔的乘数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.bootstrap</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5573">表示配置服务器应使用远程存储库中的属性初始化其自己的环境。</font><font o="5574">默认情况下关闭，因为它会延迟启动，但在将服务器嵌入到另一个应用程序中时很有用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.default-application-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5575">传入请求没有特定的默认应用程序名称。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.default-label</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5576">传入请求没有特定标签时的默认存储库标签。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.default-profile</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5577">传入请求没有特定的默认应用程序配置文件时。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.encrypt.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5578">在发送给客户端之前启用对环境属性的解密。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.basedir</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5579">库的本地工作副本的基本目录。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.clone-on-start</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5580">标记以表明应该在启动时克隆存储库（不是按需）。</font><font o="5581">通常会导致启动速度较慢，但​​第一次查询更快。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.default-label</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.environment</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.force-pull</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5582">标记表示存储库应该强制拉。</font><font o="5583">如果真的丢弃任何本地更改并从远程存储库获取。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.git-factory</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5584">使用远程存储库验证密码。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.repos</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5585">存储库标识符映射到位置和其他属性。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.search-paths</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5586">在本地工作副本中使用的搜索路径。</font><font o="5587">默认情况下只搜索根。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.timeout</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5588">用于获取HTTP或SSH连接的超时（以秒为单位）（如果适用）。</font><font o="5589">默认5秒。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.uri</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5590">远程存储库的URI。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.git.username</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5591">用于远程存储库的身份验证用户名。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.health.repositories</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.native.fail-on-error</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5592">标识以确定在解密期间如何处理异常（默认为false）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.native.search-locations</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5593">搜索配置文件的位置。</font><font o="5594">默认与Spring Boot应用程序相同，因此[classpath：/，classpath：/ config /，file：./，file：./ config /]。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.native.version</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5595">为本地存储库报告的版本字符串</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.overrides</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5596">无条件发送给所有客户的资源的额外地图。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5597">配置资源路径的前缀（默认为空）。</font><font o="5598">当您不想更改上下文路径或servlet路径时嵌入其他应用程序时很有用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.strip-document-from-yaml</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5599">标记为指示作为文本或集合（而不是映射）的YAML文档应以“本机”形式返回。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.basedir</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5600">库的本地工作副本的基本目录。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.default-label</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">trunk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5601">用于环境属性请求的默认标签。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.environment</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.password</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5602">使用远程存储库验证密码。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.search-paths</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5603">在本地工作副本中使用的搜索路径。</font><font o="5604">默认情况下只搜索根。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.uri</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5605">远程存储库的URI。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.server.svn.username</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5606">用于远程存储库的身份验证用户名。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.token</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5607">安全令牌通过到底层环境库。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.uri</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock"><a href="http://localhost:8888/" class="bare">http://localhost:8888</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5608">远程服务器的URI（默认</font><a href="http://localhost:8888/" class="bare"><font o="5608">http：// localhost：8888</font></a><font o="5608">）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.config.username</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5609">联系远程服务器时使用的用户名（HTTP Basic）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.acl-token</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.data-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5610">如果格式为Format.PROPERTIES或Format.YAML，则使用以下字段来查找协调配置。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.default-context</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">application</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.fail-fast</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5611">在配置查找期间抛出异常，如果为true，否则为日志警告。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.format</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">config</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.profile-separator</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">,</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.watch.delay</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5612">手表的固定延迟的价值在毫秒。</font><font o="5613">默认为1000。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.watch.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5614">如果手表启用 </font><font o="5615">默认为true。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.config.watch.wait-time</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">55</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5616">等待（或阻止）观看查询的秒数，默认为55.需要小于默认的ConsulClient（默认为60）。</font><font o="5617">要增加ConsulClient超时，使用自定义的HttpClient创建一个带有自定义ConsulRawClient的ConsulClient bean。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.acl-token</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.catalog-services-watch-delay</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.catalog-services-watch-timeout</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.default-query-tag</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5618">如果没有在serverListQueryTags中列出，请在服务列表中查询标签。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.default-zone-metadata-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zone</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5619">服务实例区域来自元数据。</font><font o="5620">这允许更改元数据标签名称。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5621">是否启用服务发现？</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.fail-fast</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5622">在服务注册期间抛出异常，如果为true，否则，记录警告（默认为true）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.health-check-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5623">执行健康检查的频率（例如10s）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.health-check-path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/health</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5624">调用健康检查的备用服务器路径</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.health-check-timeout</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5625">健康检查超时（例如10s）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.health-check-url</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5626">自定义健康检查网址覆盖默认值</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.heartbeat-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.interval-ratio</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.ttl-unit</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.ttl-value</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.host-info</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.hostname</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5627">访问服务器时使用的主机名</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.instance-id</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5628">唯一的服务实例ID</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.instance-zone</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5629">服务实例区</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.ip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5630">访问服务时使用的IP地址（还必须设置preferIpAddress才能使用）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.lifecycle.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.management-port</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5631">端口注册管理服务（默认为管理端口）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.management-suffix</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5632">注册管理服务时使用后缀</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.management-tags</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5633">注册管理服务时使用的标签</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.port</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5634">端口注册服务（默认为侦听端口）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.prefer-agent-address</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5635">我们将如何确定使用地址的来源</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.prefer-ip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5636">在注册时使用ip地址而不是主机名</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.query-passing</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5637">将“pass”参数添加到/ v1 / health / service / serviceName。</font><font o="5638">这会将健康检查推送到服务器。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.register</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5639">注册为领事服务。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.register-health-check</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5640">注册领事健康检查。</font><font o="5641">在开发服务期间有用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.scheme</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5642">是否注册http或https服务</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.server-list-query-tags</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5643">服务器列表中要查询的serviceId的→标签的映射。</font><font o="5644">这允许通过单个标签过滤服务。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.service-name</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5645">服务名称</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.discovery.tags</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5646">注册服务时使用的标签</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5647">启用了spring cloud consul</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.host</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">localhost</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5648">Consul代理主机名。</font><font o="5649">默认为“localhost”。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.port</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">8500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5650">Consul代理端口。</font><font o="5651">默认为'8500'。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.retry.initial-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5652">初始重试间隔（以毫秒为单位）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.retry.max-attempts</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5653">最大尝试次数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.retry.max-interval</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5654">退避的最大间隔</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.consul.retry.multiplier</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5655">下一个间隔的乘数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.hypermedia.refresh.fixed-delay</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.hypermedia.refresh.initial-delay</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.default-hostname</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">localhost</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5656">默认主机名。</font><font o="5657">用于发生错误的情况。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.default-ip-address</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">127.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5658">默认ipaddress。</font><font o="5659">用于发生错误的情况。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.ignored-interfaces</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5660">将被忽略的网络接口的Java正则表达式列表。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.preferred-networks</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5661">将被忽略的网络地址的Java正则表达式列表。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.timeout-seconds</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5662">计算主机名的超时秒数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.inetutils.use-only-site-local-interfaces</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5663">仅使用与站点本地地址的接口。</font><font o="5664">有关详细信息，请参阅</font><font o="5664">{@link InetAddress＃isSiteLocalAddress（）}。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.loadbalancer.retry.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.binders</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.bindings</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.consul.binder.event-timeout</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.consumer-defaults</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.default-binder</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.dynamic-destinations</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.ignore-unknown-properties</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.instance-count</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.instance-index</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.producer-defaults</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.rabbit.binder.admin-adresses</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.rabbit.binder.compression-level</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.rabbit.binder.nodes</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.stream.rabbit.bindings</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.base-sleep-time-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5665">重试之间等待的初始时间</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.block-until-connected-unit</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5666">与Zookeeper连接时阻止的时间单位</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.block-until-connected-wait</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5667">等待时间阻止连接到Zookeeper</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.connect-string</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">localhost:2181</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5668">连接字符串到Zookeeper集群</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.default-health-endpoint</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5669">将检查以验证依赖关系是否存在的默认运行状况端点</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.dependencies</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5670">将别名映射到ZookeeperDependency。</font><font o="5671">从Ribbon的角度看，别名实际上是serviceID，因为Ribbon不能接受serviceID中的嵌套结构</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.dependency-configurations</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.dependency-names</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-host</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5672">预定义的主机可以在Zookeeper中注册自己的服务。</font><font o="5673">对应于URI规范中的{code address}。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-port</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5674">端口注册服务（默认为侦听端口）</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.metadata</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5675">获取与此实例关联的元数据名称/值对。</font><font o="5676">该信息被发送到动物管理员，可以被其他实例使用。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.register</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5677">在动物园管理员中注册为服务。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.root</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/services</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5678">所有实例都被注册的根Zookeeper文件夹</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.discovery.uri-spec</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">{scheme}://{address}:{port}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5679">在Zookeeper服务注册期间解决的URI规范</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5680">启用了Zookeeper</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.max-retries</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5681">最多重试次数</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.max-sleep-ms</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5682">每次重试最多可以以ms为单位睡眠</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.cloud.zookeeper.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5683">将应用于所有Zookeeper依赖关系的路径的公共前缀</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.integration.poller.fixed-delay</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5684">修复默认轮询器的延迟。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.integration.poller.max-messages-per-poll</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5685">默认轮询器每轮询的最大消息。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.integration.enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5686">启用Spring Integration侦察器。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.integration.patterns</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5687">一组简单的模式，通道名称将与之匹配。</font><font o="5688">默认值为*（所有通道）。</font><font o="5689">请参阅org.springframework.util.PatternMatchUtils.simpleMatch（String，String）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.async.class-name-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5690">具有使用</font><font o="5690">{@code @Async} </font><font o="5690">注释的方法的类的简单名称，</font><font o="5690">从异步进程开始
</font></p><p class="tableblock"><font o="5691"> @see org.springframework.scheduling.annotation.Async</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.async.method-name-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5692">使用</font><font o="5692">{@code @Async}
 </font><font o="5692">注释的方法的名称</font></p><p class="tableblock"><font o="5693"> @see org.springframework.scheduling.annotation.Async</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.async.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5694">如果标题名称被添加为标签，则使用前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.async.thread-name-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">thread</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5695">执行异步方法的线程的名称
</font></p><p class="tableblock"><font o="5696"> @see org.springframework.scheduling.annotation.Async</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.headers</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5697">额外的标题应该作为标签添加，如果它们存在。</font><font o="5698">如果头值是多值的，则标签值将是逗号分隔的单引号列表。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.host</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5699">URL或主机头的域部分。</font><font o="5700">示例：“mybucket.s3.amazonaws.com”。</font><font o="5701">用于过滤主机而不是ip地址。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.method</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5702">HTTP方法或动词，如“GET”或“POST”。</font><font o="5703">用于过滤http路由。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5704">绝对的http路径，没有任何查询参数。</font><font o="5705">示例：“/ objects / abcd-ff”。</font><font o="5706">用于过滤http路由，可以与zipkin v1一起移植。</font><font o="5707">在zipkin v1中，只支持等于过滤器。</font><font o="5708">删除查询参数使不同URI的数量减少。</font><font o="5709">例如，无论查询行中编码的签名参数如何，都可以查询相同的资源。</font><font o="5710">这不会降低HTTP单路由的基数。</font><font o="5711">例如，通常将路由表示为http URI模板，如“/ resource / {resource_id}”。</font><font o="5712">在只有等量查询可用的系统中，</font><font o="5712">如果实际请求是“/ resource / abcd-ff” </font><font o="5712">，则搜索
  </font><font o="5712">{@code http.uri = / resource}将不匹配。</font><font o="5713">历史记录：这通常在拉链中被表示为“http.uri”，但最常见的只是一条路。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5714">如果标题名称被添加为标签，则使用前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.request-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.request.size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5715">非空HTTP请求体的大小（以字节为单位）。</font><font o="5716">防爆。</font>"16384"</p><p class="tableblock"><font o="5718"> &lt;p&gt;大上传可能会超出限制或直接影响延迟。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.response-size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.response.size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5719">非空HTTP响应体的大小（以字节为单位）。</font><font o="5720">防爆。</font>"16384"</p><p class="tableblock"><font o="5722"> &lt;p&gt;大量下载可能会超出限制或直接影响延迟。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.status-code</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.status_code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5723">当HTTP响应代码不在2xx范围内。</font><font o="5724">防爆。</font><font o="5725">“503”用于过滤错误状态。</font><font o="5726">2xx范围不会被记录，因为成功代码对延迟故障排除不那么有趣。</font><font o="5727">省略节省每个跨度至少20个字节。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.http.url</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">http.url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5728">整个URL，包括方案，主机和查询参数（如果可用）。</font><font o="5729">防爆。</font><font o="5730">“https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256...”结合</font><font o="5730">{@link #method }，您可以了解完全限定的请求行。</font><font o="5731">这是可选的，因为它可能包括私人数据或相当长的长度。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.hystrix.command-group</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">commandGroup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5732">命令组的名称 </font><font o="5733">Hystrix使用命令组密钥将诸如报告，警报，仪表板或团队/库所有权的命令分组在一起。
</font></p><p class="tableblock"><font o="5734"> @see com.netflix.hystrix.HystrixCommandGroupKey</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.hystrix.command-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">commandKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5735">命令键的名称 </font><font o="5736">描述给定命令的名称。</font><font o="5737">代表用于监视，断路器，指标发布，缓存和其他此类用途</font><font o="5737">的</font><font o="5737">{@link com.netflix.hystrix.HystrixCommand}的关键。
</font></p><p class="tableblock"><font o="5738"> @see com.netflix.hystrix.HystrixCommandKey</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.hystrix.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5739">如果标题名称被添加为标签，则使用前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.hystrix.thread-pool-key</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">threadPoolKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5740">线程池密钥的名称。</font><font o="5741">线程池密钥表示</font><font o="5741">用于监视，指标发布，缓存和其他此类用途</font><font o="5741">的</font><font o="5741">{@link com.netflix.hystrix.HystrixThreadPool}。</font><font o="5742">甲</font><font o="5742">{@link com.netflix.hystrix.HystrixCommand}与单个相关的</font><font o="5742">{@link com.netflix.hystrix.HystrixThreadPool}如由检索</font><font o="5742">{@link com.netflix.hystrix.HystrixThreadPoolKey}注入它，或者它的默认值使用</font><font o="5742">{@link com.netflix.hystrix.HystrixCommandGroupKey}创建的创建它。
</font></p><p class="tableblock"><font o="5743"> @see com.netflix.hystrix.HystrixThreadPoolKey</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.message.headers</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5744">额外的标题应该作为标签添加，如果它们存在。</font><font o="5745">如果头值不是String，它将使用其toString（）方法转换为String。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.message.payload.size</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">message/payload-size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5746">估计有效载荷的大小（如果有的话）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.message.payload.type</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">message/payload-type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5747">有效载荷的类型。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.message.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">message/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5748">如果标题名称被添加为标签，则使用前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.mvc.controller-class</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">mvc.controller.class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5749">小写，连字符分隔处理请求的类的名称。</font><font o="5750">防爆。</font><font o="5751">名为“BookController”的类将导致“book-controller”标签值。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.keys.mvc.controller-method</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">mvc.controller.method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5752">小写，连字符分隔处理请求的类的名称。</font><font o="5753">防爆。</font><font o="5754">名为“listOfBooks”的方法将导致“list-of-books”标签值。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.metric.span.accepted-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">counter.span.accepted</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.metric.span.dropped-name</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">counter.span.dropped</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.sampler.percentage</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5755">应采样的请求百分比。</font><font o="5756">例如1.0  -  100％的请求应该被抽样。</font><font o="5757">精度仅为全数（即不支持0.1％的痕迹）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">spring.sleuth.trace-id128</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5758">如果为true，则生成128位跟踪ID，而不是64位跟踪ID。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.add-host-header</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5759">标识以确定代理是否转发主机头。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.add-proxy-headers</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5760">标识以确定代理是否添加X-Forwarded- *标头。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.host.max-per-route-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5761">单个路由可以使用的最大连接数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.host.max-total-connections</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5762">代理可以容纳到后端的总连接数。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ignore-local-service</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ignore-security-headers</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5763">标记说，如果spring security在类路径上，则将SECURITY_HEADERS添加到忽略的标头。</font><font o="5764">通过将ignoreSecurityHeaders设置为false，我们可以关闭此默认行为。</font><font o="5765">这应该与禁用默认的spring security标头一起使用，请参见</font><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers" class="bare"><font o="5765">https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers</font></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ignored-headers</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5766">HTTP标头的名称完全忽略（即将其从下游请求中删除，并将其从下游响应中删除）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ignored-patterns</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ignored-services</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5767">一组服务名称不考虑代理自动。</font><font o="5768">默认情况下，发现客户端中的所有服务都将被代理。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5769">所有路由的公共前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.remove-semicolon-content</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5770">标记说，可以删除超过第一个分号的路径元素。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.retryable</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5771">默认情况下是否支持重试的标志（假设路由本身支持）。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ribbon-isolation-strategy</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.routes</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5772">将路线名称映射到属性。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.s-e-c-u-r-i-t-y-h-e-a-d-e-r-s</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5773">一般预期由Spring安全性添加的标头，因此如果代理和后端使用Spring保护，则通常会重复。</font><font o="5774">默认情况下，如果存在Spring安全性，并且ignoreSecurityHeaders = true，它们将被添加到忽略的标头。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.semaphore.max-semaphores</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5775">Hystrix的总信号量的最大数量。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.sensitive-headers</p></td>
<td class="tableblock halign-left valign-top notranslate"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5776">不传递到下游请求的敏感标头列表。</font><font o="5777">默认为通常包含用户凭据的“安全”标题集。</font><font o="5778">如果下游服务是与代理相同的系统的一部分，那么从列表中删除它们是正确的，所以他们正在共享认证数据。</font><font o="5779">如果在您自己的域之外使用物理URL，那么一般来说泄漏用户凭据将是一个坏主意。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.servlet-path</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">/zuul</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5780">安装Zuul作为servlet的路径（不是Spring MVC的一部分）。</font><font o="5781">对于具有大型机构的请求，例如文件上传，servlet对于更高的内存效率更高。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.ssl-hostname-validation-enabled</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5782">标记以说明是否应验证ssl连接的主机名。</font><font o="5783">默认值为true。</font><font o="5784">这只应用于测试设置！</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.strip-prefix</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5785">在转发之前标记是否从路径中删除前缀。</font></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">zuul.trace-request-body</p></td>
<td class="tableblock halign-left valign-top notranslate"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><font o="5786">标记说可以跟踪请求机构。</font></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<script type="text/javascript" charset="UTF-8" name="springcloud">springcloud.cc({"original":{"2":"Table of Contents","3":"Features","4":"Cloud Native Applications","5":"{22/} Context: Application Context Services","6":"The Bootstrap Application Context","7":"Application Context Hierarchies","8":"Changing the Location of Bootstrap {31/}","9":"Overriding the Values of Remote {31/}","10":"Customizing the Bootstrap Configuration","11":"Customizing the Bootstrap Property Sources","12":"Environment Changes","13":"Refresh Scope","14":"Encryption and Decryption","15":"Endpoints","16":"{4/}: Common Abstractions","17":"@EnableDiscoveryClient","18":"ServiceRegistry","19":"{12/} as a Load Balancer Client","20":"Multiple RestTemplate objects","21":"Ignore Network Interfaces","23":"Quick Start","24":"Client Side Usage","25":"{16/} Server","26":"Environment Repository","27":"Health Indicator","28":"Security","29":"Encryption and Decryption","30":"Key Management","31":"Creating a Key Store for Testing","32":"Using Multiple Keys and Key Rotation","33":"Serving Encrypted {31/}","34":"Serving Alternative Formats","35":"Serving Plain Text","36":"Embedding the Config Server","37":"Push Notifications and {9/}","38":"{16/} Client","39":"Config First Bootstrap","40":"Discovery First Bootstrap","41":"Config Client Fail Fast","42":"Config Client Retry","43":"Locating Remote Configuration Resources","44":"Security","47":"Service Discovery: {62/} Clients","48":"How to Include {62/} Client","49":"Registering with {62/}","50":"Authenticating with the {62/} Server","51":"Status Page and Health Indicator","52":"Registering a Secure Application","53":"{62/}’s Health Checks","54":"{62/} Metadata for Instances and Clients","55":"Using the EurekaClient","56":"Alternatives to the native Netflix EurekaClient","57":"Why is it so Slow to Register a Service?","58":"Zones","59":"Service Discovery: {62/} Server","60":"How to Include {62/} Server","61":"How to Run a {62/} Server","62":"High Availability, Zones and Regions","63":"Standalone Mode","64":"Peer Awareness","65":"Prefer IP Address","66":"Circuit Breaker: {47/} Clients","67":"How to Include {47/}","68":"Propagating the Security Context or using {41/} Scopes","69":"Health Indicator","70":"{47/} Metrics Stream","71":"Circuit Breaker: {47/} Dashboard","72":"{47/} Timeouts And {43/} Clients","73":"How to Include {47/} Dashboard","76":"Client Side Load Balancer: {43/}","77":"How to Include {43/}","78":"Customizing the {43/} Client","79":"Customizing the {43/} Client using properties","80":"Using {43/} with {62/}","81":"Example: How to Use {43/} Without {62/}","82":"Example: Disable {62/} use in {43/}","83":"Using the {43/} API Directly","84":"Caching of {43/} Configuration","85":"Declarative REST Client: {55/}","86":"How to Include {55/}","87":"Overriding {55/} Defaults","88":"Creating {55/} Clients Manually","89":"{10/} Support","90":"{10/} Fallbacks","91":"{55/} and {63/}","92":"{55/} Inheritance Support","93":"{55/} request/response compression","94":"{55/} logging","95":"External Configuration: {38/}","96":"Router and Filter: {60/}","97":"How to Include {60/}","98":"Embedded {60/} Reverse Proxy","99":"{60/} Http Client","100":"Cookies and Sensitive Headers","101":"Ignored Headers","102":"The Routes Endpoint","103":"Strangulation Patterns and Local Forwards","104":"Uploading Files through {60/}","105":"Query String Encoding","106":"Plain Embedded {60/}","107":"Disable {60/} Filters","108":"Providing {47/} Fallbacks For Routes","109":"{60/} Developer Guide","110":"{44/} support with {51/}","111":"RxJava with {41/} MVC","112":"Metrics: {42/}, {57/}, and {56/}","113":"Dimensional vs. Hierarchical Metrics","114":"Default Metrics Collection","115":"Metrics Collection: {42/}","116":"Metrics Collection: {57/}","117":"Metrics Backend: {56/}","118":"Retrying Failed Requests","119":"{22/} Stream","120":"Introducing {22/} Stream","121":"Main Concepts","122":"Application Model","123":"The {48/} Abstraction","124":"Persistent Publish-Subscribe Support","125":"Consumer Groups","126":"Partitioning Support","127":"Programming Model","128":"Declaring and Binding Channels","130":"Producers and Consumers","132":"{48/} Detection","133":"Multiple {35/} on the Classpath","134":"Connecting to Multiple Systems","135":"{48/} configuration properties","136":"Configuration Options","137":"{22/} Stream {31/}","138":"Binding {31/}","139":"Using dynamically bound destinations","140":"Content Type and Transformation","141":"MIME types","142":"MIME types and Java types","143":"Customizing message conversion","144":"{64/} and Message Conversion","145":"{40/} evolution support","146":"{11/} Message Converters","147":"Converters with schema support","148":"{40/} Registry Support","149":"{40/} Registry Server","150":"{40/} Registry Client","151":"{8/} Registry Client Message Converters","152":"{40/} Registration and Resolution","153":"Inter-Application Communication","154":"Connecting Multiple Application Instances","155":"Instance Index and Instance Count","156":"Partitioning","157":"Testing","158":"Health Indicator","159":"Metrics Emitter","160":"Samples","161":"Getting Started","162":"{48/} Implementations","163":"Apache {6/}","164":"Usage","165":"Apache {6/} Overview","166":"Configuration Options","167":"{7/} Topic Processing","169":"Usage","170":"{18/} Overview","171":"Configuration Options","172":"Retry With the {18/}","173":"{7/} Queue Processing","175":"Quick Start","176":"Addressing an Instance","177":"Addressing all instances of a service","178":"Application Context ID must be unique","179":"Customizing the Message Broker","180":"Tracing {33/}","181":"Broadcasting Your Own {39/}","182":"Registering events in custom packages","183":"{22/} Sleuth","184":"Terminology","185":"Purpose","186":"Adding to the project","187":"Additional resources","188":"Features","189":"Sampling","190":"Instrumentation","191":"{59/} lifecycle","192":"Creating and closing {61/}","193":"Continuing {61/}","194":"Creating {61/} with an explicit parent","195":"Naming {61/}","196":"@SpanName annotation","197":"toString() method","198":"Managing {61/} with annotations","199":"Rationale","200":"Creating new {61/}","201":"Continuing {61/}","202":"More advanced tag setting","203":"Customizations","205":"HTTP","206":"Example","207":"Custom SA tag in {46/}","208":"Custom service name","209":"Host locator","210":"{52/} as Messages","211":"{46/} Consumer","212":"Custom Consumer","213":"Metrics","214":"Integrations","215":"Runnable and Callable","217":"RxJava","218":"HTTP integration","219":"HTTP client integration","221":"Asynchronous communication","222":"Messaging","224":"Running examples","226":"Install {49/}","228":"Service Discovery with {49/}","229":"How to activate","230":"Registering with {49/}","231":"HTTP Health Check","232":"Using the DiscoveryClient","233":"Distributed Configuration with {49/}","234":"How to activate","235":"Customizing","236":"Config Watch","237":"YAML or {31/} with Config","238":"git2consul with Config","239":"Fail Fast","240":"{49/} Retry","241":"{9/} with {49/}","242":"How to activate","243":"Circuit Breaker with {47/}","244":"{47/} metrics aggregation with {50/} and {49/}","246":"Install {37/}","247":"Service Discovery with {37/}","248":"How to activate","249":"Registering with {37/}","250":"Using the DiscoveryClient","251":"Using {1/} with {5/} Components","252":"{43/} with {37/}","253":"{1/} and Service Registry","254":"Instance Status","255":"{37/} Dependencies","256":"Using the {37/} Dependencies","257":"How to activate {37/} Dependencies","258":"Setting up {37/} Dependencies","259":"Configuring {1/} Dependencies","260":"{1/} Dependency Watcher","261":"How to activate","262":"Registering a listener","263":"Presence Checker","264":"Distributed Configuration with {37/}","265":"How to activate","266":"Customizing","268":"Quickstart","269":"OAuth2 Single Sign On","270":"OAuth2 Protected Resource","271":"More Detail","272":"Single Sign On","273":"Token Relay","274":"Configuring Authentication Downstream of a {60/} Proxy","275":"{22/} for Cloud Foundry","276":"Discovery","277":"Single Sign On","280":"{2/} WireMock","281":"Registering Stubs Automatically","282":"Using Files to Specify the Stub Bodies","283":"Alternative: Using JUnit Rules","284":"WireMock and {41/} MVC Mocks","285":"Generating Stubs using RestDocs","286":"Generating {36/} using RestDocs","287":"{2/} Verifier","288":"Introduction","289":"FAQ","290":"{2/} Verifier HTTP","291":"{2/} Verifier Messaging","293":"{13/} Core","294":"{13/} JUnit Rule","296":"{13/} Boot Application","297":"{13/} for Messaging","298":"{13/} Camel","299":"{13/} Integration","300":"{13/} Stream","301":"{13/} {41/} AMQP","303":"Customization","304":"Pluggable architecture","305":"Links","306":"Appendix: Compendium of Configuration {31/}","307":"{22/} provides tools for developers to quickly build some of the common patterns in distributed systems (eg configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus).","308":"Coordination of distributed systems leads to boiler plate patterns, and using {41/} Cloud developers can quickly stand up services and applications that implement those patterns.","309":"They will work well in any distributed environment, including the developer's own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.","310":"Version: Dalston.RELEASE","311":"Features","312":"{22/} focuses on providing good out of box experience for typical use cases\nand extensibility mechanism to cover others.","313":"Distributed/versioned configuration","314":"Service registration and discovery","315":"Routing","316":"Service-to-service calls","317":"Load balancing","318":"Circuit Breakers","319":"Distributed messaging","320":"Cloud Native Applications","321":"Cloud Native is a style of application development that encourages easy adoption of best practices in the areas of continuous delivery and value-driven development.","322":"A related discipline is that of building 12-factor Apps in which development practices are aligned with delivery and operations goals, for instance by using declarative programming and management and monitoring.","323":"{22/} facilitates these styles of development in a number of specific ways and the starting point is a set of features that all components in a distributed system either need or need easy access to when required.","324":"Many of those features are covered by {19/} , which we build on in {22/}.","325":"Some more are delivered by {22/} as two libraries: {22/} Context and {4/}.","326":"{22/} Context provides utilities and special services for the {65/} of a {22/} application (bootstrap context, encryption, refresh scope and environment endpoints).","327":"{4/} is a set of abstractions and common classes used in different {22/} implementations (eg. {5/} vs. {22/} {49/}).","328":"If you are getting an exception due to \"Illegal key size\" and you are using Sun's JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.","329":"See the following links for more information:","330":"Java 6 JCE","331":"Java 7 JCE","332":"Java 8 JCE","333":"Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).","334":"Note","335":"{22/} is released under the non-restrictive Apache 2.0 license.","336":"If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at github .","337":"{22/} Context: Application Context Services","338":"{19/} has an opinionated view of how to build an application with {41/}: for instance it has conventional locations for common configuration file, and endpoints for common management and monitoring tasks.","339":"{22/} builds on top of that and adds a few features that probably all components in a system would use or occasionally need.","340":"The Bootstrap Application Context","341":"A {22/} application operates by creating a \"bootstrap\" context, which is a parent context for the main application.","342":"Out of the box it is responsible for loading configuration properties from the external sources, and also decrypting properties in the local external configuration files.","343":"The two contexts share an {66/} which is the source of external properties for any {41/} application.","344":"Bootstrap properties are added with high precedence, so they cannot be overridden by local configuration, by default.","345":"The bootstrap context uses a different convention for locating external configuration than the main application context, so instead of {67/} (or {68/}) you use {69/}, keeping the external configuration for bootstrap and main context nicely separate.","346":"Example:","347":"bootstrap.yml","348":"It is a good idea to set the {70/} (in\n{71/} or {72/}) if your application needs any\napplication-specific configuration from the server.","349":"You can disable the bootstrap process completely by setting\n{73/} (e.g. in System properties).","350":"Application Context Hierarchies","351":"If you build an application context from {74/} or {75/}, then the Bootstrap context is added as a parent to that context.","352":"It is a feature of {41/} that child contexts inherit property sources and profiles from their parent, so the \"main\" application context will contain additional property sources, compared to building the same context without {16/}.","353":"The additional property sources are:","354":"\"bootstrap\": an optional {76/} appears with high priority if any {77/} are found in the Bootstrap context, and they have non-empty properties.","355":"An example would be properties from the {16/} Server.","356":"See below for instructions on how to customize the contents of this property source.","357":"\"applicationConfig: [classpath:bootstrap.yml]\" (and friends if {41/} profiles are active).","358":"If you have a {78/} (or properties) then those properties are used to configure the Bootstrap context, and then they get added to the child context when its parent is set.","359":"They have lower precedence than the {79/} (or properties) and any other property sources that are added to the child as a normal part of the process of creating a {19/} application.","360":"See below for instructions on how to customize the contents of these property sources.","361":"Because of the ordering rules of property sources the \"bootstrap\"\nentries take precedence, but note that these do not contain any data\nfrom {80/}, which has very low precedence, but can be used\nto set defaults.","362":"You can extend the context hierarchy by simply setting the parent context of any {81/} you create, eg using its own interface, or with the {82/} convenience methods ({83/}, {84/} and {85/}).","363":"The bootstrap context will be the parent of the most senior ancestor that you create yourself.","364":"Every context in the hierarchy will have its own \"bootstrap\" property source (possibly empty) to avoid promoting values inadvertently from parents down to their descendants.","365":"Every context in the hierarchy can also (in principle) have a different {86/} and hence a different remote property source if there is a Config Server.","366":"Normal {41/} application context behaviour rules apply to property resolution: properties from a child context override those in the parent, by name and also by property source name (if the child has a property source with the same name as the parent, the one from the parent is not included in the child).","367":"Note that the {87/} allows you to share an {88/} amongst the whole hierarchy, but that is not the default.","368":"Thus, sibling contexts in particular do not need to have the same profiles or property sources, even though they will share common things with their parent.","369":"Changing the Location of Bootstrap {31/}","370":"The {89/} (or {90/}) location can be specified using {91/} (default \"bootstrap\") or {92/} (default empty), eg in System properties.","371":"Those properties behave like the {93/} variants with the same name, in fact they are used to set up the bootstrap {94/} by setting those properties in its {95/}.","372":"If there is an active profile (from {96/} or through the {97/} API in the context you are building) then properties in that profile will be loaded as well, just like in a regular {19/} app, eg from {98/} for a \"development\" profile.","373":"Overriding the Values of Remote {31/}","374":"The property sources that are added to you application by the bootstrap context are often \"remote\" (eg from a Config Server), and by default they cannot be overridden locally, except on the command line.","375":"If you want to allow your applications to override the remote properties with their own System properties or config files, the remote property source has to grant it permission by setting {99/} (it doesn't work to set this locally).","376":"Once that flag is set there are some finer grained settings to control the location of the remote properties in relation to System properties and the application's local configuration: {100/} to override with any local property source, and {101/} if only System properties and env vars should override the remote settings, but not the local config files.","377":"Customizing the Bootstrap Configuration","378":"The bootstrap context can be trained to do anything you like by adding entries to {102/} under the key {103/}.","379":"This is a comma-separated list of {41/} {104/} classes which will be used to create the context.","380":"Any beans that you want to be available to the main application context for autowiring can be created here, and also there is a special contract for {105/} of type {106/}.","381":"Classes can be marked with an {107/} if you want to control the startup sequence (the default order is \"last\").","382":"Warning","383":"Be careful when adding custom {108/} that the classes you add are not {109/} by mistake into your \"main\" application context, where they might not be needed.","384":"Use a separate package name for boot configuration classes that is not already covered by your {110/} or {111/} annotated configuration classes.","385":"The bootstrap process ends by injecting initializers into the main {112/} instance (ie the normal {19/} startup sequence, whether it is running as a standalone app or deployed in an application server).","386":"First a bootstrap context is created from the classes found in {113/} and then all {114/} of type {115/} are added to the main {116/} before it is started.","387":"Customizing the Bootstrap Property Sources","388":"The default property source for external configuration added by the bootstrap process is the Config Server, but you can add additional sources by adding beans of type {117/} to the bootstrap context (via {118/}).","389":"You could use this to insert additional properties from a different server, or from a database, for instance.","390":"As an example, consider the following trivial custom locator:","391":"The {119/} that is passed in is the one for the {120/} about to be created, ie the one that we are supplying additional property sources for.","392":"It will already have its normal {19/}-provided property sources, so you can use those to locate a property source specific to this {121/} (eg by keying it on the {122/}, as is done in the default Config Server property source locator).","393":"If you create a jar with this class in it and then add a\n{123/} containing:","394":"then the \"customProperty\" {124/} will show up in any\napplication that includes that jar on its classpath.","395":"Environment Changes","396":"The application will listen for an {125/} and react to the change in a couple of standard ways (additional {126/} can be added as {127/} by the user in the normal way).","397":"When an {128/} is observed it will have a list of key values that have changed, and the application will use those to:","398":"Re-bind any {129/} beans in the context","399":"Set the logger levels for any properties in {130/}","400":"Note that the Config Client does not by default poll for changes in the {131/}, and generally we would not recommend that approach for detecting changes (although you could set it up with a {132/} annotation).","401":"If you have a scaled-out client application then it is better to broadcast the {133/} to all the instances instead of having them polling for changes (eg using the {22/} Bus ).","402":"The {134/} covers a large class of refresh use cases, as long as you can actually make a change to the {135/} and publish the event (those APIs are public and part of core {41/}).","403":"You can verify the changes are bound to {136/} beans by visiting the {137/} endpoint (normal {19/} Actuator feature).","404":"For instance a {138/} can have its {139/} changed at runtime (the default {140/} created by {19/} is an {141/} bean) and grow capacity dynamically.","405":"Re-binding {142/} does not cover another large class of use cases, where you need more control over the refresh, and where you need a change to be atomic over the whole {143/}.","406":"To address those concerns we have {144/}.","407":"Refresh Scope","408":"A {41/} {145/} that is marked as {146/} will get special treatment when there is a configuration change.","409":"This addresses the problem of stateful beans that only get their configuration injected when they are initialized.","410":"For instance if a {147/} has open connections when the database URL is changed via the {148/}, we probably want the holders of those connections to be able to complete what they are doing.","411":"Then the next time someone borrows a connection from the pool he gets one with the new URL.","412":"Refresh scope beans are lazy proxies that initialize when they are used (ie when a method is called), and the scope acts as a cache of initialized values.","413":"To force a bean to re-initialize on the next method call you just need to invalidate its cache entry.","414":"The {149/} is a bean in the context and it has a public method {150/} to refresh all beans in the scope by clearing the target cache.","415":"There is also a {151/} method to refresh an individual bean by name.","416":"This functionality is exposed in the {152/} endpoint (over HTTP or JMX).","417":"Note","418":"{153/} works (technically) on an {154/} class, but it might lead to surprising behaviour: eg it does not mean that all the {155/} defined in that class are themselves {156/}.","419":"Specifically, anything that depends on those beans cannot rely on them being updated when a refresh is initiated, unless it is itself in {157/} (in which it will be rebuilt on a refresh and its dependencies re-injected, at which point they will be re-initialized from the refreshed {158/}).","420":"Encryption and Decryption","421":"{22/} has an {159/} pre-processor for decrypting property values locally.","422":"It follows the same rules as the Config Server, and has the same external configuration via {160/}.","423":"Thus you can use encrypted values in the form {161/} and as long as there is a valid key then they will be decrypted before the main application context gets the {162/}.","424":"To use the encryption features in an application you need to include {41/} Security RSA in your classpath (Maven co-ordinates \"org.springframework.security:spring-security-rsa\") and you also need the full strength JCE extensions in your JVM.","425":"If you are getting an exception due to \"Illegal key size\" and you are using Sun's JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.","426":"See the following links for more information:","427":"Java 6 JCE","428":"Java 7 JCE","429":"Java 8 JCE","430":"Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).","431":"Endpoints","432":"For a {19/} Actuator application there are some additional management endpoints:","433":"POST to {163/} to update the {164/} and rebind {165/} and log levels","434":"{166/} for re-loading the boot strap context and refreshing the {167/} beans","435":"{168/} for closing the {169/} and restarting it (disabled by default)","436":"{170/} and {171/} for calling the {172/} methods ({173/} and {174/} on the {175/})","437":"{4/}: Common Abstractions","438":"Patterns such as service discovery, load balancing and circuit breakers lend themselves to a common abstraction layer that can be consumed by all {22/} clients, independent of the implementation (e.g. discovery via {62/} or {49/}).","439":"@EnableDiscoveryClient","440":"Commons provides the {176/} annotation.","441":"This looks for implementations of the {177/} interface via {178/}.","442":"Implementations of Discovery Client will add a configuration class to {179/} under the {180/} key.","443":"Examples of {181/} implementations: are {5/} {62/} , {22/} {49/} Discovery and {1/} Discovery .","444":"By default, implementations of {182/} will auto-register the local {19/} server with the remote discovery server.","445":"This can be disabled by setting {183/} in {184/}.","446":"ServiceRegistry","447":"Commons now provides a {185/} interface which provides methods like {186/} and {187/} which allow you to provide custom registered services.","448":"{188/} is a marker interface.","449":"Each {189/} implementation has its own {190/} implementation.","450":"ServiceRegistry Auto-Registration","451":"By default, the {191/} implementation will auto-register the running service.","452":"To disable that behavior, there are two methods.","453":"You can set {192/} to permanently disable auto-registration.","454":"You can also set {193/} to disable the behavior via configuration.","455":"Service Registry Actuator Endpoint","456":"A {194/} actuator endpoint is provided by Commons.","457":"This endpoint relys on a {195/} bean in the {41/} Application Context.","458":"Calling {196/} via a GET will return the status of the {197/}.","459":"A POST to the same endpoint with a {198/} body will change the status of the current {199/} to the new value.","460":"Please see the documentation of the {200/} implementation you are using for the allowed values for updating the status and the values retured for the status.","461":"{12/} as a Load Balancer Client","462":"{201/} can be automatically configured to use ribbon.","463":"To create a load balanced {202/} create a {203/} {204/} and use the {205/} qualifier.","464":"Warning","465":"A {206/} bean is no longer created via auto configuration.","466":"It must be created by individual applications.","467":"The URI needs to use a virtual host name (ie. service name, not a host name).","468":"The {43/} client is used to create a full physical address.","469":"See RibbonAutoConfiguration for details of how the {207/} is set up.","470":"Retrying Failed Requests","471":"A load balanced {208/} can be configured to retry failed requests.","472":"By default this logic is disabled, you can enable it by adding {41/} Retry to your application's classpath.","473":"The load balanced {209/} will honor some of the {43/} configuration values related to retrying failed requests.","474":"If you would like to disable the retry logic with {41/} Retry on the classpath you can set {210/}.","475":"The properties you can use are {211/}, {212/}, and {213/}.","476":"See the {43/} documentation for a description of what there properties do.","477":"Note","478":"\n{214/} in the above examples should be replaced with your {43/} client’s\nname.\n","479":"Multiple RestTemplate objects","480":"If you want a {215/} that is not load balanced, create a {216/} bean and inject it as normal.","481":"To access the load balanced {217/} use the {218/} qualifier when you create your {219/}.","482":"Important","483":"\nNotice the {220/} annotation on the plain {221/} declaration in the example below, to disambiguate the unqualified {222/} injection.\n","484":"Tip","485":"\nIf you see errors like {223/} try injecting {224/} instead or setting {225/}.\n","486":"Ignore Network Interfaces","487":"Sometimes it is useful to ignore certain named network interfaces so they can be excluded from Service Discovery registration (eg. running in a Docker container).","488":"A list of regular expressions can be set that will cause the desired network interfaces to be ignored.","489":"The following configuration will ignore the \"docker0\" interface and all interfaces that start with \"veth\".","490":"application.yml","491":"You can also force to use only specified network addresses using list of regular expressions:","492":"application.yml","493":"You can also force to use only site local addresses.","494":"See Inet4Address.html.isSiteLocalAddress() for more details what is site local address.","495":"application.yml","497":"Dalston.RELEASE","498":"{16/} provides server and client-side support for externalized configuration in a distributed system.","499":"With the Config Server you have a central place to manage external properties for applications across all environments.","500":"The concepts on both client and server map identically to the {41/} {226/} and {227/} abstractions, so they fit very well with {41/} applications, but can be used with any application running in any language.","501":"As an application moves through the deployment pipeline from dev to test and into production you can manage the configuration between those environments and be certain that applications have everything they need to run when they migrate.","502":"The default implementation of the server storage backend uses git so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content.","503":"It is easy to add alternative implementations and plug them in with {41/} configuration.","504":"Quick Start","505":"Start the server:","506":"The server is a {19/} application so you can run it from your IDE instead if you prefer (the main class is {228/}).","507":"Then try out a client:","508":"The default strategy for locating property sources is to clone a git repository (at {229/}) and use it to initialize a mini {230/}.","509":"The mini-application's {231/} is used to enumerate property sources and publish them via a JSON endpoint.","510":"The HTTP service has resources in the form:","511":"where the \"application\" is injected as the {232/} in the\n{233/} (i.e. what is normally \"application\" in a regular\n{19/} app), \"profile\" is an active profile (or comma-separated\nlist of properties), and \"label\" is an optional git label (defaults to\n\"master\".)","512":"{16/} Server pulls configuration for remote clients\nfrom a git repository (which must be provided):","513":"Client Side Usage","514":"To use these features in an application, just build it as a {41/} Boot application that depends on spring-cloud-config-client (eg see the test cases for the config-client, or the sample app).","515":"The most convenient way to add the dependency is via a {19/} starter {234/}.","516":"There is also a parent pom and BOM ({235/}) for Maven users and a {41/} IO version management properties file for Gradle and {41/} CLI users.","517":"Example Maven configuration:","518":"pom.xml","519":"Then you can create a standard {19/} application, like this simple HTTP server:","520":"When it runs it will pick up the external configuration from the default local config server on port 8888 if it is running.","521":"To modify the startup behaviour you can change the location of the config server using {236/} (like {237/} but for the bootstrap phase of an application context), eg","522":"The bootstrap properties will show up in the {238/} endpoint as a\nhigh-priority property source, e.g.","523":"(a property source called \"configService:<URL of remote\nrepository>/<file name>\" contains the property \"foo\" with value\n\"bar\" and is highest priority).","524":"Note","525":"\nthe URL in the property source name is the git repository not\nthe config server URL.\n","526":"{16/} Server","527":"The Server provides an HTTP, resource-based API for external configuration (name-value pairs, or equivalent YAML content).","528":"The server is easily embeddable in a {19/} application using the {239/} annotation.","529":"So this app is a config server:","530":"ConfigServer.java","531":"Like all {19/} apps it runs on port 8080 by default, but you can switch it to the conventional port 8888 in various ways.","532":"The easiest, which also sets a default configuration repository, is by launching it with {240/} (there is a {241/} in the Config Server jar).","533":"Another is to use your own {242/}, eg","534":"application.properties","535":"where {243/} is a git repository containing\nYAML and properties files.","536":"Note","537":"\nin Windows you need an extra \"/\" in the file URL if it is\nabsolute with a drive prefix, e.g. {244/}.\n","538":"Tip","539":"Here’s a recipe for creating the git repository in the example\nabove:","540":"Warning","541":"using the local filesystem for your git repository is intended for testing only.","542":"Use a server to host your configuration repositories in production.","543":"Warning","544":"the initial clone of your configuration repository will be quick and efficient if you only keep text files in it.","545":"If you start to store binary files, especially large ones, you may experience delays on the first request for configuration and/or out of memory errors in the server.","546":"Environment Repository","547":"Where do you want to store the configuration data for the Config Server?","548":"The strategy that governs this behaviour is the {245/}, serving {246/} objects.","549":"This {247/} is a shallow copy of the domain from the {41/} {248/} (including {249/} as the main feature).","550":"The {250/} resources are parametrized by three variables:","551":"{251/} maps to \"spring.application.name\" on the client side;","552":"{252/} maps to \"spring.profiles.active\" on the client (comma separated list);","553":"and","554":"{253/} which is a server side feature labelling a \"versioned\" set of config files.","555":"Repository implementations generally behave just like a {19/} application loading configuration files from a \"spring.config.name\" equal to the {254/} parameter, and \"spring.profiles.active\" equal to the {255/} parameter.","556":"Precedence rules for profiles are also the same as in a regular Boot application: active profiles take precedence over defaults, and if there are multiple profiles the last one wins (like adding entries to a {256/}).","557":"Example: a client application has this bootstrap configuration:","558":"bootstrap.yml","559":"(as usual with a {19/} application, these properties could also\nbe set as environment variables or command line arguments).","560":"If the repository is file-based, the server will create an {257/} from {258/} (shared between all clients), and {259/} (with {260/} taking precedence).","561":"If the YAML files have documents inside them that point to {41/} profiles, those are applied with higher precedence (in order of the profiles listed), and if there are profile-specific YAML (or properties) files these are also applied with higher precedence than the defaults.","562":"Higher precedence translates to a {261/} listed earlier in the {262/}.","563":"(These are the same rules as apply in a standalone {19/} application.)","564":"Git Backend","565":"The default implementation of {263/} uses a Git backend, which is very convenient for managing upgrades and physical environments, and also for auditing changes.","566":"To change the location of the repository you can set the \"spring.cloud.config.server.git.uri\" configuration property in the Config Server (eg in {264/}).","567":"If you set it with a {265/} prefix it should work from a local repository so you can get started quickly and easily without a server, but in that case the server operates directly on the local repository without cloning it (it doesn't matter if it's not bare because the Config Server never makes changes to the \"remote\" repository).","568":"To scale the Config Server up and make it highly available, you would need to have all instances of the server pointing to the same repository, so only a shared file system would work.","569":"Even in that case it is better to use the {266/} protocol for a shared filesystem repository, so that the server can clone it and use a local working copy as a cache.","570":"This repository implementation maps the {267/} parameter of the HTTP resource to a git label (commit id, branch name or tag).","571":"If the git branch or tag name contains a slash (\"/\") then the label in the HTTP URL should be specified with the special string \"(_)\" instead (to avoid ambiguity with other URL paths).","572":"For example, if the label is {268/}, replacing the slash would result in a label that looks like {269/}.","573":"Be careful with the brackets in the URL if you are using a command line client like curl (eg escape them from the shell with quotes '').","574":"Placeholders in Git URI","575":"{16/} Server supports a git repository URL with placeholders for the {270/} and {271/} (and {272/} if you need it, but remember that the label is applied as a git label anyway).","576":"So you can easily support a \"one repo per application\" policy using (for example):","577":"or a \"one repo per profile\" policy using a similar pattern but with\n{273/}.","578":"Pattern Matching and Multiple Repositories","579":"There is also support for more complex requirements with pattern matching on the application and profile name.","580":"The pattern format is a comma-separated list of {274/} names with wildcards (where a pattern beginning with a wildcard may need to be quoted).","581":"Example:","582":"If {275/} does not match any of the patterns, it will use the default uri defined under \"spring.cloud.config.server.git.uri\".","583":"In the above example, for the \"simple\" repository, the pattern is {276/} (ie it only matches one application named \"simple\" in all profiles).","584":"The \"local\" repository matches all application names beginning with \"local\" in all profiles (the {277/} suffix is added automatically to any pattern that doesn't have a profile matcher).","585":"Note","586":"the \"one-liner\" short cut used in the \"simple\" example above can only be used if the only property to be set is the URI.","587":"If you need to set anything else (credentials, pattern, etc.) you need to use the full form.","588":"The {278/} property in the repo is actually an array, so you can use a YAML array (or {279/}, {280/}, etc. suffixes in properties files) to bind to multiple patterns.","589":"You may need to do this if you are going to run apps with multiple profiles.","590":"Example:","591":"Note","592":"{22/} will guess that a pattern containing a profile that doesn't end in {281/} implies that you actually want to match a list of profiles starting with this pattern (so {282/} is a shortcut for {283/}).","593":"This is common where you need to run apps in the \"development\" profile locally but also the \"cloud\" profile remotely, for instance.","594":"Every repository can also optionally store config files in sub-directories, and patterns to search for those directories can be specified as {284/}.","595":"For example at the top level:","596":"In this example the server searches for config files in the top level\nand in the \"foo/\" sub-directory and also any sub-directory whose name\nbegins with \"bar\".","597":"By default the server clones remote repositories when configuration is first requested.","598":"The server can be configured to clone the repositories at startup.","599":"For example at the top level:","600":"In this example the server clones team-a's config-repo on startup before it accepts any requests.","601":"All other repositories will not be cloned until configuration from the repository is requested.","602":"Note","603":"Setting a repository to be cloned when the Config Server starts up can help to identify a misconfigured configuration source (eg, an invalid repository URI) quickly, while the Config Server is starting up.","604":"With {285/} not enabled for a configuration source, the Config Server may start successfully with a misconfigured or invalid configuration source and not detect an error until an application requests configuration from that configuration source.","605":"Authentication","606":"To use HTTP basic authentication on the remote repository add the\n\"username\" and \"password\" properties separately (not in the URL),\ne.g.","607":"If you don't use HTTPS and user credentials, SSH should also work out of the box when you store keys in the default directories ({286/}) and the uri points to an SSH location, eg \" git@github.com :configuration/cloud-configuration\".","608":"It is important that an entry for the Git server be present in the {287/} file and that it is in {288/} format.","609":"Other formats (like {289/}) are not supported.","610":"To avoid surprises, you should ensure that only one entry is present in the {290/} file for the Git server and that it is matching with the URL you provided to the config server.","611":"If you used a hostname in the URL, you want to have exactly that in the {291/} file, not the IP.","612":"The repository is accessed using JGit, so any documentation you find on that should be applicable.","613":"HTTPS proxy settings can be set in {292/} or in the same way as for any other JVM process via system properties ({293/} and {294/}).","614":"Tip","615":"\nIf you don’t know where your {295/} directory is use {296/} to manipulate the settings (e.g. {297/}).\n","616":"Authentication with AWS CodeCommit","617":"AWS CodeCommit authentication can also be done.","618":"AWS CodeCommit uses an authentication helper when using Git from the command line.","619":"This helper is not used with the JGit library, so a JGit CredentialProvider for AWS CodeCommit will be created if the Git URI matches the AWS CodeCommit pattern.","620":"AWS CodeCommit URIs always look like https://git-codecommit.${AWS_REGION}.amazonaws.com/${repopath} .","621":"If you provide a username and password with an AWS CodeCommit URI, then these must be the AWS accessKeyId and secretAccessKey to be used to access the repository.","622":"If you do not specify a username and password, then the accessKeyId and secretAccessKey will be retrieved using the AWS Default Credential Provider Chain .","623":"If your Git URI matches the CodeCommit URI pattern (above) then you must provide valid AWS credentials in the username and password, or in one of the locations supported by the default credential provider chain.","624":"AWS EC2 instances may use IAM Roles for EC2 Instances .","625":"Note: The aws-java-sdk-core jar is an optional dependency.","626":"If the aws-java-sdk-core jar is not on your classpath, then the AWS Code Commit credential provider will not be created regardless of the git server URI.","627":"Placeholders in Git Search Paths","628":"{16/} Server also supports a search path with placeholders for the {298/} and {299/} (and {300/} if you need it).","629":"Example:","630":"searches the repository for files in the same name as the directory (as well as the top level).","631":"Wildcards are also valid in a search path with placeholders (any matching directory is included in the search).","632":"Force pull in Git Repositories","633":"As mentioned before {16/} Server makes a clone of the\nremote git repository and if somehow the local copy gets dirty (e.g.\nfolder content changes by OS process) so {16/} Server\ncannot update the local copy from remote repository.","634":"To solve this there is a {301/} property that will make {22/} Config Server force pull from remote repository if the local copy is dirty.","635":"Example:","636":"If you have a multiple repositories configuration you can configure the {302/} property per repository.","637":"Example:","638":"Note","639":"\nThe default value for {303/} property is {304/}.\n","640":"Version Control Backend Filesystem Use","641":"Warning","642":"With VCS based backends (git, svn) files are checked out or cloned to the local filesystem.","643":"By default they are put in the system temporary directory with a prefix of {305/}.","644":"On linux, for example it could be {306/}.","645":"Some operating systems routinely clean out temporary directories.","646":"This can lead to unexpected behaviour such as missing properties.","647":"To avoid this problem, change the directory Config Server uses, by setting {307/} or {308/} to a directory that does not reside in the system temp structure.","648":"File System Backend","649":"There is also a \"native\" profile in the Config Server that doesn't use Git, but just loads the config files from the local classpath or file system (any static URL you want to point to with \"spring.cloud.config.server.native.searchLocations\").","650":"To use the native profile just launch the Config Server with \"spring.profiles.active=native\".","651":"Note","652":"Remember to use the {309/} prefix for file resources (the default without a prefix is usually the classpath).","653":"Just as with any {19/} configuration you can embed {310/}-style environment placeholders, but remember that absolute paths in Windows require an extra \"/\", eg {311/}","654":"Warning","655":"The default value of the {312/} is identical to a local {19/} application (so {313/}).","656":"This does not expose the {314/} from the server to all clients because any property sources present in the server are removed before being sent to the client.","657":"Tip","658":"A filesystem backend is great for getting started quickly and for testing.","659":"To use it in production you need to be sure that the file system is reliable, and shared across all instances of the Config Server.","660":"The search locations can contain placeholders for {315/}, {316/} and {317/}.","661":"In this way you can segregate the directories in the path, and choose a strategy that makes sense for you (eg sub-directory per application, or sub-directory per profile).","662":"If you don't use placeholders in the search locations, this repository also appends the {318/} parameter of the HTTP resource to a suffix on the search path, so properties files are loaded from each search location and a subdirectory with the same name as the label (the labelled properties take precedence in the {41/} Environment).","663":"Thus the default behaviour with no placeholders is the same as adding a search location ending with {319/} is the same as {320/}","664":"{54/} Backend","665":"{16/} Server also supports {54/} as a backend.","666":"{54/} is a tool for securely accessing secrets.","667":"A secret is anything that you want to tightly control access to, such as API keys, passwords, certificates, and more.","668":"{54/} provides a unified interface to any secret, while providing tight access control and recording a detailed audit log.","669":"For more information on {54/} see the {54/} quickstart guide.","670":"To enable the config server to use a {54/} backend you must run your config server with the {321/} profile.","671":"For example in your config server's {322/} you can add {323/}.","672":"By default the config server will assume your {54/} server is running at {324/}.","673":"It also will assume that the name of backend is {325/} and the key is {326/}.","674":"All of these defaults can be configured in your config server's {327/}.","675":"Below is a table of configurable {54/} properties.","676":"All properties are prefixed with {328/}.","677":"Name","678":"Default Value","681":"http","682":"secret","683":"application","685":"All configurable properties can be found in\n{329/}.","686":"With your config server running you can make HTTP requests to the server to retrieve values from the {54/} backend.","687":"To do this you will need a token for your {54/} server.","688":"First place some data in you {54/}.","689":"For example","690":"Now make the HTTP request to your config server to retrieve the values.","691":"You should see a response similar to this after making the above request.","692":"Multiple {31/} Sources","693":"When using {54/} you can provide your applications with multiple properties sources.","694":"For example, assume you have written data to the following paths in {54/}.","695":"{31/} written to {330/} are available to all applications using the Config Server .","696":"An application with the name {331/} would have any properties written to {332/} and {333/} available to it.","697":"When {334/} has the {335/} profile enabled then properties written to all of the above paths would be available to it, with properties in the first path in the list taking priority over the others.","698":"Sharing Configuration With All Applications","699":"File Based Repositories","700":"With file-based (ie git, svn and native) repositories, resources with file names in {336/} are shared between all client applications (so {337/}, {338/}, {339/} etc.).","701":"You can use resources with these file names to configure global defaults and have them overridden by application-specific files as necessary.","702":"The #_property_overrides[property overrides] feature can also be used\nfor setting global defaults, and with placeholders applications are\nallowed to override them locally.","703":"Tip","704":"With the \"native\" profile (local file system backend) it is recommended that you use an explicit search location that isn't part of the server's own configuration.","705":"Otherwise the {340/} resources in the default search locations are removed because they are part of the server.","706":"{54/} Server","707":"When using {54/} as a backend you can share configuration with all applications by placing configuration in {341/}.","708":"For example, if you run this {54/} command","709":"All applications using the config server will have the properties\n{342/} and {343/} available to them.","710":"Composite Environment Repositories","711":"In some scenarios you may wish to pull configuration data from multiple environment repositories.","712":"To do this just enable multiple profiles in your config server's application properties or YAML file.","713":"If, for example, you want to pull configuration data from a Git repository as well as a SVN repository you would set the following properties for your configuration server.","714":"In addition to each repo specifying a URI, you can also specify an {344/} property.","715":"The {345/} property allows you to specify the priority order for all your repositories.","716":"The lower the numerical value of the {346/} property the higher priority it will have.","717":"The priority order of a repository will help resolve any potential conflicts between repositories that contain values for the same properties.","718":"Note","719":"\nAny type of failure when retrieving values from an environment repositoy\nwill result in a failure for the entire composite environment.\n","720":"Note","721":"When using a composite environment it is important that all repos contain the same label(s).","722":"If you have an environment similar to the one above and you request configuration data with the label {347/} but the SVN repo does not contain a branch called {348/} the entire request will fail.","723":"Custom Composite Environment Repositories","724":"It is also possible to provide your own {349/} bean to be included as part of a composite environment in addition to using one of the environment repositories from {22/}.","725":"To do this your bean must implement the {350/} interface.","726":"If you would like to control the priority of you custom {351/} within the composite environment you should also implement the {352/} interface and override the {353/} method.","727":"If you do not implement the {354/} interface then your {355/} will be given the lowest priority.","728":"Property Overrides","729":"The Config Server has an \"overrides\" feature that allows the operator to provide configuration properties to all applications that cannot be accidentally changed by the application using the normal {19/} hooks.","730":"To declare overrides just add a map of name-value pairs to {356/}.","731":"For example","732":"will cause all applications that are config clients to read {357/} independent of their own configuration.","733":"(Of course an application can use the data in the Config Server in any way it likes, so overrides are not enforceable, but they do provide useful default behaviour if they are {16/} clients.)","734":"Tip","735":"Normal, {41/} environment placeholders with \"${}\" can be escaped (and resolved on the client) by using backslash (\"\\\") to escape the \"$\" or the \"{\", eg {358/} resolves to \"bar\" unless the app provides its own \"app.foo\".","736":"Note that in YAML you don't need to escape the backslash itself, but in properties files you do, when you configure the overrides on the server.","737":"You can change the priority of all overrides in the client to be more\nlike default values, allowing applications to supply their own values\nin environment variables or System properties, by setting the flag\n{359/} (default is false) in the\nremote repository.","738":"Health Indicator","739":"Config Server comes with a Health Indicator that checks if the configured {360/} is working.","740":"By default it asks the {361/} for an application named {362/}, the {363/} profile and the default label provided by the {364/} implementation.","741":"You can configure the Health Indicator to check more applications\nalong with custom profiles and custom labels, e.g.","742":"You can disable the Health Indicator by setting {365/}.","743":"Security","744":"You are free to secure your Config Server in any way that makes sense\nto you (from physical network security to OAuth2 bearer\ntokens), and {41/} Security and {19/} make it easy to do pretty\nmuch anything.","745":"To use the default {19/} configured HTTP Basic security, just include {41/} Security on the classpath (eg through {366/}).","746":"The default is a username of \"user\" and a randomly generated password, which isn't going to be very useful in practice, so we recommend you configure the password (via {367/}) and encrypt it (see below for instructions on how to do that).","747":"Encryption and Decryption","748":"Important","749":"Prerequisites: to use the encryption and decryption features you need the full-strength JCE installed in your JVM (it's not there by default).","750":"You can download the \"Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files\" from Oracle, and follow instructions for installation (essentially replace the 2 policy files in the JRE lib/security directory with the ones that you downloaded).","751":"If the remote property sources contain encrypted content (values starting with {368/}) they will be decrypted before sending to clients over HTTP.","752":"The main advantage of this set up is that the property values don't have to be in plain text when they are \"at rest\" (eg in a git repository).","753":"If a value cannot be decrypted it is removed from the property source and an additional property is added with the same key, but prefixed with \"invalid.\"","754":"and a value that means \"not applicable\" (usually \"<n/a>\").","755":"This is largely to prevent cipher text being used as a password and accidentally leaking.","756":"If you are setting up a remote config repository for config client\napplications it might contain an {369/} like this, for\ninstance:","757":"application.yml","758":"Encrypted values in a .properties file must not be wrapped in quotes, otherwise the value will not be decrypted:","759":"application.properties","760":"You can safely push this plain text to a shared git repository and the\nsecret password is protected.","761":"The server also exposes {370/} and {371/} endpoints (on the assumption that these will be secured and only accessed by authorized agents).","762":"If you are editing a remote config file you can use the Config Server to encrypt values by POSTing to the {372/} endpoint, eg","763":"Note","764":"\nIf the value you are encrypting has characters in it that need to be URL encoded you should use\nthe {373/} option to {374/} to make sure they are encoded properly.\n","765":"The inverse operation is also available via {375/} (provided the server is\nconfigured with a symmetric key or a full key pair):","766":"Tip","767":"\nIf you are testing like this with curl, then use\n{376/} (instead of {377/}) or set an explicit {378/} to make sure curl encodes the data correctly when there\nare special characters ('+' is particularly tricky).\n","768":"Take the encrypted value and add the {379/} prefix before you put\nit in the YAML or properties file, and before you commit and push it\nto a remote, potentially insecure store.","769":"The {380/} and {381/} endpoints also both accept paths of the\nform {382/} which can be used to control cryptography\nper application (name) and profile when clients call into the main\nEnvironment resource.","770":"Note","771":"to control the cryptography in this granular way you must also provide a {383/} of type {384/} that creates a different encryptor per name and profiles.","772":"The one that is provided by default does not do this (so all encryptions use the same key).","773":"The {385/} command line client (with {22/} CLI extensions\ninstalled) can also be used to encrypt and decrypt, e.g.","774":"To use a key in a file (e.g. an RSA public key for encryption) prepend\nthe key value with \"@\" and provide the file path, e.g.","775":"The key argument is mandatory (despite having a {386/} prefix).","776":"Key Management","777":"The Config Server can use a symmetric (shared) key or an asymmetric one (RSA key pair).","778":"The asymmetric choice is superior in terms of security, but it is often more convenient to use a symmetric key since it is just a single property value to configure.","779":"To configure a symmetric key you just need to set {387/} to a\nsecret String (or use an enviroment variable {388/} to keep it\nout of plain text configuration files).","780":"To configure an asymmetric key you can either set the key as a PEM-encoded text value (in {389/}), or via a keystore (eg as created by the {390/} utility that comes with the JDK).","781":"The keystore properties are {391/} with {392/} equal to","782":"{393/} (a {394/} location),","783":"{395/} (to unlock the keystore) and","784":"{396/} (to identify which key in the store is to be\nused).","785":"The encryption is done with the public key, and a private key is needed for decryption.","786":"Thus in principle you can configure only the public key in the server if you only want to do encryption (and are prepared to decrypt the values yourself locally with the private key).","787":"In practice you might not want to do that because it spreads the key management process around all the clients, instead of concentrating it in the server.","788":"On the other hand it's a useful option if your config server really is relatively insecure and only a handful of clients need the encrypted properties.","789":"Creating a Key Store for Testing","790":"To create a keystore for testing you can do something like this:","791":"Put the {397/} file in the classpath (for instance) and then in\nyour {398/} for the Config Server:","792":"Using Multiple Keys and Key Rotation","793":"In addition to the {399/} prefix in encrypted property values, the Config Server looks for {400/} prefixes (zero or many) before the start of the (Base64 encoded) cipher text.","794":"The keys are passed to a {401/} which can do whatever logic it needs to locate a {402/} for the cipher.","795":"If you have configured a keystore ({403/}) the default locator will look for keys in the store with aliases as supplied by the \"key\" prefix, ie with a cipher text like this:","796":"the locator will look for a key named \"testkey\".","797":"A secret can also be supplied via a {404/} value in the prefix, but if it is not the default is to use the keystore password (which is what you get when you build a keytore and don't specify a secret).","798":"If you do supply a secret it is recommended that you also encrypt the secrets using a custom {405/}.","799":"Key rotation is hardly ever necessary on cryptographic grounds if the keys are only being used to encrypt a few bytes of configuration data (ie they are not being used elsewhere), but occasionally you might need to change the keys if there is a security breach for instance.","800":"In that case all the clients would need to change their source config files (eg in git) and use a new {406/} prefix in all the ciphers, checking beforehand of course that the key alias is available in the Config Server keystore.","801":"Tip","802":"\nthe {407/} prefixes can also be added to plaintext posted\nto the {408/} endpoint, if you want to let the Config Server\nhandle all encryption as well as decryption.\n","803":"Serving Encrypted {31/}","804":"Sometimes you want the clients to decrypt the configuration locally, instead of doing it in the server.","805":"In that case you can still have /encrypt and /decrypt endpoints (if you provide the {409/} configuration to locate a key), but you need to explicitly switch off the decryption of outgoing properties using {410/}.","806":"If you don't care about the endpoints, then it should work if you configure neither the key nor the enabled flag.","807":"Serving Alternative Formats","808":"The default JSON format from the environment endpoints is perfect for consumption by {41/} applications because it maps directly onto the {411/} abstraction.","809":"If you prefer you can consume the same data as YAML or Java properties by adding a suffix to the resource path (\".yml\", \".yaml\" or \".properties\").","810":"This can be useful for consumption by applications that do not care about the structure of the JSON endpoints, or the extra metadata they provide, for example an application that is not using {41/} might benefit from the simplicity of this approach.","811":"The YAML and properties representations have an additional flag (provided as a boolean query parameter {412/}) to signal that placeholders in the source documents, in the standard {41/} {413/} form, should be resolved in the output where possible before rendering.","812":"This is a useful feature for consumers that don't know about the {41/} placeholder conventions.","813":"Note","814":"there are limitations in using the YAML or properties formats, mainly in relation to the loss of metadata.","815":"The JSON is structured as an ordered list of property sources, for example, with names that correlate with the source.","816":"The YAML and properties forms are coalesced into a single map, even if the origin of the values has multiple sources, and the names of the original source files are lost.","817":"The YAML representation is not necessarily a faithful representation of the YAML source in a backing repository either: it is constructed from a list of flat property sources, and assumptions have to be made about the form of the keys.","818":"Serving Plain Text","819":"Instead of using the {414/} abstraction (or one of the alternative representations of it in YAML or properties format) your applications might need generic plain text configuration files, tailored to their environment.","820":"The Config Server provides these through an additional endpoint at {415/} where \"name\", \"profile\" and \"label\" have the same meaning as the regular environment endpoint, but \"path\" is a file name (eg {416/}).","821":"The source files for this endpoint are located in the same way as for the environment endpoints: the same search path is used as for properties or YAML files, but instead of aggregating all matching resources, only the first one to match is returned.","822":"After a resource is located, placeholders in the normal format ({417/}) are resolved using the effective {418/} for the application name, profile and label supplied.","823":"In this way the resource endpoint is tightly integrated with the environment endpoints.","824":"Example, if you have this layout for a GIT (or SVN) repository:","825":"where {419/} looks like this:","826":"and {420/} like this:","827":"then the {421/} resource looks like this:","828":"and {422/} like this:","829":"Note","830":"\njust like the source files for environment configuration, the\n\"profile\" is used to resolve the file name, so if you want a\nprofile-specific file then {423/} will be\nresolved by a file called {424/} (in preference\nto {425/}).\n","831":"Embedding the Config Server","832":"The Config Server runs best as a standalone application, but if you need to you can embed it in another application.","833":"Just use the {426/} annotation.","834":"An optional property that can be useful in this case is {427/} which is a flag to indicate that the server should configure itself from its own remote repository.","835":"The flag is off by default because it can delay startup, but when embedded in another application it makes sense to initialize the same way as any other application.","836":"Note","837":"\nIt should be obvious, but remember that if you use the bootstrap\nflag the config server will need to have its name and repository URI\nconfigured in {428/}.\n","838":"To change the location of the server endpoints you can (optionally) set {429/}, eg \"/config\", to serve the resources under a prefix.","839":"The prefix should start but not end with a \"/\".","840":"It is applied to the {430/} in the Config Server (ie underneath the {19/} prefixes {431/} and {432/}).","841":"If you want to read the configuration for an application directly from the backend repository (instead of from the config server) that's basically an embedded config server with no endpoints.","842":"You can switch off the endpoints entirely if you don't use the {433/} annotation (just set {434/}).","843":"Push Notifications and {9/}","844":"Many source code repository providers (like Github, Gitlab or Bitbucket for instance) will notify you of changes in a repository through a webhook.","845":"You can configure the webhook via the provider's user interface as a URL and a set of events in which you are interested.","846":"For instance Github will POST to the webhook with a JSON body containing a list of commits, and a header \"X-Github-Event\" equal to \"push\".","847":"If you add a dependency on the {435/} library and activate the {9/} in your Config Server, then a \"/monitor\" endpoint is enabled.","848":"When the webhook is activated the Config Server will send a {436/} targeted at the applications it thinks might have changed.","849":"The change detection can be strategized, but by default it just looks for changes in files that match the application name (eg \"foo.properties\" is targeted at the \"foo\" application, and \"application.properties\" is targeted at all applications).","850":"The strategy if you want to override the behaviour is {437/} which accepts the request headers and body as parameters and returns a list of file paths that changed.","851":"The default configuration works out of the box with Github, Gitlab or Bitbucket.","852":"In addition to the JSON notifications from Github, Gitlab or Bitbucket you can trigger a change notification by POSTing to \"/monitor\" with a form-encoded body parameters {438/}.","853":"This will broadcast to applications matching the \"{name}\" pattern (can contain wildcards).","854":"Note","855":"\nthe {439/} will only be transmitted if\nthe {440/} is activated in the Config Server and in the\nclient application.\n","856":"Note","857":"\nthe default configuration also detects filesystem changes in\nlocal git repositories (the webhook is not used in that case but as\nsoon as you edit a config file a refresh will be broadcast).\n","858":"{16/} Client","859":"A {19/} application can take immediate advantage of the {41/}\nConfig Server (or other external property sources provided by the\napplication developer), and it will also pick up some additional\nuseful features related to {441/} change events.","860":"Config First Bootstrap","861":"This is the default behaviour for any application which has the {41/} Cloud Config Client on the classpath.","862":"When a config client starts up it binds to the Config Server (via the bootstrap configuration property {442/}) and initializes {41/} {443/} with remote property sources.","863":"The net result of this is that all client apps that want to consume\nthe Config Server need a {444/} (or an environment variable)\nwith the server address in {445/} (defaults to\n\"http://localhost:8888\").","864":"Discovery First Bootstrap","865":"If you are using a `DiscoveryClient implementation, such as {5/}\nand {62/} Service Discovery or {22/} {49/} ({1/} does\nnot support this yet), then you can have the Config Server register with the\nDiscovery Service if you want to, but in the default \"Config First\" mode,\nclients won’t be able to take advantage of the registration.","866":"If you prefer to use {446/} to locate the Config Server, you can do that by setting {447/} (default \"false\").","867":"The net result of that is that client apps all need a {448/} (or an environment variable) with the appropriate discovery configuration.","868":"For example, with {5/}, you need to define the {62/} server address, eg in {449/}.","869":"The price for using this option is an extra network round trip on start up to locate the service registration.","870":"The benefit is that the Config Server can change its co-ordinates, as long as the Discovery Service is a fixed point.","871":"The default service id is \"configserver\" but you can change that on the client with {450/} (and on the server in the usual way for a service, eg by setting {451/}).","872":"The discovery client implementations all support some kind of metadata map (eg for {62/} we have {452/}).","873":"Some additional properties of the Config Server may need to be configured in its service registration metadata so that clients can connect correctly.","874":"If the Config Server is secured with HTTP Basic you can configure the credentials as \"username\" and \"password\".","875":"And if the Config Server has a context path you can set \"configPath\".","876":"Example, for a Config Server that is a {62/} client:","877":"bootstrap.yml","878":"Config Client Fail Fast","879":"In some cases, it may be desirable to fail startup of a service if it cannot connect to the Config Server.","880":"If this is the desired behavior, set the bootstrap configuration property {453/} and the client will halt with an Exception.","881":"Config Client Retry","882":"If you expect that the config server may occasionally be unavailable when your app starts, you can ask it to keep trying after a failure.","883":"First you need to set {454/}, and then you need to add {455/} and {456/} to your classpath.","884":"The default behaviour is to retry 6 times with an initial backoff interval of 1000ms and an exponential multiplier of 1.1 for subsequent backoffs.","885":"You can configure these properties (and others) using {457/} configuration properties.","886":"Tip","887":"To take full control of the retry add a {458/} of type {459/} with id \"configServerRetryInterceptor\".","888":"{41/} Retry has a {460/} that makes it easy to create one.","889":"Locating Remote Configuration Resources","890":"The Config Service serves property sources from {461/}, where the default bindings in the client app are","891":"\"name\" = {462/}","892":"\"profile\" = {463/} (actually {464/})","893":"\"label\" = \"master\"","894":"All of them can be overridden by setting {465/} (where {466/} is \"name\", \"profile\" or \"label\").","895":"The \"label\" is useful for rolling back to previous versions of configuration;","896":"with the default Config Server implementation it can be a git label, branch name or commit id.","897":"Label can also be provided as a comma-separated list, in which case the items in the list are tried on-by-one until one succeeds.","898":"This can be useful when working on a feature branch, for instance, when you might want to align the config label with your branch, but make it optional (eg {467/}).","899":"Security","900":"If you use HTTP Basic security on the server then clients just need to know the password (and username if it isn't the default).","901":"You can do that via the config server URI, or via separate username and password properties, eg","902":"bootstrap.yml","903":"or","904":"bootstrap.yml","905":"The {468/} and {469/}\nvalues override anything that is provided in the URI.","906":"If you deploy your apps on Cloud Foundry then the best way to provide the password is through service credentials, eg in the URI, since then it doesn't even need to be in a config file.","907":"An example which works locally and for a user-provided service on Cloud Foundry named \"configserver\":","908":"bootstrap.yml","909":"If you use another form of security you might need to provide a\n{470/} to the {471/} (e.g. by\ngrabbing it in the bootstrap context and injecting one).","910":"Health Indicator","911":"The Config Client supplies a {19/} Health Indicator that attempts to load configuration from Config Server.","912":"The health indicator can be disabled by setting {472/}.","913":"The response is also cached for performance reasons.","914":"The default cache time to live is 5 minutes.","915":"To change that value set the {473/} property (in milliseconds).","916":"Providing A Custom RestTemplate","917":"In some cases you might need to customize the requests made to the config server from the client.","918":"Typically this involves passing special {474/} headers to authenticate requests to the server.","919":"To provide a custom {475/} follow the steps below.","920":"Set {476/} to disable the existing config server\nproperty source.","921":"Create a new configuration bean with an implementation of {477/}.","922":"CustomConfigServiceBootstrapConfiguration.java","923":"In {478/} create a file called\n{479/} and specify your custom configuration.","924":"spring.factorties","926":"When using {54/} as a backend to your config server the client will need to supply a token for the server to retrieve values from {54/}.","927":"This token can be provided within the client by setting {480/} in {481/}.","928":"bootstrap.yml","930":"Nested Keys In {54/}","931":"{54/} supports the ability to nest keys in a value stored in {54/}.","932":"For example","933":"This command will write a JSON object to your {54/}.","934":"To access these values in {41/} you would use the traditional dot(.) annotation.","935":"For example","936":"The above code would set the {482/} variable to {483/}.","938":"Dalston.RELEASE","939":"This project provides Netflix OSS integrations for {19/} apps through autoconfiguration and binding to the {41/} Environment and other {41/} programming model idioms.","940":"With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with battle-tested Netflix components.","941":"The patterns provided include Service Discovery ({62/}), Circuit Breaker ({47/}), Intelligent Routing ({60/}) and Client Side Load Balancing ({43/}).","942":"Service Discovery: {62/} Clients","943":"Service Discovery is one of the key tenets of a microservice based architecture.","944":"Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.","945":"{62/} is the Netflix Service Discovery Server and Client.","946":"The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others.","947":"How to Include {62/} Client","948":"To include {62/} Client in your project use the starter with group {484/} and artifact id {485/}.","949":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","950":"Registering with {62/}","951":"When a client registers with {62/}, it provides meta-data about itself such as host and port, health indicator URL, home page etc. {62/} receives heartbeat messages from each instance belonging to a service.","952":"If the heartbeat fails over a configurable timetable, the instance is normally removed from the registry.","953":"Example eureka client:","954":"(ie utterly normal {19/} app).","955":"In this example we use {486/} explicitly, but with only {62/} available you could also use {487/}.","956":"Configuration is required to locate the {62/} server.","957":"Example:","958":"application.yml","959":"where \"defaultZone\" is a magic string fallback value that provides the\nservice URL for any client that doesn’t express a preference\n(i.e. it’s a useful default).","960":"The default application name (service ID), virtual host and non-secure\nport, taken from the {488/}, are {489/},\n{490/} and {491/} respectively.","961":"{492/} makes the app into both a {62/} \"instance\" (ie it registers itself) and a \"client\" (ie it can query the registry to locate other services).","962":"The instance behaviour is driven by {493/} configuration keys, but the defaults will be fine if you ensure that your application has a {494/} (this is the default for the {62/} service ID, or VIP).","963":"See EurekaInstanceConfigBean and EurekaClientConfigBean for more details of the configurable options.","964":"Authenticating with the {62/} Server","965":"HTTP basic authentication will be automatically added to your eureka client if one of the {495/} URLs has credentials embedded in it (curl style, like {496/}).","966":"For more complex needs you can create a {497/} of type {498/} and inject {499/} instances into it, all of which will be applied to the calls from the client to the server.","967":"Note","968":"\nBecause of a limitation in {62/} it isn’t possible to support\nper-server basic auth credentials, so only the first set that are\nfound will be used.\n","969":"Status Page and Health Indicator","970":"The status page and health indicators for a {62/} instance default to \"/info\" and \"/health\" respectively, which are the default locations of useful endpoints in a {19/} Actuator application.","971":"You need to change these, even for an Actuator application if you use a non-default context path or servlet path (eg {500/}) or management endpoint path (eg {501/}).","972":"Example:","973":"application.yml","974":"These links show up in the metadata that is consumed by clients, and\nused in some scenarios to decide whether to send requests to your\napplication, so it’s helpful if they are accurate.","975":"Registering a Secure Application","976":"If your app wants to be contacted over HTTPS you can set two flags in the {502/}, viz {503/} respectively.","977":"This will make {62/} publish instance information showing an explicit preference for secure communication.","978":"The {41/} Cloud {504/} will always return an {505/} URI for a service configured this way, and the {62/} (native) instance information will have a secure health check URL.","979":"Because of the way {62/} works internally, it will still publish a non-secure URL for status and home page unless you also override those explicitly.","980":"You can use placeholders to configure the eureka instance urls, eg","981":"application.yml","982":"(Note that {506/} is a native placeholder only available\nin later versions of {62/}. You could achieve the same thing with\n{41/} placeholders as well, e.g. using {507/}.)","983":"Note","984":"If your app is running behind a proxy, and the SSL termination is in the proxy (eg if you run in Cloud Foundry or other platforms as a service) then you will need to ensure that the proxy \"forwarded\" headers are intercepted and handled by the application.","985":"An embedded Tomcat container in a {19/} app does this automatically if it has explicit configuration for the 'X-Forwarded-\\*` headers.","986":"A sign that you got this wrong will be that the links rendered by your app to itself will be wrong (the wrong host, port or protocol).","987":"{62/}’s Health Checks","988":"By default, {62/} uses the client heartbeat to determine if a client is up.","989":"Unless specified otherwise the Discovery Client will not propagate the current health check status of the application per the {19/} Actuator.","990":"Which means that after successful registration {62/} will always announce that the application is in 'UP' state.","991":"This behaviour can be altered by enabling {62/} health checks, which results in propagating application status to {62/}.","992":"As a consequence every other application won't be sending traffic to application in state other then 'UP'.","993":"application.yml","994":"Warning","995":"{508/} should only be set in {509/}.","996":"Setting the value in {510/} will cause undesirable side effects like registering in eureka with an {511/} status.","997":"If you require more control over the health checks, you may consider\nimplementing your own {512/}.","998":"{62/} Metadata for Instances and Clients","999":"It's worth spending a bit of time understanding how the {62/} metadata works, so you can use it in a way that makes sense in your platform.","1000":"There is standard metadata for things like hostname, IP address, port numbers, status page and health check.","1001":"These are published in the service registry and used by clients to contact the services in a straightforward way.","1002":"Additional metadata can be added to the instance registration in the {513/}, and this will be accessible in the remote clients, but in general will not change the behaviour of the client, unless it is made aware of the meaning of the metadata.","1003":"There are a couple of special cases described below where {22/} already assigns meaning to the metadata map.","1004":"Using {62/} on Cloudfoundry","1005":"Cloudfoundry has a global router so that all instances of the same app have the same hostname (it's the same in other PaaS solutions with a similar architecture).","1006":"This isn't necessarily a barrier to using {62/}, but if you use the router (recommended, or even mandatory depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router.","1007":"You might also want to use instance metadata so you can distinguish between the instances on the client (eg in a custom load balancer).","1008":"By default, the {514/} is {515/}.","1009":"For example:","1010":"application.yml","1011":"Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls.","1012":"This feature is not (yet) available on Pivotal Web Services ( PWS ).","1013":"Using {62/} on AWS","1014":"If the application is planned to be deployed to an AWS cloud, then the {62/} instance will have to be configured to be AWS aware and this can be done by customizing the EurekaInstanceConfigBean the following way:","1015":"Changing the {62/} Instance ID","1016":"A vanilla Netflix {62/} instance is registered with an ID that is equal to its host name (ie only one service per host).","1017":"{22/} {62/} provides a sensible default that looks like this: {516/}.","1018":"For example {517/}.","1019":"Using {22/} you can override this by providing a unique identifier in {518/}.","1020":"For example:","1021":"application.yml","1022":"With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique.","1023":"In Cloudfoundry the {519/} will be populated automatically in a {19/} application, so the random value will not be needed.","1024":"Using the EurekaClient","1025":"Once you have an app that is {520/} (or {521/}) you can use it to discover service instances from the {62/} Server .","1026":"One way to do that is to use the native {522/} (as opposed to the {41/} Cloud {523/}), eg","1027":"Tip","1028":"Don't use the {524/} in {525/} method or in a {526/} method (or anywhere where the {527/} might not be started yet).","1029":"It is initialized in a {528/} (with {529/}) so the earliest you can rely on it being available is in another {530/} with higher phase.","1030":"Alternatives to the native Netflix EurekaClient","1031":"You don't have to use the raw Netflix {531/} and usually it is more convenient to use it behind a wrapper of some sort.","1032":"{41/} Cloud has support for {55/} (a REST client builder) and also {41/} {532/} using the logical {62/} service identifiers (VIPs) instead of physical URLs.","1033":"To configure {43/} with a fixed list of physical servers you can simply set {533/} to a comma-separated list of physical addresses (or hostnames), where {534/} is the ID of the client.","1034":"You can also use the {535/}\nwhich provides a simple API for discovery clients that is not specific\nto Netflix, e.g.","1035":"Why is it so Slow to Register a Service?","1036":"Being an instance also involves a periodic heartbeat to the registry (via the client's {536/}) with default duration 30 seconds.","1037":"A service is not available for discovery by clients until the instance, the server and the client all have the same metadata in their local cache (so it could take 3 heartbeats).","1038":"You can change the period using {537/} and this will speed up the process of getting clients connected to other services.","1039":"In production it's probably better to stick with the default because there are some computations internally in the server that make assumptions about the lease renewal period.","1040":"Zones","1041":"If you have deployed {62/} clients to multiple zones than you may prefer that those clients leverage services within the same zone before trying services in another zone.","1042":"To do this you need to configure your {62/} clients correctly.","1043":"First, you need to make sure you have {62/} servers deployed to each zone and that they are peers of each other.","1044":"See the section on zones and regions for more information.","1045":"Next you need to tell {62/} which zone your service is in. You can do this using the {538/} property.","1046":"For example if {539/} is deployed to both {540/} and {541/} you would need to set the following {62/} properties in {542/}","1047":"Service 1 in Zone 1","1048":"Service 1 in Zone 2","1049":"Service Discovery: {62/} Server","1050":"How to Include {62/} Server","1051":"To include {62/} Server in your project use the starter with group {543/} and artifact id {544/}.","1052":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1053":"How to Run a {62/} Server","1054":"Example eureka server;","1055":"The server has a home page with a UI, and HTTP API endpoints per the\nnormal {62/} functionality under {545/}.","1056":"{62/} background reading: see flux capacitor and google group discussion.","1057":"Tip","1058":"Due to Gradle's dependency resolution rules and the lack of a parent bom feature, simply depending on spring-cloud-starter-eureka-server can cause failures on application startup.","1059":"To remedy this the {19/} Gradle plugin must be added and the {41/} cloud starter parent bom must be imported like so:","1060":"build.gradle","1061":"High Availability, Zones and Regions","1062":"The {62/} server does not have a backend store, but the service instances in the registry all have to send heartbeats to keep their registrations up to date (so this can be done in memory).","1063":"Clients also have an in-memory cache of eureka registrations (so they don't have to go to the registry for every single request to a service).","1064":"By default every {62/} server is also a {62/} client and requires (at least one) service URL to locate a peer.","1065":"If you don't provide it the service will run and work, but it will shower your logs with a lot of noise about not being able to register with the peer.","1066":"See also below for details of {43/}\nsupport on the client side for Zones and Regions.","1067":"Standalone Mode","1068":"The combination of the two caches (client and server) and the heartbeats make a standalone {62/} server fairly resilient to failure, as long as there is some sort of monitor or elastic runtime keeping it alive (eg Cloud Foundry).","1069":"In standalone mode, you might prefer to switch off the client side behaviour, so it doesn't keep trying and failing to reach its peers.","1070":"Example:","1071":"application.yml (Standalone {62/} Server)","1072":"Notice that the {546/} is pointing to the same host as the local\ninstance.","1073":"Peer Awareness","1074":"{62/} can be made even more resilient and available by running multiple instances and asking them to register with each other.","1075":"In fact, this is the default behaviour, so all you need to do to make it work is add a valid {547/} to a peer, eg","1076":"application.yml (Two Peer Aware {62/} Servers)","1077":"In this example we have a YAML file that can be used to run the same server on 2 hosts (peer1 and peer2), by running it in different {41/} profiles.","1078":"You could use this configuration to test the peer awareness on a single host (there's not much value in doing that in production) by manipulating {548/} to resolve the host names.","1079":"In fact, the {549/} is not needed if you are running on a machine that knows its own hostname (it is looked up using {550/} by default).","1080":"You can add multiple peers to a system, and as long as they are all connected to each other by at least one edge, they will synchronize the registrations amongst themselves.","1081":"If the peers are physically separated (inside a data centre or between multiple data centres) then the system can in principle survive split-brain type failures.","1082":"Prefer IP Address","1083":"In some cases, it is preferable for {62/} to advertise the IP Adresses of services rather than the hostname.","1084":"Set {551/} to {552/} and when the application registers with eureka, it will use its IP Address rather than its hostname.","1085":"Circuit Breaker: {47/} Clients","1086":"Netflix has created a library called {47/} that implements the circuit breaker pattern .","1087":"In a microservice architecture it is common to have multiple layers of service calls.","1088":"Figure 1. Microservice Graph","1089":"A service failure in the lower level of services can cause cascading failure all the way up to the user.","1090":"When calls to a particular service reach a certain threshold (20 failures in 5 seconds is the default in {47/}), the circuit opens and the call is not made.","1091":"In cases of error and an open circuit a fallback can be provided by the developer.","1092":"Figure 2. {47/} fallback prevents cascading failures","1093":"Having an open circuit stops cascading failures and allows overwhelmed or failing services time to heal.","1094":"The fallback can be another {47/} protected call, static data or a sane empty value.","1095":"Fallbacks may be chained so the first fallback makes some other business call which in turn falls back to static data.","1096":"How to Include {47/}","1097":"To include {47/} in your project use the starter with group {553/} and artifact id {554/}.","1098":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1099":"Example boot app:","1100":"The {555/} is provided by a Netflix contrib library called \"javanica\" .","1101":"{22/} automatically wraps {41/} beans with that annotation in a proxy that is connected to the {47/} circuit breaker.","1102":"The circuit breaker calculates when to open and close the circuit, and what to do in case of a failure.","1103":"To configure the {556/} you can use the {557/} attribute with a list of {558/} annotations.","1104":"See here for more details.","1105":"See the {47/} wiki for details on the properties available.","1106":"Propagating the Security Context or using {41/} Scopes","1107":"If you want some thread local context to propagate into a {559/} the default declaration will not work because it executes the command in a thread pool (in case of timeouts).","1108":"You can switch {47/} to use the same thread as the caller using some configuration, or directly in the annotation, by asking it to use a different \"Isolation Strategy\".","1109":"For example:","1110":"The same thing applies if you are using {560/} or {561/}.","1111":"You will know when you need to do this because of a runtime exception that says it can't find the scoped context.","1112":"You also have the option to set the {562/} property to {563/}.","1113":"Doing so will auto configure an {47/} concurrency strategy plugin hook who will transfer the {564/} from your main thread to the one used by the {47/} command.","1114":"{47/} does not allow multiple hystrix concurrency strategy to be registered so an extension mechanism is available by declaring your own {565/} as a {41/} bean.","1115":"{22/} will lookup for your implementation within the {41/} context and wrap it inside its own plugin.","1116":"Health Indicator","1117":"The state of the connected circuit breakers are also exposed in the\n{566/} endpoint of the calling application.","1118":"{47/} Metrics Stream","1119":"To enable the {47/} metrics stream include a dependency on {567/}.","1120":"This will expose the {568/} as a management endpoint.","1121":"Circuit Breaker: {47/} Dashboard","1122":"One of the main benefits of {47/} is the set of metrics it gathers about each HystrixCommand.","1123":"The {47/} Dashboard displays the health of each circuit breaker in an efficient manner.","1124":"Figure 3. {47/} Dashboard","1125":"{47/} Timeouts And {43/} Clients","1126":"When using {47/} commands that wrap {43/} clients you want to make sure your {47/} timeout is configured to be longer than the configured {43/} timeout, including any potential retries that might be made.","1127":"For example, if your {43/} connection timeout is one second and the {43/} client might retry the request three times, than your {47/} timeout should be slightly more than three seconds.","1128":"How to Include {47/} Dashboard","1129":"To include the {47/} Dashboard in your project use the starter with group {569/} and artifact id {570/}.","1130":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1131":"To run the {47/} Dashboard annotate your {19/} main class with {571/}.","1132":"You then visit {572/} and point the dashboard to an individual instances {573/} endpoint in a {47/} client application.","1134":"Looking at an individual instances {47/} data is not very useful in terms of the overall health of the system.","1135":"{50/} is an application that aggregates all of the relevant {574/} endpoints into a combined {575/} for use in the {47/} Dashboard.","1136":"Individual instances are located via {62/}.","1137":"Running {50/} is as simple as annotating your main class with the {576/} annotation (eg using spring-cloud-starter-turbine to set up the classpath).","1138":"All of the documented configuration properties from the {50/} 1 wiki apply.","1139":"The only difference is that the {577/} does not need the port prepended as this is handled automatically unless {578/}.","1140":"Note","1141":"By default, {50/} looks for the {579/} endpoint on a registered instance by looking up its {580/} entry in {62/}, then appending {581/} to it.","1142":"This means that if {582/} is running on its own port (which is the default), the call to {583/} will fail.","1143":"To make turbine find the {47/} stream at the correct port, you need to add {584/} to the instances' metadata:","1144":"The configuration key {585/} is a list of eureka serviceIds that turbine will use to lookup instances.","1145":"The turbine stream is then used in the {47/} dashboard using a url that looks like: {586/} (the cluster parameter can be omitted if the name is \"default\").","1146":"The {587/} parameter must match an entry in {588/}.","1147":"Values returned from eureka are uppercase, thus we expect this example to work if there is an app registered with {62/} called \"customers\":","1148":"The {589/} can be customized by a SPEL expression in {590/} with root an instance of {591/}.","1149":"The default value is {592/}, which means that the {62/} serviceId ends up as the cluster key (ie the {593/} for customers has an {594/} of \"CUSTOMERS\").","1150":"A different example would be {595/}, which would get the cluster name from the AWS ASG name.","1151":"Another example:","1152":"In this case, the cluster name from 4 services is pulled from their metadata map, and is expected to have values that include \"SYSTEM\" and \"USER\".","1153":"To use the \"default\" cluster for all apps you need a string literal expression (with single quotes, and escaped with double quotes if it is in YAML as well):","1154":"{22/} provides a {596/} that has all the dependencies you need to get a {50/} server running.","1155":"Just create a {19/} application and annotate it with {597/}.","1156":"Note","1157":"by default {22/} allows {50/} to use the host and port to allow multiple processes per host, per cluster.","1158":"If you want the native Netflix behaviour built into {50/} that does not allow multiple processes per host, per cluster (the key to the instance id is the hostname), then set the property {598/}.","1160":"In some environments (eg in a PaaS setting), the classic {50/} model of pulling metrics from all the distributed {47/} commands doesn't work.","1161":"In that case you might want to have your {47/} commands push metrics to {50/}, and {22/} enables that with messaging.","1162":"All you need to do on the client is add a dependency to {599/} and the {600/} of your choice (see {22/} Stream documentation for details on the brokers, and how to configure the client credentials, but it should work out of the box for a local broker).","1163":"On the server side Just create a {19/} application and annotate it with {601/} and by default it will come up on port 8989 (point your {47/} dashboard to that port, any path).","1164":"You can customize the port using either {602/} or {603/}.","1165":"If you have {604/} and {605/} on the classpath as well, then you can open up the Actuator endpoints on a separate port (with Tomcat by default) by providing a {606/} which is different.","1166":"You can then point the {47/} Dashboard to the {15/} Server instead of individual {47/} streams.","1167":"If {15/} is running on port 8989 on myhost, then put {607/} in the stream input field in the {47/} Dashboard.","1168":"Circuits will be prefixed by their respective serviceId, followed by a dot, then the circuit name.","1169":"{22/} provides a {608/} that has all the dependencies you need to get a {15/} server running - just add the Stream binder of your choice, eg {609/}.","1170":"You need Java 8 to run the app because it is Netty-based.","1171":"Client Side Load Balancer: {43/}","1172":"{43/} is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients.","1173":"{55/} already uses {43/}, so if you are using {610/} then this section also applies.","1174":"A central concept in {43/} is that of the named client.","1175":"Each load balancer is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer (eg using the {611/} annotation).","1176":"{22/} creates a new ensemble as an {612/} on demand for each named client using {613/}.","1177":"This contains (amongst other things) an {614/}, a {615/}, and a {616/}.","1178":"How to Include {43/}","1179":"To include {43/} in your project use the starter with group {617/} and artifact id {618/}.","1180":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1181":"Customizing the {43/} Client","1182":"You can configure some bits of a {43/} client using external properties in {619/}, which is no different than using the Netflix APIs natively, except that you can use {19/} configuration files.","1183":"The native options can be inspected as static fields in {620/} (part of ribbon-core).","1184":"{22/} also lets you take full control of the client by declaring additional configuration (on top of the {621/}) using {622/}.","1185":"Example:","1186":"In this case the client is composed from the components already in\n{623/} together with any in {624/}\n(where the latter generally will override the former).","1187":"Warning","1188":"The {625/} has to be {626/} but take care that it is not in a {627/} for the main application context, otherwise it will be shared by all the {628/}.","1189":"If you use {629/} (or {630/}) you need to take steps to avoid it being included (for instance put it in a separate, non-overlapping package, or specify the packages to scan explicitly in the {631/}).","1190":"{5/} provides the following beans by default for ribbon\n({632/} beanName: {633/}):","1191":"{634/} ribbonClientConfig: {635/}","1192":"{636/} ribbonRule: {637/}","1193":"{638/} ribbonPing: {639/}","1194":"{640/} ribbonServerList: {641/}","1195":"{642/} ribbonServerListFilter: {643/}","1196":"{644/} ribbonLoadBalancer: {645/}","1197":"{646/} ribbonServerListUpdater: {647/}","1198":"Creating a bean of one of those type and placing it in a {648/} configuration (such as {649/} above) allows you to override each one of the beans described.","1199":"Example:","1200":"This replaces the {650/} with {651/}.","1201":"Customizing the {43/} Client using properties","1202":"Starting with version 1.2.0, {5/} now supports customizing {43/} clients using properties to be compatible with the {43/} documentation.","1203":"This allows you to change behavior at start up time in different environments.","1204":"The supported properties are listed below and should be prefixed by {652/}:","1205":"{653/}: should implement {654/}","1206":"{655/}: should implement {656/}","1207":"{657/}: should implement {658/}","1208":"{659/}: should implement {660/}","1209":"{661/} should implement {662/}","1210":"Note","1211":"\nClasses defined in these properties have precedence over beans defined using {663/} and the defaults provided by {5/}.\n","1212":"To set the {664/} for a service name {665/} you could set the following:","1213":"application.yml","1214":"See the {43/} documentation for implementations provided by {43/}.","1215":"Using {43/} with {62/}","1216":"When {62/} is used in conjunction with {43/} (ie, both are on the classpath) the {666/} is overridden with an extension of {667/} which populates the list of servers from {62/}.","1217":"It also replaces the {668/} interface with {669/} which delegates to {62/} to determine if a server is up.","1218":"The {670/} that is installed by default is a {671/} and the purpose of this is to make physical metadata available to the load balancer without using AWS AMI metadata (which is what Netflix relies on).","1219":"By default the server list will be constructed with \"zone\" information as provided in the instance metadata (so on the remote clients set {672/}), and if that is missing it can use the domain name from the server hostname as a proxy for zone (if the flag {673/} is set).","1220":"Once the zone information is available it can be used in a {674/}.","1221":"By default it will be used to locate a server in the same zone as the client because the default is a {675/}.","1222":"The zone of the client is determined the same way as the remote instances by default, ie via {676/}.","1223":"Note","1224":"\nThe orthodox \"archaius\" way to set the client zone is via a\nconfiguration property called \"@zone\", and {22/} will use that\nin preference to all other settings if it is available (note that the\nkey will have to be quoted in YAML configuration).\n","1225":"Note","1226":"If there is no other source of zone data then a guess is made based on the client configuration (as opposed to the instance configuration).","1227":"We take {677/}, which is a map from region name to a list of zones, and pull out the first zone for the instance's own region (ie the {678/}, which defaults to \"us-east-1\" for comatibility with native Netflix).","1228":"Example: How to Use {43/} Without {62/}","1229":"{62/} is a convenient way to abstract the discovery of remote servers so you don't have to hard code their URLs in clients, but if you prefer not to use it, {43/} and {55/} are still quite amenable.","1230":"Suppose you have declared a {679/} for \"stores\", and {62/} is not in use (and not even on the classpath).","1231":"The {43/} client defaults to a configured server list, and you can supply the configuration like this","1232":"application.yml","1233":"Example: Disable {62/} use in {43/}","1234":"Setting the property {680/} will explicitly\ndisable the use of {62/} in {43/}.","1235":"application.yml","1236":"Using the {43/} API Directly","1237":"You can also use the {681/} directly.","1238":"Example:","1239":"Caching of {43/} Configuration","1240":"Each {43/} named client has a corresponding child Application Context that {22/} maintains, this application context is lazily loaded up on the first request to the named client.","1241":"This lazy loading behavior can be changed to instead eagerly load up these child Application contexts at startup by specifying the names of the {43/} clients.","1242":"application.yml","1243":"Declarative REST Client: {55/}","1244":"{55/} is a declarative web service client.","1245":"It makes writing web service clients easier.","1246":"To use {55/} create an interface and annotate it.","1247":"It has pluggable annotation support including {55/} annotations and JAX-RS annotations.","1248":"{55/} also supports pluggable encoders and decoders.","1249":"{22/} adds support for {41/} MVC annotations and for using the same {682/} used by default in {41/} Web.","1250":"{22/} integrates {43/} and {62/} to provide a load balanced http client when using {55/}.","1251":"How to Include {55/}","1252":"To include {55/} in your project use the starter with group {683/} and artifact id {684/}.","1253":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1254":"Example {30/} app","1255":"StoreClient.java","1256":"In the {685/} annotation the String value (\"stores\" above) is an arbitrary client name, which is used to create a {43/} load balancer (see below for details of {43/} support ).","1257":"You can also specify a URL using the {686/} attribute (absolute value or just a hostname).","1258":"The name of the bean in the application context is the fully qualified name of the interface.","1259":"To specify your own alias value you can use the {687/} value of the {688/} annotation.","1260":"The {43/} client above will want to discover the physical addresses for the \"stores\" service.","1261":"If your application is a {62/} client then it will resolve the service in the {62/} service registry.","1262":"If you don't want to use {62/}, you can simply configure a list of servers in your external configuration (see above for example ).","1263":"Overriding {55/} Defaults","1264":"A central concept in {22/}'s {55/} support is that of the named client.","1265":"Each feign client is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer using the {689/} annotation.","1266":"{22/} creates a new ensemble as an {690/} on demand for each named client using {691/}.","1267":"This contains (amongst other things) an {692/}, a {693/}, and a {694/}.","1268":"{22/} lets you take full control of the feign client by declaring additional configuration (on top of the {695/}) using {696/}.","1269":"Example:","1270":"In this case the client is composed from the components already in {697/} together with any in {698/} (where the latter will override the former).","1271":"Note","1272":"{699/} does not need to be annotated with {700/}.","1273":"However, if it is, then take care to exclude it from any {701/} that would otherwise include this configuration as it will become the default source for {702/}, {703/}, {704/}, etc., when specified.","1274":"This can be avoided by putting it in a separate, non-overlapping package from any {705/} or {706/}, or it can be explicitly excluded in {707/}.","1275":"Note","1276":"\nThe {708/} attribute is now deprecated in favor of the {709/} attribute.\n","1277":"Warning","1278":"Previously, using the {710/} attribute, did not require the {711/} attribute.","1279":"Using {712/} is now required.","1280":"Placeholders are supported in the {713/} and {714/} attributes.","1281":"{5/} provides the following beans by default for feign ({715/} beanName: {716/}):","1282":"{717/} feignDecoder: {718/} (which wraps a {719/})","1283":"{720/} feignEncoder: {721/}","1284":"{722/} feignLogger: {723/}","1285":"{724/} feignContract: {725/}","1286":"{726/} feignBuilder: {727/}","1287":"{728/} feignClient: if {43/} is enabled it is a {729/}, otherwise the default feign client is used.","1288":"The OkHttpClient and ApacheHttpClient feign clients can be used by setting {730/} or {731/} to {732/}, respectively, and having them on the classpath.","1289":"{5/} does not provide the following beans by default for feign, but still looks up beans of these types from the application context to create the feign client:","1290":"Creating a bean of one of those type and placing it in a {733/} configuration (such as {734/} above) allows you to override each one of the beans described.","1291":"Example:","1292":"This replaces the {735/} with {736/} and adds a {737/} to the collection of {738/}.","1293":"Default configurations can be specified in the {739/} attribute {740/} in a similar manner as described above.","1294":"The difference is that this configuration will apply to all feign clients.","1295":"Note","1296":"\nIf you need to use {741/} bound variables in your {742/} or disable {47/} in {55/}.\n","1297":"application.yml","1298":"Creating {55/} Clients Manually","1299":"In some cases it might be necessary to customize your {55/} Clients in a way that is not possible using the methods above.","1300":"In this case you can create Clients using the {55/} Builder API .","1301":"Below is an example which creates two {55/} Clients with the same interface but configures each one with a separate request interceptor.","1302":"Note","1303":"\nIn the above example {743/} is the default configuration\nprovided by {5/}.\n","1304":"Note","1305":"\n{744/} is the name of the service the Clients will be making requests to.\n","1306":"{10/} Support","1307":"If {47/} is on the classpath and {745/}, {55/} will wrap all methods with a circuit breaker.","1308":"Returning a {746/} is also available.","1309":"This lets you use reactive patterns (with a call to {747/} or {748/} or asynchronous use (with a call to {749/}).","1310":"To disable {47/} support on a per-client basis create a vanilla {750/} with the \"prototype\" scope, e.g.:","1311":"Warning","1312":"Prior to the {22/} Dalston release, if {47/} was on the classpath {55/} would have wrapped all methods in a circuit breaker by default.","1313":"This default behavior was changed in {22/} Dalston in favor for an opt-in approach.","1314":"{10/} Fallbacks","1315":"{47/} supports the notion of a fallback: a default code path that is executed when they circuit is open or there is an error.","1316":"To enable fallbacks for a given {751/} set the {752/} attribute to the class name that implements the fallback.","1317":"If one needs access to the cause that made the fallback trigger, one can use the {753/} attribute inside {754/}.","1318":"Warning","1319":"There is a limitation with the implementation of fallbacks in {55/} and how {47/} fallbacks work.","1320":"Fallbacks are currently not supported for methods that return {755/} and {756/}.","1321":"{55/} and {757/}","1322":"When using {55/} with {47/} fallbacks, there are multiple beans in the {758/} of the same type.","1323":"This will cause {759/} to not work because there isn't exactly one bean, or one marked as primary.","1324":"To work around this, {5/} marks all {55/} instances as {760/}, so {41/} Framework will know which bean to inject.","1325":"In some cases, this may not be desirable.","1326":"To turn off this behavior set the {761/} attribute of {762/} to false.","1327":"{55/} Inheritance Support","1328":"{55/} supports boilerplate apis via single-inheritance interfaces.","1329":"This allows grouping common operations into convenient base interfaces.","1330":"UserService.java","1331":"UserResource.java","1332":"UserClient.java","1333":"Note","1334":"It is generally not advisable to share an interface between a server and a client.","1335":"It introduces tight coupling, and also actually doesn't work with {41/} MVC in its current form (method parameter mapping is not inherited).","1336":"{55/} request/response compression","1337":"You may consider enabling the request or response GZIP compression for your {55/} requests.","1338":"You can do this by enabling one of the properties:","1339":"{55/} request compression gives you settings similar to what you may set for your web server:","1340":"These properties allow you to be selective about the compressed media types and minimum request threshold length.","1341":"{55/} logging","1342":"A logger is created for each {55/} client created.","1343":"By default the name of the logger is the full class name of the interface used to create the {55/} client.","1344":"{55/} logging only responds to the {763/} level.","1345":"application.yml","1346":"The {764/} object that you may configure per client, tells {55/} how much to log.","1347":"Choices are:","1348":"{765/}, No logging (DEFAULT).","1349":"{766/}, Log only the request method and URL and the response status code and execution time.","1350":"{767/}, Log the basic information along with request and response headers.","1351":"{768/}, Log the headers, body, and metadata for both requests and responses.","1352":"For example, the following would set the {769/} to {770/}:","1353":"External Configuration: {38/}","1354":"{38/} is the Netflix client side configuration library.","1355":"It is the library used by all of the Netflix OSS components for configuration.","1356":"{38/} is an extension of the Apache Commons Configuration project.","1357":"It allows updates to configuration by either polling a source for changes or for a source to push changes to the client.","1358":"{38/} uses Dynamic<Type>Property classes as handles to properties.","1359":"{38/} Example","1360":"{38/} has its own set of configuration files and loading priorities.","1361":"{41/} applications should generally not use {38/} directly, but the need to configure the Netflix tools natively remains.","1362":"{22/} has a {41/} Environment Bridge so {38/} can read properties from the {41/} Environment.","1363":"This allows {19/} projects to use the normal configuration toolchain, while allowing them to configure the Netflix tools, for the most part, as documented.","1364":"Router and Filter: {60/}","1365":"Routing in an integral part of a microservice architecture.","1366":"For example, {771/} may be mapped to your web application, {772/} is mapped to the user service and {773/} is mapped to the shop service.","1367":"{60/} is a JVM based router and server side load balancer by Netflix.","1368":"Netflix uses {60/} for the following:","1369":"Authentication","1370":"Insights","1371":"Stress Testing","1372":"Canary Testing","1373":"Dynamic Routing","1374":"Service Migration","1375":"Load Shedding","1376":"Security","1377":"Static Response handling","1378":"Active/Active traffic management","1379":"{60/}’s rule engine allows rules and filters to be written in essentially any JVM language, with built in support for Java and Groovy.","1380":"Note","1381":"\nThe configuration property {774/} has been replaced by two new properties, {775/} and {776/} which default to 200 and 20 respectively.\n","1382":"Note","1383":"Default {47/} isolation pattern (ExecutionIsolationStrategy) for all routes is SEMAPHORE.","1384":"{777/} can be changed to THREAD if this isolation pattern is preferred.","1385":"How to Include {60/}","1386":"To include {60/} in your project use the starter with group {778/} and artifact id {779/}.","1387":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","1388":"Embedded {60/} Reverse Proxy","1389":"{22/} has created an embedded {60/} proxy to ease the development of a very common use case where a UI application wants to proxy calls to one or more back end services.","1390":"This feature is useful for a user interface to proxy to the backend services it requires, avoiding the need to manage CORS and authentication concerns independently for all the backends.","1391":"To enable it, annotate a {19/} main class with {780/}, and this forwards local calls to the appropriate service.","1392":"By convention, a service with the ID \"users\", will receive requests from the proxy located at {781/} (with the prefix stripped).","1393":"The proxy uses {43/} to locate an instance to forward to via discovery, and all requests are executed in a hystrix command , so failures will show up in {47/} metrics, and once the circuit is open the proxy will not try to contact the service.","1394":"Note","1395":"\nthe {60/} starter does not include a discovery client, so for\nroutes based on service IDs you need to provide one of those\non the classpath as well (e.g. {62/} is one choice).\n","1396":"To skip having a service automatically added, set {782/} to a list of service id patterns.","1397":"If a service matches a pattern that is ignored, but also included in the explicitly configured routes map, then it will be unignored.","1398":"Example:","1399":"application.yml","1400":"In this example, all services are ignored except \"users\".","1401":"To augment or change\nthe proxy routes, you can add external configuration like the\nfollowing:","1402":"application.yml","1403":"This means that http calls to \"/myusers\" get forwarded to the \"users\"\nservice (for example \"/myusers/101\" is forwarded to \"/101\").","1404":"To get more fine-grained control over a route you can specify the path\nand the serviceId independently:","1405":"application.yml","1406":"This means that http calls to \"/myusers\" get forwarded to the \"users_service\" service.","1407":"The route has to have a \"path\" which can be specified as an ant-style pattern, so \"/myusers/*\" only matches one level, but \"/myusers/**\" matches hierarchically.","1408":"The location of the backend can be specified as either a \"serviceId\"\n(for a service from discovery) or a \"url\" (for a physical location), e.g.","1409":"application.yml","1410":"These simple url-routes don't get executed as a {783/} nor can you loadbalance multiple URLs with {43/}.","1411":"To achieve this, specify a service-route and configure a {43/} client for the serviceId (this currently requires disabling {62/} support in {43/}: see above for more information ), eg","1412":"application.yml","1413":"You can provide convention between serviceId and routes using regexmapper.","1414":"It uses regular expression named groups to extract variables from serviceId and inject them into a route pattern.","1415":"ApplicationConfiguration.java","1416":"This means that a serviceId \"myusers-v1\" will be mapped to route \"/v1/myusers/**\".","1417":"Any regular expression is accepted but all named groups must be present in both servicePattern and routePattern.","1418":"If servicePattern does not match a serviceId, the default behavior is used.","1419":"In the example above, a serviceId \"myusers\" will be mapped to route \"/myusers/**\" (no version detected) This feature is disable by default and only applies to discovered services.","1420":"To add a prefix to all mappings, set {784/} to a value, such as {785/}.","1421":"The proxy prefix is stripped from the request before the request is forwarded by default (switch this behaviour off with {786/}).","1422":"You can also switch off the stripping of the service-specific prefix from individual routes, eg","1423":"application.yml","1424":"Note","1425":"{787/} only applies to the prefix set in {788/}.","1426":"It does have any effect on prefixes defined within a given route's {789/}.","1427":"In this example, requests to \"/myusers/101\" will be forwarded to \"/myusers/101\" on the \"users\" service.","1428":"The {790/} entries actually bind to an object of type {791/}.","1429":"If you look at the properties of that object you will see that it also has a \"retryable\" flag.","1430":"Set that flag to \"true\" to have the {43/} client automatically retry failed requests (and if you need to you can modify the parameters of the retry operations using the {43/} client configuration).","1431":"The {792/} header is added to the forwarded requests by default.","1432":"To turn it off set {793/}.","1433":"The prefix path is stripped by default, and the request to the backend picks up a header \"X-Forwarded-Prefix\" (\"/myusers\" in the examples above).","1434":"An application with {794/} could act as a standalone\nserver if you set a default route (\"/\"), for example {795/} would route all traffic (i.e. \"/**\") to the \"home\" service.","1435":"If more fine-grained ignoring is needed, you can specify specific patterns to ignore.","1436":"These patterns are evaluated at the start of the route location process, which means prefixes should be included in the pattern to warrant a match.","1437":"Ignored patterns span all services and supersede any other route specification.","1438":"application.yml","1439":"This means that all calls such as \"/myusers/101\" will be forwarded to \"/101\" on the \"users\" service.","1440":"But calls including \"/admin/\" will not resolve.","1441":"Warning","1442":"If you need your routes to have their order preserved you need to use a YAML file as the ordering will be lost using a properties file.","1443":"For example:","1444":"application.yml","1445":"If you were to use a properties file, the {796/} path may end up in front of the {797/}\npath rendering the {798/} path unreachable.","1446":"{60/} Http Client","1447":"The default HTTP client used by zuul is now backed by the Apache HTTP Client instead of the deprecated {43/} {799/}.","1448":"To use {800/} or to use the {801/} set {802/} or {803/} respectively.","1449":"Cookies and Sensitive Headers","1450":"It's OK to share headers between services in the same system, but you probably don't want sensitive headers leaking downstream into external servers.","1451":"You can specify a list of ignored headers as part of the route configuration.","1452":"Cookies play a special role because they have well-defined semantics in browsers, and they are always to be treated as sensitive.","1453":"If the consumer of your proxy is a browser, then cookies for downstream services also cause problems for the user because they all get jumbled up (all downstream services look like they come from the same place).","1454":"If you are careful with the design of your services, for example if only one of the downstream services sets cookies, then you might be able to let them flow from the backend all the way up to the caller.","1455":"Also, if your proxy sets cookies and all your back end services are part of the same system, it can be natural to simply share them (and for instance use {41/} Session to link them up to some shared state).","1456":"Other than that, any cookies that get set by downstream services are likely to be not very useful to the caller, so it is recommended that you make (at least) \"Set-Cookie\" and \"Cookie\" into sensitive headers for routes that are not part of your domain.","1457":"Even for routes that are part of your domain, try to think carefully about what it means before allowing cookies to flow between them and the proxy.","1458":"The sensitive headers can be configured as a comma-separated list per\nroute, e.g.","1459":"application.yml","1460":"Note","1461":"this is the default value for {804/}, so you don't need to set it unless you want it to be different.","1462":"NB this is new in {5/} 1.1 (in 1.0 the user had no control over headers and all cookies flow in both directions).","1463":"The {805/} are a blacklist and the default is not empty, so to make {60/} send all headers (except the \"ignored\" ones) you would have to explicitly set it to the empty list.","1464":"This is necessary if you want to pass cookie or authorization headers to your back end.","1465":"Example:","1466":"application.yml","1467":"Sensitive headers can also be set globally by setting {806/}.","1468":"If {807/} is set on a route, this will override the global {808/} setting.","1469":"Ignored Headers","1470":"In addition to the per-route sensitive headers, you can set a global value for {809/} for values that should be discarded (both request and response) during interactions with downstream services.","1471":"By default these are empty, if {41/} Security is not on the classpath, and otherwise they are initialized to a set of well-known \"security\" headers (eg involving caching) as specified by {41/} Security.","1472":"The assumption in this case is that the downstream services might add these headers too, and we want the values from the proxy.","1473":"To not discard these well known security headers in case {41/} Security is on the classpath you can set {810/} to {811/}.","1474":"This can be useful if you disabled the HTTP Security response headers in {41/} Security and want the values provided by downstream services","1475":"The Routes Endpoint","1476":"If you are using {812/} with tha {19/} Actuator you will enable (by default) an additional endpoint, available via HTTP as {813/}.","1477":"A GET to this endpoint will return a list of the mapped routes.","1478":"A POST will force a refresh of the existing routes (eg in case there have been changes in the service catalog).","1479":"You can disable this endpoint by setting {814/} to {815/}.","1480":"Note","1481":"\nthe routes should respond automatically to changes in the\nservice catalog, but the POST to /routes is a way to force the change\nto happen immediately.\n","1482":"Strangulation Patterns and Local Forwards","1483":"A common pattern when migrating an existing application or API is to \"strangle\" old endpoints, slowly replacing them with different implementations.","1484":"The {60/} proxy is a useful tool for this because you can use it to handle all traffic from clients of the old endpoints, but redirect some of the requests to new ones.","1485":"Example configuration:","1486":"application.yml","1487":"In this example we are strangling the \"legacy\" app which is mapped to all requests that do not match one of the other patterns.","1488":"Paths in {816/} have been extracted into a new service with an external URL.","1489":"And paths in {817/} are forwarded so they can be handled locally, eg with a normal {41/} {818/}.","1490":"Paths in {819/} are also forwarded, but with a different prefix (ie {820/} is forwarded to {821/}).","1491":"Note","1492":"\nThe ignored patterns aren’t completely ignored, they just\naren’t handled by the proxy (so they are also effectively forwarded\nlocally).\n","1493":"Uploading Files through {60/}","1494":"If you {822/} you can use the proxy paths to upload files and it should just work as long as the files are small.","1495":"For large files there is an alternative path which bypasses the {41/} {823/} (to avoid multipart processing) in \"/zuul/*\".","1496":"Ie if {824/} then you can POST large files to \"/zuul/customers/*\".","1497":"The servlet path is externalized via {825/}.","1498":"Extremely large files will also require elevated timeout settings if the proxy route takes you through a {43/} load balancer, eg","1499":"application.yml","1500":"Note that for streaming to work with large files, you need to use chunked encoding in the request (which some browsers do not do by default).","1501":"Eg on the command line:","1502":"Query String Encoding","1503":"When processing the incoming request, query params are decoded so they can be available for possible modifications in {60/} filters.","1504":"They are then re-encoded when building the backend request in the route filters.","1505":"The result can be different than the original input if it was encoded using Javascript's {826/} method for example.","1506":"While this causes no issues in most cases, some web servers can be picky with the encoding of complex query string.","1507":"To force the original encoding of the query string, it is possible to pass a special flag to {827/} so\nthat the query string is taken as is with the {828/} method :","1508":"application.yml","1509":"Note: This special flag only works with {829/} and you loose the ability to easily override\nquery parameters with {830/} since\nthe query string is now fetched directly on the original {831/}.","1510":"Plain Embedded {60/}","1511":"You can also run a {60/} server without the proxying, or switch on parts of the proxying platform selectively, if you use {832/} (instead of {833/}).","1512":"Any beans that you add to the application of type {834/} will be installed automatically, as they are with {835/}, but without any of the proxy filters being added automatically.","1513":"In this case the routes into the {60/} server are still specified by configuring \"zuul.routes.*\", but there is no service discovery and no proxying, so the \"serviceId\" and \"url\" settings are ignored.","1514":"For example:","1515":"application.yml","1516":"maps all paths in \"/api/**\" to the {60/} filter chain.","1517":"Disable {60/} Filters","1518":"{60/} for {22/} comes with a number of {836/} beans enabled by default in both proxy and server mode.","1519":"See the zuul filters package for the possible filters that are enabled.","1520":"If you want to disable one, simply set {837/}.","1521":"By convention, the package after {838/} is the {60/} filter type.","1522":"For example to disable {839/} set {840/}.","1523":"Providing {47/} Fallbacks For Routes","1524":"When a circuit for a given route in {60/} is tripped you can provide a fallback response by creating a bean of type {841/}.","1525":"Within this bean you need to specify the route ID the fallback is for and provide a {842/} to return as a fallback.","1526":"Here is a very simple {843/} implementation.","1527":"And here is what the route configuration would look like.","1528":"If you would like to provide a default fallback for all routes than you can create a bean of\ntype {844/} and have the {845/} method return {846/} or {847/}.","1529":"{60/} Developer Guide","1530":"For a general overview of how {60/} works, please see the {60/} Wiki.","1531":"The {60/} Servlet","1532":"{60/} is implemented as a Servlet.","1533":"For the general cases, {60/} is embedded into the {41/} Dispatch mechanism.","1534":"This allows {41/} MVC to be in control of the routing.","1535":"In this case, {60/} is configured to buffer requests.","1536":"If there is a need to go through {60/} without buffering requests (eg for large file uploads), the Servlet is also installed outside of the {41/} Dispatcher.","1537":"By default, this is located at {848/}.","1538":"This path can be changed with the {849/} property.","1539":"{60/} RequestContext","1540":"To pass information between filters, {60/} uses a .","1541":"Its data is held in a {850/} specific to each request.","1542":"Information about where to route requests, errors and the actual {851/} and {852/} are stored there.","1543":"The {853/} extends {854/}, so anything can be stored in the context.","1544":"contains the keys that are used by the filters installed by {5/} (more on these later).","1545":"{855/} vs. {856/}","1546":"{5/} installs a number of filters based on which annotation was used to enable {60/}.","1547":"{857/} is a superset of {858/}.","1548":"In other words, {859/} contains all filters installed by {860/}.","1549":"The additional filters in the \"proxy\" enable routing functionality.","1550":"If you want a \"blank\" {60/}, you should use {861/}.","1551":"{862/} Filters","1552":"Creates a {863/} that loads route definitions from {19/} configuration files.","1553":"The following filters are installed (as normal {41/} Beans):","1554":"Pre filters:","1555":"{864/}: Detects if the request is through the {41/} Dispatcher.","1556":"Sets boolean with key {865/}.","1557":"{866/}: Parses form data and reencodes it for downstream requests.","1558":"{867/}: if the {868/} request parameter is set, this filter sets {869/} and {870/} to true.","1559":"Route filters:","1560":"{871/}: This filter forwards requests using the Servlet {872/}.","1561":"The forwarding location is stored in the {873/} attribute {874/}.","1562":"This is useful for forwarding to endpoints in the current application.","1563":"Post filters:","1564":"{875/}: Writes responses from proxied requests to the current response.","1565":"Error filters:","1566":"{876/}: Forwards to /error (by default) if {877/} is not null.","1567":"The default forwarding path ({878/}) can be changed by setting the {879/} property.","1568":"{880/} Filters","1569":"Creates a {881/} that loads route definitions from a {882/} (like {62/}), as well as from properties.","1570":"A route is created for each {883/} from the {884/}.","1571":"As new services are added, the routes will be refreshed.","1572":"In addition to the filters described above, the following filters are installed (as normal {41/} Beans):","1573":"Pre filters:","1574":"{885/}: This filter determines where and how to route based on the supplied {886/}.","1575":"It also sets various proxy-related headers for downstream requests.","1576":"Route filters:","1577":"{887/}: This filter uses {43/}, {47/} and pluggable HTTP clients to send requests.","1578":"Service ids are found in the {888/} attribute {889/}.","1579":"This filter can use different HTTP clients.","1580":"They are:","1581":"Apache {890/}.","1582":"This is the default client.","1583":"Squareup {891/} v3.","1584":"This is enabled by having the {892/} library on the classpath and setting {893/}.","1585":"Netflix {43/} HTTP client.","1586":"This is enabled by setting {894/}.","1587":"This client has limitations, such as it doesn't support the PATCH method, but also has built-in retry.","1588":"{895/}: This filter sends requests to predetermined URLs via an Apache HttpClient.","1589":"URLs are found in {896/}.","1590":"Custom {60/} Filter examples","1591":"Most of the following \"How to Write\" examples below are included Sample {60/} Filters project.","1592":"There are also examples of manipulating the request or response body in that repository.","1593":"How to Write a Pre Filter","1594":"Pre filters are used to set up data in the {897/} for use in filters downstream.","1595":"The main use case is to set information required for route filters.","1596":"The filter above populates {898/} from the {899/} request parameter.","1597":"In reality, it's not a good idea to do that kind of direct mapping, but the service id should be looked up from the value of {900/} instead.","1598":"Now that {901/} is populated, {902/} won't run and {903/} will.","1599":"If you wanted to route to a full URL instead, call {904/} instead.","1600":"To modify the path that routing filters will forward to, set the {905/}.","1601":"How to Write a Route Filter","1602":"Route filters are run after pre filters and are used to make requests to other services.","1603":"Much of the work here is to translate request and response data to and from the client required model.","1604":"The above filter translates Servlet request information into OkHttp3 request information, executes an HTTP request, then translates OkHttp3 reponse information to the Servlet response.","1605":"WARNING: this filter might have bugs and not function correctly.","1606":"How to Write a Post Filter","1607":"Post filters typically manipulate the response.","1608":"In the filter below, we add a random {906/} as the {907/} header.","1609":"Other manipulations, such as transforming the response body, are much more complex and compute-intensive.","1610":"How {60/} Errors Work","1611":"If an exception is thrown during any portion of the {60/} filter lifecycle, the error filters are executed.","1612":"The {908/} is only run if {909/} is not {910/}.","1613":"It then sets specific {911/} attributes in the request and forwards the request to the {19/} error page.","1614":"{60/} Eager Application Context Loading","1615":"{60/} internally uses {43/} for calling the remote url's and {43/} clients are by default lazily loaded up by {22/} on first call.","1616":"This behavior can be changed for {60/} using the following configuration and will result in the child {43/} related Application contexts being eagerly loaded up at application startup time.","1617":"application.yml","1618":"{44/} support with {51/}","1619":"Do you have non-jvm languages you want to take advantage of {62/}, {43/} and Config Server?","1620":"The {5/} {51/} was inspired by Netflix Prana .","1621":"It includes a simple http api to get all of the instances (ie host and port) for a given service.","1622":"You can also proxy service calls through an embedded {60/} proxy which gets its route entries from {62/}.","1623":"The {16/} Server can be accessed directly via host lookup or through the {60/} Proxy.","1624":"The non-jvm app should implement a health check so the {51/} can report to eureka if the app is up or down.","1625":"To include {51/} in your project use the dependency with group {912/}\nand artifact id {913/}.","1626":"To enable the {51/}, create a {19/} application with {914/}.","1627":"This annotation includes {915/}, {916/}, and {917/}.","1628":"Run the resulting application on the same host as the non-jvm application.","1629":"To configure the side car add {918/} and {919/} to {920/}.","1630":"The {921/} property is the port the non-jvm app is listening on.","1631":"This is so the {51/} can properly register the app with {62/}.","1632":"The {922/} is a uri accessible on the non-jvm app that mimicks a {19/} health indicator.","1633":"It should return a json document like the following:","1634":"health-uri-document","1635":"Here is an example application.yml for a {51/} application:","1636":"application.yml","1637":"The api for the {923/} method is {924/}.","1638":"Here is an example response for {925/} that returns two instances on different hosts.","1639":"This api is accessible to the non-jvm app (if the sidecar is on port 5678) at {926/}.","1640":"/hosts/customers","1641":"The {60/} proxy automatically adds routes for each service known in eureka to {927/}, so the customers service is available at {928/}.","1642":"The Non-jvm app can access the customer service via {929/} (assuming the sidecar is listening on port 5678).","1643":"If the Config Server is registered with {62/}, non-jvm application can access it via the {60/} proxy.","1644":"If the serviceId of the ConfigServer is {930/} and the {51/} is on port 5678, then it can be accessed at http://localhost:5678/configserver","1645":"Non-jvm app can take advantage of the Config Server's ability to return YAML documents.","1646":"For example, a call to http://sidecar.local.spring.io:5678/configserver/default-master.yml might result in a YAML document like the following","1647":"RxJava with {41/} MVC","1648":"{5/} includes RxJava.","1649":"RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.","1650":"{5/} provides support for returning {931/} objects from {41/} MVC Controllers.","1651":"It also supports using {932/} objects for Server-sent events (SSE) .","1652":"This can be very convenient if your internal APIs are already built using RxJava (see {10/} Support for examples).","1653":"Here are some examples of using {933/}:","1654":"If you have an {934/}, rather than a single, you can use {935/} or {936/}.","1655":"Here are some examples:","1656":"If you have a streaming endpoint and client, SSE could be an option.","1657":"To convert {937/} to a {41/} {938/} use {939/}.","1658":"Here are some examples:","1659":"Metrics: {42/}, {57/}, and {56/}","1660":"When used together, {42/}/{57/} and {56/} provide a near real-time operational insight platform.","1661":"{42/} and {57/} are Netflix's metrics collection libraries.","1662":"{56/} is a Netflix metrics backend to manage dimensional time series data.","1663":"{57/} served Netflix for several years and is still usable, but is gradually being phased out in favor of {42/}, which is only designed to work with Java 8. {5/} provides support for both, but Java 8 based applications are encouraged to use {42/}.","1664":"Dimensional vs. Hierarchical Metrics","1665":"{19/} Actuator metrics are hierarchical and metrics are separated only by name.","1666":"These names often follow a naming convention that embeds key/value attribute pairs (dimensions) into the name separated by periods.","1667":"Consider the following metrics for two endpoints, root and star-star:","1668":"The first metric gives us a normalized count of successful requests against the root endpoint per unit of time.","1669":"But what if the system had 20 endpoints and you want to get a count of successful requests against all the endpoints?","1670":"Some hierarchical metrics backends would allow you to specify a wild card such as {940/} that would read all 20 metrics and aggregate the results.","1671":"Alternatively, you could provide a {941/} that intercepts and records a metric like {942/} for all successful requests irrespective of the endpoint, but now you must write 20+1 different metrics.","1672":"Similarly if you want to know the total number of successful requests for all endpoints in the service, you could specify a wild card such as {943/} {944/}.","1673":"Even in the presence of wildcarding support on a hierarchical metrics backend, naming consistency can be difficult.","1674":"Specifically the position of these tags in the name string can slip with time, breaking queries.","1675":"For example, suppose we add an additional dimension to the hierarchical metrics above for HTTP method.","1676":"Then {945/} becomes {946/}, etc. Our {947/} suddenly no longer has the same semantic meaning.","1677":"Furthermore, if the new dimension is not applied uniformly across the codebase, certain queries may become impossible.","1678":"This can quickly get out of hand.","1679":"Netflix metrics are tagged (aka dimensional).","1680":"Each metric has a name, but this single named metric can contain multiple statistics and 'tag' key/value pairs that allows more querying flexibility.","1681":"In fact, the statistics themselves are recorded in a special tag.","1682":"Recorded with Netflix {57/} or {42/}, a timer for the root endpoint described above contains 4 statistics per status code, where the count statistic is identical to {19/} Actuator's counter.","1683":"In the event that we have encountered an HTTP 200 and 400 thus far, there will be 8 available data points:","1684":"Default Metrics Collection","1685":"Without any additional dependencies or configuration, a {22/} based service will autoconfigure a {57/} {948/} and begin collecting metrics on every {41/} MVC request.","1686":"By default, a {57/} timer with the name {949/} will be recorded for each MVC request which is tagged with:","1687":"HTTP method","1688":"HTTP status (e.g. 200, 400, 500)","1689":"URI (or \"root\" if the URI is empty), sanitized for {56/}","1690":"The exception class name, if the request handler threw an exception","1691":"The caller, if a request header with a key matching {950/} is set on the request.","1692":"There is no default key for {951/}.","1693":"You must add it to your application properties if you wish to collect caller information.","1694":"Set the {952/} property to change the name of the metric from {953/} to a name you provide.","1695":"If {41/} AOP is enabled and {954/} is present on your runtime classpath, {22/} will also collect metrics on every client call made with {955/}.","1696":"A {57/} timer with the name of {956/} will be recorded for each MVC request which is tagged with:","1697":"HTTP method","1698":"HTTP status (e.g. 200, 400, 500), \"CLIENT_ERROR\" if the response returned null, or \"IO_ERROR\" if an {957/} occurred during the execution of the {958/} method","1699":"URI, sanitized for {56/}","1700":"Client name","1701":"Warning","1702":"Avoid using hardcoded url parameters within {959/}.","1703":"When targeting dynamic endpoints use URL variables.","1704":"This will avoid potential \"GC Overhead Limit Reached\" issues where {960/} treats each url as a unique key.","1705":"Metrics Collection: {42/}","1706":"To enable {42/} metrics, include a dependency on {961/}:","1707":"In {42/} parlance, a meter is a named, typed, and tagged configuration and a metric represents the value of a given meter at a point in time.","1708":"{42/} meters are created and controlled by a registry, which currently has several different implementations.","1709":"{42/} provides 4 meter types: counter, timer, gauge, and distribution summary.","1710":"{22/} {42/} integration configures an injectable {962/} instance for you.","1711":"Specifically, it configures a {963/} instance in order to unify the collection of REST metrics and the exporting of metrics to the {56/} backend under a single {57/} API.","1712":"Practically, this means that your code may use a mixture of {57/} monitors and {42/} meters and both will be scooped up by {19/} Actuator {964/} instances and both will be shipped to the {56/} backend.","1713":"{42/} Counter","1714":"A counter is used to measure the rate at which some event is occurring.","1715":"The counter records a single time-normalized statistic.","1716":"{42/} Timer","1717":"A timer is used to measure how long some event is taking.","1718":"{22/} automatically records timers for {41/} MVC requests and conditionally {965/} requests, which can later be used to create dashboards for request related metrics like latency:","1719":"Figure 4. Request Latency","1720":"The timer simultaneously records 4 statistics: count, max, totalOfSquares, and totalTime.","1721":"The count statistic will always match the single normalized value provided by a counter if you had called {966/} once on the counter for each time you recorded a timing, so it is rarely necessary to count and time separately for a single operation.","1722":"For long running operations, {42/} provides a special {967/}.","1723":"{42/} Gauge","1724":"Gauges are used to determine some current value like the size of a queue or number of threads in a running state.","1725":"Since gauges are sampled, they provide no information about how these values fluctuate between samples.","1726":"The normal use of a gauge involves registering the gauge once in initialization with an id, a reference to the object to be sampled, and a function to get or compute a numeric value based on the object.","1727":"The reference to the object is passed in separately and the {42/} registry will keep a weak reference to the object.","1728":"If the object is garbage collected, then {42/} will automatically drop the registration.","1729":"See the note in {42/}'s documentation about potential memory leaks if this API is misused.","1730":"{42/} Distribution Summaries","1731":"A distribution summary is used to track the distribution of events.","1732":"It is similar to a timer, but more general in that the size does not have to be a period of time.","1733":"For example, a distribution summary could be used to measure the payload sizes of requests hitting a server.","1734":"Metrics Collection: {57/}","1735":"Warning","1736":"\nIf your code is compiled on Java 8, please use {42/} instead of {57/} as {42/} is destined to replace {57/} entirely in the long term.\n","1737":"In {57/} parlance, a monitor is a named, typed, and tagged configuration and a metric represents the value of a given monitor at a point in time.","1738":"{57/} monitors are logically equivalent to {42/} meters.","1739":"{57/} monitors are created and controlled by a {968/}.","1740":"In spite of the above warning, {57/} does have a wider array of monitor options than {42/} has meters.","1741":"{22/} integration configures an injectable {969/} instance for you.","1742":"Once you have created the appropriate {970/} type in {57/}, the process of recording data is wholly similar to {42/}.","1743":"Creating {57/} Monitors","1744":"If you are using the {57/} {971/} instance provided by {22/} (specifically, an instance of {972/}), {57/} provides convenience classes for retrieving counters and timers .","1745":"These convenience classes ensure that only one {973/} is registered for each unique combination of name and tags.","1746":"To manually create a Monitor type in {57/}, especially for the more exotic monitor types for which convenience methods are not provided, instantiate the appropriate type by providing a {974/} instance:","1747":"Metrics Backend: {56/}","1748":"{56/} was developed by Netflix to manage dimensional time series data for near real-time operational insight.","1749":"{56/} features in-memory data storage, allowing it to gather and report very large numbers of metrics, very quickly.","1750":"{56/} captures operational intelligence.","1751":"Whereas business intelligence is data gathered for analyzing trends over time, operational intelligence provides a picture of what is currently happening within a system.","1752":"{22/} provides a {975/} that has all the dependencies you need.","1753":"Then just annotate your {19/} application with {976/} and provide a location for your running {56/} server with the {977/} property.","1754":"Global tags","1755":"{22/} enables you to add tags to every metric sent to the {56/} backend.","1756":"Global tags can be used to separate metrics by application name, environment, region, etc.","1757":"Each bean implementing {978/} will contribute to the global tag list:","1758":"Using {56/}","1759":"To bootstrap a in-memory standalone {56/} instance:","1760":"Tip","1761":"\nAn {56/} standalone node running on an r3.2xlarge (61GB RAM) can handle roughly 2 million metrics per minute for a given 6 hour window.\n","1762":"Once running and you have collected a handful of metrics, verify that your setup is correct by listing tags on the {56/} server:","1763":"Tip","1764":"\nAfter executing several requests against your service, you can gather some very basic information on the request latency of every request by pasting the following url in your browser: {979/}\n","1765":"The {56/} wiki contains a compilation of sample queries for various scenarios.","1766":"Make sure to check out the alerting philosophy and docs on using double exponential smoothing to generate dynamic alert thresholds.","1767":"Retrying Failed Requests","1768":"{5/} offers a variety of ways to make HTTP requests.","1769":"You can use a load balanced {980/}, {43/}, or {55/}.","1770":"No matter how you choose to your HTTP requests, there is always a chance the request may fail.","1771":"When a request fails you may want to have the request retried automatically.","1772":"To accomplish this when using Sping Cloud Netflix you need to include {41/} Retry on your application's classpath.","1773":"When {41/} Retry is present load balanced {981/}, {55/}, and {60/} will automatically retry any failed requests (assuming you configuration allows it to).","1774":"Configuration","1775":"Anytime {43/} is used with {41/} Retry you can control the retry functionality by configuring certain {43/} properties.","1776":"The properties you can use are {982/}, {983/}, and {984/}.","1777":"See the {43/} documentation for a description of what there properties do.","1778":"In addition you may want to retry requests when certain status codes are returned in the response.","1779":"You can list the response codes you would like the {43/} client to retry using the property {985/}.","1780":"For example","1781":"You can also create a bean of type {986/} and implement the {987/}\nmethod to determine whether you want to retry a request given the status code.","1783":"You can turn off {60/}'s retry functionality by setting {988/} to {989/}.","1784":"You can also disable retry functionality on route by route basis by setting {990/} to {991/}.","1785":"{22/} Stream","1786":"This section goes into more detail about how you can work with {22/} Stream.","1787":"It covers topics such as creating and running stream applications.","1788":"Introducing {22/} Stream","1789":"{22/} Stream is a framework for building message-driven microservice applications.","1790":"{22/} Stream builds upon {19/} to create standalone, production-grade {41/} applications, and uses {20/} to provide connectivity to message brokers.","1791":"It provides opinionated configuration of middleware from several vendors, introducing the concepts of persistent publish-subscribe semantics, consumer groups, and partitions.","1792":"You can add the {992/} annotation to your application to get immediate connectivity to a message broker, and you can add {993/} to a method to cause it to receive events for stream processing.","1793":"The following is a simple sink application which receives external messages.","1794":"The {994/} annotation takes one or more interfaces as parameters (in this case, the parameter is a single {995/} interface).","1795":"An interface declares input and/or output channels.","1796":"{22/} Stream provides the interfaces {996/}, {997/}, and {998/};","1797":"you can also define your own interfaces.","1798":"The following is the definition of the {999/} interface:","1799":"The {1000/} annotation identifies an input channel , through which received messages enter the application;","1800":"the {1001/} annotation identifies an output channel , through which published messages leave the application.","1801":"The {1002/} and {1003/} annotations can take a channel name as a parameter;","1802":"if a name is not provided, the name of the annotated method will be used.","1803":"{22/} Stream will create an implementation of the interface for you.","1804":"You can use this in the application by autowiring it, as in the following example of a test case.","1805":"Main Concepts","1806":"{22/} Stream provides a number of abstractions and primitives that simplify the writing of message-driven microservice applications.","1807":"This section gives an overview of the following:","1808":"{22/} Stream’s application model","1809":"The {48/} abstraction","1810":"Persistent publish-subscribe support","1811":"Consumer group support","1812":"Partitioning support","1813":"A pluggable {48/} API","1814":"Application Model","1815":"A {22/} Stream application consists of a middleware-neutral core.","1816":"The application communicates with the outside world through input and output channels injected into it by {22/} Stream.","1817":"Channels are connected to external brokers through middleware-specific {48/} implementations.","1818":"Figure 5. {22/} Stream Application","1819":"Fat JAR","1820":"{22/} Stream applications can be run in standalone mode from your IDE for testing.","1821":"To run a {22/} Stream application in production, you can create an executable (or \"fat\") JAR by using the standard {19/} tooling provided for Maven or Gradle.","1822":"The {48/} Abstraction","1823":"{22/} Stream provides {48/} implementations for {58/} and Rabbit MQ .","1824":"{22/} Stream also includes a TestSupportBinder , which leaves a channel unmodified so that tests can interact with channels directly and reliably assert on what is received.","1825":"You can use the extensible API to write your own {48/}.","1826":"{22/} Stream uses {19/} for configuration, and the {48/} abstraction makes it possible for a {22/} Stream application to be flexible in how it connects to middleware.","1827":"For example, deployers can dynamically choose, at runtime, the destinations (eg, the {58/} topics or {45/} exchanges) to which channels connect.","1828":"Such configuration can be provided through external configuration properties and in any form supported by {19/} (including application arguments, environment variables, and {1004/} or {1005/} files).","1829":"In the sink example from the Introducing {22/} Stream section, setting the application property {1006/} to {1007/} will cause it to read from the {1008/} {58/} topic, or from a queue bound to the {1009/} {45/} exchange.","1830":"{22/} Stream automatically detects and uses a binder found on the classpath.","1831":"You can easily use different types of middleware with the same code: just include a different binder at build time.","1832":"For more complex use cases, you can also package multiple binders with your application and have it choose the binder, and even whether to use different binders for different channels, at runtime.","1833":"Persistent Publish-Subscribe Support","1834":"Communication between applications follows a publish-subscribe model, where data is broadcast through shared topics.","1835":"This can be seen in the following figure, which shows a typical deployment for a set of interacting {22/} Stream applications.","1836":"Figure 6. {22/} Stream Publish-Subscribe","1837":"Data reported by sensors to an HTTP endpoint is sent to a common destination named {1010/}.","1838":"From the destination, it is independently processed by a microservice application that computes time-windowed averages and by another microservice application that ingests the raw data into HDFS.","1839":"In order to process the data, both applications declare the topic as their input at runtime.","1840":"The publish-subscribe communication model reduces the complexity of both the producer and the consumer, and allows new applications to be added to the topology without disruption of the existing flow.","1841":"For example, downstream from the average-calculating application, you can add an application that calculates the highest temperature values for display and monitoring.","1842":"You can then add another application that interprets the same flow of averages for fault detection.","1843":"Doing all communication through shared topics rather than point-to-point queues reduces coupling between microservices.","1844":"While the concept of publish-subscribe messaging is not new, {22/} Stream takes the extra step of making it an opinionated choice for its application model.","1845":"By using native middleware support, {22/} Stream also simplifies use of the publish-subscribe model across different platforms.","1846":"Consumer Groups","1847":"While the publish-subscribe model makes it easy to connect applications through shared topics, the ability to scale up by creating multiple instances of a given application is equally important.","1848":"When doing this, different instances of an application are placed in a competing consumer relationship, where only one of the instances is expected to handle a given message.","1849":"{22/} Stream models this behavior through the concept of a consumer group .","1850":"({22/} Stream consumer groups are similar to and inspired by {58/} consumer groups.) Each consumer binding can use the {1011/} property to specify a group name.","1851":"For the consumers shown in the following figure, this property would be set as {1012/} or {1013/}.","1852":"Figure 7. {22/} Stream Consumer Groups","1853":"All groups which subscribe to a given destination receive a copy of published data, but only one member of each group receives a given message from that destination.","1854":"By default, when a group is not specified, {22/} Stream assigns the application to an anonymous and independent single-member consumer group that is in a publish-subscribe relationship with all other consumer groups.","1855":"Durability","1856":"Consistent with the opinionated application model of {22/} Stream, consumer group subscriptions are durable .","1857":"That is, a binder implementation ensures that group subscriptions are persistent, and once at least one subscription for a group has been created, the group will receive messages, even if they are sent while all applications in the group are stopped.","1858":"Note","1859":"Anonymous subscriptions are non-durable by nature.","1860":"For some binder implementations (eg, {45/}), it is possible to have non-durable group subscriptions.","1861":"In general, it is preferable to always specify a consumer group when binding an application to a given destination.","1862":"When scaling up a {22/} Stream application, you must specify a consumer group for each of its input bindings.","1863":"This prevents the application's instances from receiving duplicate messages (unless that behavior is desired, which is unusual).","1864":"Partitioning Support","1865":"{22/} Stream provides support for partitioning data between multiple instances of a given application.","1866":"In a partitioned scenario, the physical communication medium (eg, the broker topic) is viewed as being structured into multiple partitions.","1867":"One or more producer application instances send data to multiple consumer application instances and ensure that data identified by common characteristics are processed by the same consumer instance.","1868":"{22/} Stream provides a common abstraction for implementing partitioned processing use cases in a uniform fashion.","1869":"Partitioning can thus be used whether the broker itself is naturally partitioned (eg, {58/}) or not (eg, {45/}).","1870":"Figure 8. {22/} Stream Partitioning","1871":"Partitioning is a critical concept in stateful processing, where it is critiical, for either performance or consistency reasons, to ensure that all related data is processed together.","1872":"For example, in the time-windowed average calculation example, it is important that all measurements from any given sensor are processed by the same application instance.","1873":"Note","1874":"To set up a partitioned processing scenario, you must configure both the data-producing and the data-consuming ends.","1875":"Programming Model","1876":"This section describes {22/} Stream's programming model.","1877":"{22/} Stream provides a number of predefined annotations for declaring bound input and output channels as well as how to listen to channels.","1878":"Declaring and Binding Channels","1879":"Triggering Binding Via {1014/}","1880":"You can turn a {41/} application into a {22/} Stream application by applying the {1015/} annotation to one of the application's configuration classes.","1881":"The {1016/} annotation itself is meta-annotated with {1017/} and triggers the configuration of {22/} Stream infrastructure:","1882":"The {1018/} annotation can take as parameters one or more interface classes that contain methods which represent bindable components (typically message channels).","1883":"Note","1884":"In {22/} Stream 1.0, the only supported bindable components are the {41/} Messaging {1019/} and its extensions {1020/} and {1021/}.","1885":"Future versions should extend this support to other types of components, using the same mechanism.","1886":"In this documentation, we will continue to refer to channels.","1887":"{1022/} and {1023/}","1888":"A {22/} Stream application can have an arbitrary number of input and output channels defined in an interface as {1024/} and {1025/} methods:","1889":"Using this interface as a parameter to {1026/} will trigger the creation of three bound channels named {1027/}, {1028/}, and {1029/}, respectively.","1890":"Customizing Channel Names","1891":"Using the {1030/} and {1031/} annotations, you can specify a customized channel name for the channel, as shown in the following example:","1892":"In this example, the created bound channel will be named {1032/}.","1893":"{1033/}, {1034/}, and {1035/}","1894":"For easy addressing of the most common use cases, which involve either an input channel, an output channel, or both, {22/} Stream provides three predefined interfaces out of the box.","1895":"{1036/} can be used for an application which has a single outbound channel.","1896":"{1037/} can be used for an application which has a single inbound channel.","1897":"{1038/} can be used for an application which has both an inbound channel and an outbound channel.","1898":"{22/} Stream provides no special handling for any of these interfaces;","1899":"they are only provided out of the box.","1900":"Accessing Bound Channels","1901":"Injecting the Bound Interfaces","1902":"For each bound interface, {22/} Stream will generate a bean that implements the interface.","1903":"Invoking a {1039/}-annotated or {1040/}-annotated method of one of these beans will return the relevant bound channel.","1904":"The bean in the following example sends a message on the output channel when its {1041/} method is invoked.","1905":"It invokes {1042/} on the injected {1043/} bean to retrieve the target channel.","1906":"Injecting Channels Directly","1907":"Bound channels can be also injected directly:","1908":"If the name of the channel is customized on the declaring annotation, that name should be used instead of the method name.","1909":"Given the following declaration:","1910":"The channel will be injected as shown in the following example:","1911":"Producing and Consuming Messages","1912":"You can write a {22/} Stream application using either {20/} annotations or {22/} Stream's {1044/} annotation.","1913":"The {1045/} annotation is modeled after other {41/} Messaging annotations (such as {1046/}, {1047/}, {1048/}, etc.) but adds content type management and type coercion features.","1914":"Native {20/} Support","1915":"Because {22/} Stream is based on {20/}, Stream completely inherits Integration's foundation and infrastructure as well as the component itself.","1916":"For example, you can attach the output channel of a {1049/} to a {1050/}:","1917":"Or you can use a processor’s channels in a transformer:","1918":"{20/} Error Channel Support","1919":"{22/} Stream supports publishing error messages received by the {20/} global error channel.","1920":"Error messages sent to the {1051/} can be published to a specific destination at the broker by configuring a binding for the outbound target named {1052/}.","1921":"For example, to publish error messages to a broker destination named \"myErrors\", provide the following property: {1053/}","1922":"Using @StreamListener for Automatic Content Type Handling","1923":"Complementary to its {20/} support, {22/} Stream provides its own {1054/} annotation, modeled after other {41/} Messaging annotations (eg {1055/}, {1056/}, {1057/}, etc.).","1924":"The {1058/} annotation provides a simpler model for handling inbound messages, especially when dealing with use cases that involve content type management and type coercion.","1925":"{22/} Stream provides an extensible {1059/} mechanism for handling data conversion by bound channels and for, in this case, dispatching to methods annotated with {1060/}.","1926":"The following is an example of an application which processes external {1061/} events:","1927":"The distinction between {1062/} and a {20/} {1063/} is seen when considering an inbound {1064/} that has a {1065/} payload and a {1066/} header of {1067/}.","1928":"In the case of {1068/}, the {1069/} mechanism will use the {1070/} header to parse the {1071/} payload into a {1072/} object.","1929":"As with other {41/} Messaging methods, method arguments can be annotated with {1073/}, {1074/} and {1075/}.","1930":"Note","1931":"For methods which return data, you must use the {1076/} annotation to specify the output binding destination for data returned by the method:","1932":"Using @StreamListener for dispatching messages to multiple methods","1933":"Since version 1.2, {22/} Stream supports dispatching messages to multiple {1077/} methods registered on an input channel, based on a condition.","1934":"In order to be eligible to support conditional dispatching, a method must satisfy the follow conditions:","1935":"it must not return a value","1936":"it must be an individual message handling method (reactive API methods are not supported)","1937":"The condition is specified via a SpEL expression in the {1078/} attribute of the annotation and is evaluated for each message.","1938":"All the handlers that match the condition will be invoked in the same thread and no assumption must be made about the order in which the invocations take place.","1939":"An example of using {1079/} with dispatching conditions can be seen below.","1940":"In this example, all the messages bearing a header {1080/} with the value {1081/} will be dispatched to the {1082/} method, and all the messages bearing a header {1083/} with the value {1084/} will be dispatched to the {1085/} method.","1941":"Note","1942":"Dispatching via {1086/} conditions is only supported for handlers of individual messages, and not for reactive programming support (described below).","1943":"Reactive Programming Support","1944":"{22/} Stream also supports the use of reactive APIs where incoming and outgoing data is handled as continuous data flows.","1945":"Support for reactive APIs is available via the {1087/}, which needs to be added explicitly to your project.","1946":"The programming model with reactive APIs is declarative, where instead of specifying how each individual message should be handled, you can use operators that describe functional transformations from inbound to outbound data flows.","1947":"{22/} Stream supports the following reactive APIs:","1948":"Reactor","1949":"RxJava 1.x","1950":"In the future, it is intended to support a more generic model based on Reactive Streams.","1951":"The reactive programming model is also using the {1088/} annotation for setting up reactive handlers.","1952":"The differences are that:","1953":"the {1089/} annotation must not specify an input or output, as they are provided as arguments and return values from the method;","1954":"the arguments of the method must be annotated with {1090/} and {1091/} indicating which input or output will the incoming and respectively outgoing data flows connect to;","1955":"the return value of the method, if any, will be annotated with {1092/}, indicating the input where data shall be sent.","1956":"Note","1957":"Reactive programming support requires Java 1.8.","1958":"Note","1959":"As of {22/} Stream 1.1.1 and later (starting with release train Brooklyn.SR2), reactive programming support requires the use of Reactor 3.0.4.RELEASE and higher.","1960":"Earlier Reactor versions (including 3.0.1.RELEASE, 3.0.2.RELEASE and 3.0.3.RELEASE) are not supported.","1961":"{1093/} will transitively retrieve the proper version, but it is possible for the project structure to manage the version of the {1094/} to an earlier release, especially when using Maven.","1962":"This is the case for projects generated via {41/} Initializr with {19/} 1.x, which will override the Reactor version to {1095/}.","1963":"In such cases you must ensure that the proper version of the artifact is released.","1964":"This can be simply achieved by adding a direct dependency on {1096/} with a version of {1097/} or later to your project.","1965":"Note","1966":"The use of term {1098/} is currently referring to the reactive APIs being used and not to the execution model being reactive (ie the bound endpoints are still using a 'push' rather than 'pull' model).","1967":"While some backpressure support is provided by the use of Reactor, we do intend on the long run to support entirely reactive pipelines by the use of native reactive clients for the connected middleware.","1968":"Reactor-based handlers","1969":"A Reactor based handler can have the following argument types:","1970":"For arguments annotated with {1099/}, it supports the Reactor type {1100/}.","1971":"The parameterization of the inbound Flux follows the same rules as in the case of individual message handling: it can be the entire {1101/}, a POJO which can be the {1102/} payload, or a POJO which is the result of a transformation based on the {1103/} content-type header.","1972":"Multiple inputs are provided;","1973":"For arguments annotated with {1104/}, it supports the type {1105/} which connects a {1106/} produced by the method with an output.","1974":"Generally speaking, specifying outputs as arguments is only recommended when the method can have multiple outputs;","1975":"A Reactor based handler supports a return type of {1107/}, case in which it must be annotated with {1108/}.","1976":"We recommend using the return value of the method when a single output flux is available.","1977":"Here is an example of a simple Reactor-based Processor.","1978":"The same processor using output arguments looks like this:","1979":"RxJava 1.x support","1980":"RxJava 1.x handlers follow the same rules as Reactor-based one, but will use {1109/} and {1110/} arguments and return types.","1981":"So the first example above will become:","1982":"The second example above will become:","1983":"Aggregation","1984":"{22/} Stream provides support for aggregating multiple applications together, connecting their input and output channels directly and avoiding the additional cost of exchanging messages via a broker.","1985":"As of version 1.0 of {22/} Stream, aggregation is supported only for the following types of applications:","1986":"sources - applications with a single output channel named {1111/}, typically having a single binding of the type {1112/}","1987":"sinks - applications with a single input channel named {1113/}, typically having a single binding of the type {1114/}","1988":"processors - applications with a single input channel named {1115/} and a single output channel named {1116/}, typically having a single binding of the type {1117/}.","1989":"They can be aggregated together by creating a sequence of interconnected applications, in which the output channel of an element in the sequence is connected to the input channel of the next element, if it exists.","1990":"A sequence can start with either a source or a processor , it can contain an arbitrary number of processors and must end with either a processor or a sink .","1991":"Depending on the nature of the starting and ending element, the sequence may have one or more bindable channels, as follows:","1992":"if the sequence starts with a source and ends with a sink, all communication between the applications is direct and no channels will be bound","1993":"if the sequence starts with a processor, then its input channel will become the {1118/} channel of the aggregate and will be bound accordingly","1994":"if the sequence ends with a processor, then its output channel will become the {1119/} channel of the aggregate and will be bound accordingly","1995":"Aggregation is performed using the {1120/} utility class, as in the following example.","1996":"Let's consider a project in which we have source, processor and a sink, which may be defined in the project, or may be contained in one of the project's dependencies.","1997":"Note","1998":"Each component (source, sink or processor) in an aggregate application must be provided in a separate package if the configuration classes use {1121/}.","1999":"This is required to avoid cross-talk between applications, due to the classpath scanning performed by {1122/} on the configuration classes inside the same package.","2000":"In the example below, it can be seen that the Source, Processor and Sink application classes are grouped in separate packages.","2001":"A possible alternative is to provide the source, sink or processor configuration in a separate {1123/} class, avoid the use of {1124/}/{1125/} and use those for aggregation.","2002":"Each configuration can be used for running a separate component, but in this case they can be aggregated together as follows:","2003":"The starting component of the sequence is provided as argument to the {1126/} method.","2004":"The ending component of the sequence is provided as argument to the {1127/} method.","2005":"Intermediate processors are provided as argument to the {1128/} method.","2006":"Multiple processors of the same type can be chained together (eg for pipelining transformations with different configurations).","2007":"For each component, the builder can provide runtime arguments for {19/} configuration.","2008":"Configuring aggregate application","2009":"{22/} Stream supports passing properties for the individual applications inside the aggregate application using 'namespace' as prefix.","2010":"The namespace can be set for applications as follows:","2011":"Once the 'namespace' is set for the individual applications, the application properties with the {1129/} as prefix can be passed to the aggregate application using any supported property source (commandline, environment properties etc.,)","2012":"For instance, to override the default {1130/} and {1131/} properties of 'source' and 'sink' applications:","2013":"Configuring binding service properties for non self contained aggregate application","2014":"The non self-contained aggregate application is bound to external broker via either or both the inbound/outbound components (typically, message channels) of the aggregate application while the applications inside the aggregate application are directly bound.","2015":"For example: a source application's output and a processor application's input are directly bound while the processor's output channel is bound to an external destination at the broker.","2016":"When passing the binding service properties for non-self contained aggregate application, it is required to pass the binding service properties to the aggregate application instead of setting them as 'args' to individual child application.","2017":"For instance,","2018":"The binding properties like {1132/} need to be specified as one of the external configuration properties (cmdline arg etc.,).","2020":"{22/} Stream provides a {48/} abstraction for use in connecting to physical destinations at the external middleware.","2021":"This section provides information about the main concepts behind the {32/}, its main components, and implementation-specific details.","2022":"Producers and Consumers","2023":"Figure 9. Producers and Consumers","2024":"A producer is any component that sends messages to a channel.","2025":"The channel can be bound to an external message broker via a {48/} implementation for that broker.","2026":"When invoking the {1133/} method, the first parameter is the name of the destination within the broker, the second parameter is the local channel instance to which the producer will send messages, and the third parameter contains properties (such as a partition key expression) to be used within the adapter that is created for that channel.","2027":"A consumer is any component that receives messages from a channel.","2028":"As with a producer, the consumer's channel can be bound to an external message broker.","2029":"When invoking the {1134/} method, the first parameter is the destination name, and a second parameter provides the name of a logical group of consumers.","2030":"Each group that is represented by consumer bindings for a given destination receives a copy of each message that a producer sends to that destination (ie, publish-subscribe semantics).","2031":"If there are multiple consumer instances bound using the same group name, then messages will be load-balanced across those consumer instances so that each message sent by a producer is consumed by only a single consumer instance within each group (ie, queueing semantics).","2033":"The {32/} consists of a number of interfaces, out-of-the box utility classes and discovery strategies that provide a pluggable mechanism for connecting to external middleware.","2034":"The key point of the SPI is the {1135/} interface which is a strategy for connecting inputs and outputs to external middleware.","2035":"The interface is parameterized, offering a number of extension points:","2036":"input and output bind targets - as of version 1.0, only {1136/} is supported, but this is intended to be used as an extension point in the future;","2037":"extended consumer and producer properties - allowing specific {48/} implementations to add supplemental properties which can be supported in a type-safe manner.","2038":"A typical binder implementation consists of the following","2039":"a class that implements the {1137/} interface;","2040":"a {41/} {1138/} class that creates a bean of the type above along with the middleware connection infrastructure;","2041":"a {1139/} file found on the classpath containing one or more binder definitions, e.g.","2042":"{48/} Detection","2043":"{22/} Stream relies on implementations of the {32/} to perform the task of connecting channels to message brokers.","2044":"Each {48/} implementation typically connects to one type of messaging system.","2045":"Classpath Detection","2046":"By default, {22/} Stream relies on {19/}'s auto-configuration to configure the binding process.","2047":"If a single {48/} implementation is found on the classpath, {22/} Stream will use it automatically.","2048":"For example, a {22/} Stream project that aims to bind only to {45/} can simply add the following dependency:","2049":"For the specific maven coordinates of other binder dependencies, please refer to the documentation of that binder implementation.","2050":"Multiple {35/} on the Classpath","2051":"When multiple binders are present on the classpath, the application must indicate which binder is to be used for each channel binding.","2052":"Each binder configuration contains a {1140/}, which is a simple properties file:","2053":"Similar files exist for the other provided binder implementations (eg, {58/}), and custom binder implementations are expected to provide them, as well.","2054":"The key represents an identifying name for the binder implementation, whereas the value is a comma-separated list of configuration classes that each contain one and only one bean definition of type {1141/}.","2055":"{48/} selection can either be performed globally, using the {1142/} property (eg, {1143/}) or individually, by configuring the binder on each channel binding.","2056":"For instance, a processor application (that has channels with the names {1144/} and {1145/} for read/write respectively) which reads from {58/} and writes to {45/} can specify the following configuration:","2057":"Connecting to Multiple Systems","2058":"By default, binders share the application's {19/} auto-configuration, so that one instance of each binder found on the classpath will be created.","2059":"If your application should connect to more than one broker of the same type, you can specify multiple binder configurations, each with different environment settings.","2060":"Note","2061":"Turning on explicit binder configuration will disable the default binder configuration process altogether.","2062":"If you do this, all binders in use must be included in the configuration.","2063":"Frameworks that intend to use {22/} Stream transparently may create binder configurations that can be referenced by name, but will not affect the default binder configuration.","2064":"In order to do so, a binder configuration may have its {1146/} flag set to false, eg {1147/}.","2065":"This denotes a configuration that will exist independently of the default binder configuration process.","2066":"For example, this is the typical configuration for a processor application which connects to two {45/} broker instances:","2067":"{48/} configuration properties","2068":"The following properties are available when creating custom binder configurations.","2069":"They must be prefixed with {1148/}.","2070":"type","2071":"The binder type.","2072":"It typically references one of the binders found on the classpath, in particular a key in a {1149/} file.","2073":"By default, it has the same value as the configuration name.","2074":"inheritEnvironment","2075":"Whether the configuration will inherit the environment of the application itself.","2076":"Default {1150/}.","2077":"environment","2078":"Root for a set of properties that can be used to customize the environment of the binder.","2079":"When this is configured, the context in which the binder is being created is not a child of the application context.","2080":"This allows for complete separation between the binder components and the application components.","2081":"Default {1151/}.","2082":"defaultCandidate","2083":"Whether the binder configuration is a candidate for being considered a default binder, or can be used only when explicitly referenced.","2084":"This allows adding binder configurations without interfering with the default processing.","2085":"Default {1152/}.","2086":"Configuration Options","2087":"{22/} Stream supports general configuration options as well as configuration for bindings and binders.","2088":"Some binders allow additional binding properties to support middleware-specific features.","2089":"Configuration options can be provided to {22/} Stream applications via any mechanism supported by {19/}.","2090":"This includes application arguments, environment variables, and YAML or .properties files.","2091":"{22/} Stream {31/}","2092":"spring.cloud.stream.instanceCount","2093":"The number of deployed instances of an application.","2094":"Must be set for partitioning and if using {58/}.","2095":"Default: {1153/}.","2096":"spring.cloud.stream.instanceIndex","2097":"The instance index of the application: a number from {1154/} to {1155/}-1.","2098":"Used for partitioning and with {58/}.","2099":"Automatically set in Cloud Foundry to match the application's instance index.","2100":"spring.cloud.stream.dynamicDestinations","2101":"A list of destinations that can be bound dynamically (for example, in a dynamic routing scenario).","2102":"If set, only listed destinations can be bound.","2103":"Default: empty (allowing any destination to be bound).","2104":"spring.cloud.stream.defaultBinder","2105":"The default binder to use, if multiple binders are configured.","2106":"See Multiple {35/} on the Classpath .","2107":"Default: empty.","2108":"spring.cloud.stream.overrideCloudConnectors","2109":"This property is only applicable when the {1156/} profile is active and {22/} Connectors are provided with the application.","2110":"If the property is false (the default), the binder will detect a suitable bound service (eg a {45/} service bound in Cloud Foundry for the {45/} binder) and will use it for creating connections (usually via {22/} Connectors).","2111":"When set to true, this property instructs binders to completely ignore the bound services and rely on {19/} properties (eg relying on the {1157/} properties provided in the environment for the {45/} binder).","2112":"The typical usage of this property is to be nested in a customized environment when connecting to multiple systems .","2113":"Default: false.","2114":"Binding {31/}","2115":"Binding properties are supplied using the format {1158/}.","2116":"The {1159/} represents the name of the channel being configured (eg, {1160/} for a {1161/}).","2117":"To avoid repetition, {22/} Stream supports setting values for all channels, in the format {1162/}.","2118":"In what follows, we indicate where we have omitted the {1163/} prefix and focus just on the property name, with the understanding that the prefix will be included at runtime.","2119":"{31/} for Use of {22/} Stream","2120":"The following binding properties are available for both input and output bindings and must be prefixed with {1164/}, e.g. {1165/}.","2121":"Default values can be set by using the prefix {1166/}, e.g. {1167/}.","2122":"destination","2123":"The target destination of a channel on the bound middleware (eg, the {45/} exchange or {58/} topic).","2124":"If the channel is bound as a consumer, it could be bound to multiple destinations and the destination names can be specified as comma separated String values.","2125":"If not set, the channel name is used instead.","2126":"The default value of this property cannot be overridden.","2127":"group","2128":"The consumer group of the channel.","2129":"Applies only to inbound bindings.","2130":"See Consumer Groups .","2131":"Default: null (indicating an anonymous consumer).","2132":"contentType","2133":"The content type of the channel.","2134":"Default: null (so that no type coercion is performed).","2135":"binder","2136":"The binder used by this binding.","2137":"See Multiple {35/} on the Classpath for details.","2138":"Default: null (the default binder will be used, if one exists).","2139":"Consumer properties","2140":"The following binding properties are available for input bindings only and must be prefixed with {1168/}, e.g. {1169/}.","2141":"Default values can be set by using the prefix {1170/}, e.g. {1171/}.","2142":"concurrency","2143":"The concurrency of the inbound consumer.","2144":"Default: {1172/}.","2145":"partitioned","2146":"Whether the consumer receives data from a partitioned producer.","2147":"Default: {1173/}.","2148":"headerMode","2149":"When set to {1174/}, disables header parsing on input.","2150":"Effective only for messaging middleware that does not support message headers natively and requires header embedding.","2151":"Useful when inbound data is coming from outside {22/} Stream applications.","2152":"Default: {1175/}.","2153":"maxAttempts","2154":"If processing fails, the number of attempts to process the message (including the first).","2155":"Set to 1 to disable retry.","2156":"Default: {1176/}.","2157":"backOffInitialInterval","2158":"The backoff initial interval on retry.","2159":"Default: {1177/}.","2160":"backOffMaxInterval","2161":"The maximum backoff interval.","2162":"Default: {1178/}.","2163":"backOffMultiplier","2164":"The backoff multiplier.","2165":"Default: {1179/}.","2166":"instanceIndex","2167":"When set to a value greater than equal to zero, allows customizing the instance index of this consumer (if different from {1180/}).","2168":"When set to a negative value, it will default to {1181/}.","2169":"Default: {1182/}.","2170":"instanceCount","2171":"When set to a value greater than equal to zero, allows customizing the instance count of this consumer (if different from {1183/}).","2172":"When set to a negative value, it will default to {1184/}.","2173":"Default: {1185/}.","2174":"Producer {31/}","2175":"The following binding properties are available for output bindings only and must be prefixed with {1186/}, e.g. {1187/}.","2176":"Default values can be set by using the prefix {1188/}, e.g. {1189/}.","2177":"partitionKeyExpression","2178":"A SpEL expression that determines how to partition outbound data.","2179":"If set, or if {1190/} is set, outbound data on this channel will be partitioned, and {1191/} must be set to a value greater than 1 to be effective.","2180":"The two options are mutually exclusive.","2181":"See Partitioning Support .","2182":"Default: null.","2183":"partitionKeyExtractorClass","2184":"A {1192/} implementation.","2185":"If set, or if {1193/} is set, outbound data on this channel will be partitioned, and {1194/} must be set to a value greater than 1 to be effective.","2186":"The two options are mutually exclusive.","2187":"See Partitioning Support .","2188":"Default: null.","2189":"partitionSelectorClass","2190":"A {1195/} implementation.","2191":"Mutually exclusive with {1196/}.","2192":"If neither is set, the partition will be selected as the {1197/}, where {1198/} is computed via either {1199/} or {1200/}.","2193":"Default: null.","2194":"partitionSelectorExpression","2195":"A SpEL expression for customizing partition selection.","2196":"Mutually exclusive with {1201/}.","2197":"If neither is set, the partition will be selected as the {1202/}, where {1203/} is computed via either {1204/} or {1205/}.","2198":"Default: null.","2199":"partitionCount","2200":"The number of target partitions for the data, if partitioning is enabled.","2201":"Must be set to a value greater than 1 if the producer is partitioned.","2202":"On {58/}, interpreted as a hint;","2203":"the larger of this and the partition count of the target topic is used instead.","2204":"Default: {1206/}.","2205":"requiredGroups","2206":"A comma-separated list of groups to which the producer must ensure message delivery even if they start after it has been created (e.g., by pre-creating durable queues in {45/}).","2207":"headerMode","2208":"When set to {1207/}, disables header embedding on output.","2209":"Effective only for messaging middleware that does not support message headers natively and requires header embedding.","2210":"Useful when producing data for non-{22/} Stream applications.","2211":"Default: {1208/}.","2212":"useNativeEncoding","2213":"When set to {1209/}, the outbound message is serialized directly by client library, which must be configured correspondingly (eg setting an appropriate {58/} producer value serializer).","2214":"When this configuration is being used, the outbound message marshalling is not based on the {1210/} of the binding.","2215":"When native encoding is used, it is the responsibility of the consumer to use appropriate decoder (ex: {58/} consumer value de-serializer) to deserialize the inbound message.","2216":"Also, when native encoding/decoding is used the {1211/} property is ignored and headers will not be embedded into the message.","2217":"Default: {1212/}.","2218":"Using dynamically bound destinations","2219":"Besides the channels defined via {1213/}, {22/} Stream allows applications to send messages to dynamically bound destinations.","2220":"This is useful, for example, when the target destination needs to be determined at runtime.","2221":"Applications can do so by using the {1214/} bean, registered automatically by the {1215/} annotation.","2222":"The property 'spring.cloud.stream.dynamicDestinations' can be used for restricting the dynamic destination names to a set known beforehand (whitelisting).","2223":"If the property is not set, any destination can be bound dynamicaly.","2224":"The {1216/} can be used directly as in the following example, in which a REST controller uses a path variable to decide the target channel.","2225":"After starting the application on the default port 8080, when sending the following data:","2226":"The destinations 'customers' and 'orders' are created in the broker (for example: exchange in case of Rabbit or topic in case of {58/}) with the names 'customers' and 'orders', and the data is published to the appropriate destinations.","2227":"The {1217/} is a general purpose {20/} {1218/} and can be injected in other components.","2228":"For example, in a router using a SpEL expression based on the {1219/} field of an incoming JSON message.","2229":"Content Type and Transformation","2230":"To allow you to propagate information about the content type of produced messages, {22/} Stream attaches, by default, a {1220/} header to outbound messages.","2231":"For middleware that does not directly support headers, {22/} Stream provides its own mechanism of automatically wrapping outbound messages in an envelope of its own.","2232":"For middleware that does support headers, {22/} Stream applications may receive messages with a given content type from non-{22/} Stream applications.","2233":"{22/} Stream can handle messages based on this information in two ways:","2234":"Through its {1221/} settings on inbound and outbound channels","2235":"Through its argument mapping performed for methods annotated with {1222/}","2236":"{22/} Stream allows you to declaratively configure type conversion for inputs and outputs using the {1223/} property of a binding.","2237":"Note that general type conversion may also be accomplished easily by using a transformer inside your application.","2238":"Currently, {22/} Stream natively supports the following type conversions commonly used in streams:","2239":"JSON to/from POJO","2240":"JSON to/from org.springframework.tuple.Tuple","2241":"Object to/from byte[] : Either the raw bytes serialized for remote transport, bytes emitted by an application, or converted to bytes using Java serialization(requires the object to be Serializable)","2242":"String to/from byte[]","2243":"Object to plain text (invokes the object’s toString() method)","2244":"Where JSON represents either a byte array or String payload containing JSON.","2245":"Currently, Objects may be converted from a JSON byte array or String.","2246":"Converting to JSON always produces a String.","2247":"If no {1224/} property is set on an outbound channel, {22/} Stream will serialize the payload using a serializer based on the Kryo serialization framework.","2248":"Deserializing messages at the destination requires the payload class to be present on the receiver's classpath.","2249":"MIME types","2250":"{1225/} values are parsed as media types, eg, {1226/} or {1227/}.","2251":"MIME types are especially useful for indicating how to convert to String or byte[] content.","2252":"{22/} Stream also uses MIME type format to represent Java types, using the general type {1228/} with a {1229/} parameter.","2253":"For example, {1230/} or {1231/} can be set as the {1232/} property of an input binding.","2254":"In addition, {22/} Stream provides custom MIME types, notably, {1233/} to specify a Tuple.","2255":"MIME types and Java types","2256":"The type conversions {22/} Stream provides out of the box are summarized in the following table: 'Source Payload' means the payload before conversion and 'Target Payload' means the 'payload' after conversion.","2257":"The type conversion can occur either on the 'producer' side (output) or at the 'consumer' side (input).","2258":"Source Payload","2259":"Target Payload","2260":"{1234/} header (source message)","2261":"{1235/} header (after conversion)","2262":"Comments","2263":"JSON is tailored for Tuple","2264":"will apply any Charset specified in the content-type header","2265":"will apply any Charset specified in the content-type header","2266":"Note","2267":"Conversion applies to payloads that require type conversion.","2268":"For example, if an application produces an XML string with outputType=application/json, the payload will not be converted from XML to JSON.","2269":"This is because the payload send to the outbound channel is already a String so no conversion will be applied at runtime.","2270":"It is also important to note that when using the default serialization mechanism, the payload class must be shared between the sending and receiving application, and compatible with the binary content.","2271":"This can create issues when application code changes independently in the two applications, as the binary format and code may become incompatible.","2272":"Tip","2273":"While conversion is supported for both inbound and outbound channels, it is especially recommended to be used for the conversion of outbound messages.","2274":"For the conversion of inbound messages, especially when the target is a POJO, the {1236/} support will perform the conversion automatically.","2275":"Customizing message conversion","2276":"Besides the conversions that it supports out of the box, {22/} Stream also supports registering your own message conversion implementations.","2277":"This allows you to send and receive data in a variety of custom formats, including binary, and associate them with specific {1237/}.","2278":"{22/} Stream registers all the beans of type {1238/} as custom message converters along with the out of the box message converters.","2279":"If your message converter needs to work with a specific {1239/} and target class (for both input and output), then the message converter needs to extend {1240/}.","2280":"For conversion when using {1241/}, a message converter that implements {1242/} would suffice.","2281":"Here is an example of creating a message converter bean (with the content-type {1243/}) inside a {22/} Stream application:","2282":"{22/} Stream also provides support for Avro-based converters and schema evolution.","2283":"See the specific section for details.","2284":"{1244/} and Message Conversion","2285":"The {1245/} annotation provides a convenient way for converting incoming messages without the need to specify the content type of an input channel.","2286":"During the dispatching process to methods annotated with {1246/}, a conversion will be applied automatically if the argument requires it.","2287":"For example, let's consider a message with the String content {1247/} and a {1248/} header of {1249/} is received on the input channel.","2288":"Let us consider the following application that receives it:","2289":"The argument of the method will be populated automatically with the POJO containing the unmarshalled form of the JSON String.","2290":"{40/} evolution support","2291":"{22/} Stream provides support for schema-based message converters through its {1250/} module.","2292":"Currently, the only serialization format supported out of the box for schema-based message converters is {11/}, with more formats to be added in future versions.","2293":"{11/} Message Converters","2294":"The {1251/} module contains two types of message converters that can be used for {11/} serialization:","2295":"converters using the class information of the serialized/deserialized objects, or a schema with a location known at startup;","2296":"converters using a schema registry - they locate the schemas at runtime, as well as dynamically registering new schemas as domain objects evolve.","2297":"Converters with schema support","2298":"The {1252/} supports serializing and deserializing messages either using a predefined schema or by using the schema information available in the class (either reflectively, or contained in the {1253/}).","2299":"If the target type of the conversion is a {1254/}, then a schema must be set.","2300":"For using it, you can simply add it to the application context, optionally specifying one ore more {1255/} to associate it with.","2301":"The default {1256/} is {1257/}.","2302":"Here is an example of configuring it in a sink application registering the {11/} {1258/}, without a predefined schema:","2303":"Conversely, here is an application that registers a converter with a predefined schema, to be found on the classpath:","2304":"In order to understand the schema registry client converter, we will describe the schema registry support first.","2305":"{40/} Registry Support","2306":"Most serialization models, especially the ones that aim for portability across different platforms and languages, rely on a schema that describes how the data is serialized in the binary payload.","2307":"In order to serialize the data and then to interpret it, both the sending and receiving sides must have access to a schema that describes the binary format.","2308":"In certain cases, the schema can be inferred from the payload type on serialization, or from the target type on deserialization, but in a lot of cases applications benefit from having access to an explicit schema that describes the binary data format.","2309":"A schema registry allows you to store schema information in a textual format (typically JSON) and makes that information accessible to various applications that need it to receive and send data in binary format.","2310":"A schema is referenceable as a tuple consisting of:","2311":"a subject that is the logical name of the schema;","2312":"the schema version;","2313":"the schema format  which describes the binary format of the data.","2314":"{40/} Registry Server","2315":"{22/} Stream provides a schema registry server implementation.","2316":"In order to use it, you can simply add the {1259/} artifact to your project and use the {1260/} annotation, adding the schema registry server REST controller to your application.","2317":"This annotation is intended to be used with {19/} web applications, and the listening port of the server is controlled by the {1261/} setting.","2318":"The {1262/} setting can be used to control the root path of the schema server (especially when it is embedded in other applications).","2319":"The {1263/} boolean setting enables the deletion of schema.","2320":"By default this is disabled.","2321":"The schema registry server uses a relational database to store the schemas.","2322":"By default, it uses an embedded database.","2323":"You can customize the schema storage using the {19/} SQL database and JDBC configuration options .","2324":"A {19/} application enabling the schema registry looks as follows:","2325":"{40/} Registry Server API","2326":"The {40/} Registry Server API consists of the following operations:","2327":"Register a new schema.","2328":"Accepts JSON payload  with the following fields:","2329":"{1264/} the schema subject;","2330":"{1265/} the schema format;","2331":"{1266/} the schema definition.","2332":"Response is a schema object in JSON format, with the following fields:","2333":"{1267/} the schema id;","2334":"{1268/} the schema subject;","2335":"{1269/} the schema format;","2336":"{1270/} the schema version;","2337":"{1271/} the schema definition.","2338":"Retrieve an existing schema by its subject, format and version.","2339":"Response is a schema object in JSON format, with the following fields:","2340":"{1272/} the schema id;","2341":"{1273/} the schema subject;","2342":"{1274/} the schema format;","2343":"{1275/} the schema version;","2344":"{1276/} the schema definition.","2345":"Retrieve a list of existing schema by its subject and format.","2346":"Response is a list of schemas with each schema object in JSON format, with the following fields:","2347":"{1277/} the schema id;","2348":"{1278/} the schema subject;","2349":"{1279/} the schema format;","2350":"{1280/} the schema version;","2351":"{1281/} the schema definition.","2352":"Retrieve an existing schema by its id.","2353":"Response is a schema object in JSON format, with the following fields:","2354":"{1282/} the schema id;","2355":"{1283/} the schema subject;","2356":"{1284/} the schema format;","2357":"{1285/} the schema version;","2358":"{1286/} the schema definition.","2359":"Delete an existing schema by its subject, format and version.","2360":"Delete an existing schema by its id.","2361":"Delete existing schemas by their subject.","2362":"Note","2363":"This note applies to users of {22/} Stream 1.1.0.RELEASE only.","2364":"{22/} Stream 1.1.0.RELEASE used the table name {1287/} for storing {1288/} objects, which is a keyword in a number of database implementations.","2365":"To avoid any conflicts in the future, starting with 1.1.1.RELEASE we have opted for the name {1289/} for the storage table.","2366":"Any {22/} Stream 1.1.0.RELEASE users that are upgrading are advised to migrate their existing schemas to the new table before upgrading.","2367":"{40/} Registry Client","2368":"The client-side abstraction for interacting with schema registry servers is the {1290/} interface, with the following structure:","2369":"{22/} Stream provides out of the box implementations for interacting with its own schema server, as well as for interacting with the Confluent {40/} Registry.","2370":"A client for the {22/} Stream schema registry can be configured using the {1291/} as follows:","2371":"Note","2372":"The default converter is optimized to cache not only the schemas from the remote server but also the {1292/} and {1293/} methods that are quite expensive.","2373":"Because of this, it uses a {1294/} that does not caches responses.","2374":"If you intend to use the client directly on your code, you can request a bean that also caches responses to be created.","2375":"To do that, just add the property {1295/} to your application properties.","2376":"{40/} Registry Client properties","2377":"The {40/} Registry Client supports the following properties:","2378":"spring.cloud.stream.schemaRegistryClient.endpoint","2379":"The location of the schema-server.","2380":"Use a full URL when setting this, including protocol ({1296/} or {1297/}) , port and context path.","2381":"Default","2382":"spring.cloud.stream.schemaRegistryClient.cached","2383":"Whether the client should cache schema server responses.","2384":"Normally set to {1298/}, as the caching happens iin the message converter.","2385":"Clients using the schema registry client should set this to {1299/}.","2386":"Default","2387":"{8/} Registry Client Message Converters","2388":"For {19/} applications that have a {1300/} bean registered with the application context, {22/} Stream will auto-configure an {11/} message converter that uses the schema registry client for schema management.","2389":"This eases schema evolution, as applications that receive messages can get easy access to a writer schema that can be reconciled with their own reader schema.","2390":"For outbound messages, the {1301/} will be activated if the content type of the channel is set to {1302/}, e.g.:","2391":"During the outbound conversion, the message converter will try to infer the schemas of the outbound messages based on their type and register them to a subject based on the payload type using the {1303/}.","2392":"If an identical schema is already found, then a reference to it will be retrieved.","2393":"If not, the schema will be registered and a new version number will be provided.","2394":"The message will be sent with a {1304/} header using the scheme {1305/}, where {1306/} is configurable and {1307/} is deduced from the payload type.","2395":"For example, a message of the type {1308/} may be sent as a binary payload with a content type of {1309/}, where {1310/} is the subject and {1311/} is the version number.","2396":"When receiving messages, the converter will infer the schema reference from the header of the incoming message and will try to retrieve it.","2397":"The schema will be used as the writer schema in the deserialization process.","2398":"{8/} Registry Message Converter properties","2399":"If you have enabled Avro based schema registry client by setting {1312/} you can customize the behavior of the registration with the following properties.","2400":"spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled","2401":"Enable if you want the converter to use reflection to infer a {40/} from a POJO.","2402":"Default","2403":"spring.cloud.stream.schema.avro.readerSchema","2404":"Avro compares schema versions by looking at a writer schema (origin payload) and a reader schema (your application payload), check Avro documentation for more information.","2405":"If set, this overrides any lookups at the schema server and uses the local schema as the reader schema.","2406":"Default","2407":"spring.cloud.stream.schema.avro.schemaLocations","2408":"Register any {1313/} files listed in this property with the {40/} Server.","2409":"Default","2410":"spring.cloud.stream.schema.avro.prefix","2411":"The prefix to be used on the Content-Type header.","2412":"Default","2413":"{40/} Registration and Resolution","2414":"To better understand how {22/} Stream registers and resolves new schemas, as well as its use of Avro schema comparison features, we will provide two separate subsections below: one for the registration, and one for the resolution of schemas.","2415":"{40/} Registration Process (Serialization)","2416":"The first part of the registration process is extracting a schema from the payload that is being sent over a channel.","2417":"Avro types such as {1314/} or {1315/} already contain a schema, which can be retrieved immediately from the instance.","2418":"In the case of POJOs a schema will be inferred if the property {1316/} is set to {1317/} (the default).","2419":"Figure 10. {40/} Writer Resolution Process","2420":"Once a schema is obtained, the converter will then load its metadata (version) from the remote server.","2421":"First it queries a local cache, and if not found it then submits the data to the server that will reply with versioning information.","2422":"The converter will always cache the results to avoid the overhead of querying the {40/} Server for every new message that needs to be serialized.","2423":"Figure 11. {40/} Registration Process","2424":"With the schema version information, the converter sets the {1318/} header of the message to carry the version information such as {1319/}","2425":"{40/} Resolution Process (Deserialization)","2426":"When reading messages that contain version information (ie a {1320/} header with a scheme like above), the converter will query the {40/} server to fetch the writer schema of the message.","2427":"Once it has found the correct schema of the incoming message, it then retrieves the reader schema and using Avro's schema resolution support reads it into the reader definition (setting defaults and missing properties).","2428":"Figure 12. {40/} Reading Resolution Process","2429":"Note","2430":"It's important to understand the difference between a writer schema (the application that wrote the message) and a reader schema (the receiving application).","2431":"Please take a moment to read the Avro terminology and understand the process.","2432":"{22/} Stream will always fetch the writer schema to determine how to read a message.","2433":"If you want to get Avro's schema evolution support working you need to make sure that a readerSchema was properly set for your application.","2434":"Inter-Application Communication","2435":"Connecting Multiple Application Instances","2436":"While {22/} Stream makes it easy for individual {19/} applications to connect to messaging systems, the typical scenario for {22/} Stream is the creation of multi-application pipelines, where microservice applications send data to each other.","2437":"You can achieve this scenario by correlating the input and output destinations of adjacent applications.","2438":"Supposing that a design calls for the Time Source application to send data to the Log Sink application, you can use a common destination named {1321/} for bindings within both applications.","2439":"Time Source (that has the channel name {1322/}) will set the following property:","2440":"Log Sink (that has the channel name {1323/}) will set the following property:","2441":"Instance Index and Instance Count","2442":"When scaling up {22/} Stream applications, each instance can receive information about how many other instances of the same application exist and what its own instance index is.","2443":"{22/} Stream does this through the {1324/} and {1325/} properties.","2444":"For example, if there are three instances of a HDFS sink application, all three instances will have {1326/} set to {1327/}, and the individual applications will have {1328/} set to {1329/}, {1330/}, and {1331/}, respectively.","2445":"When {22/} Stream applications are deployed via {22/} Data Flow, these properties are configured automatically;","2446":"when {22/} Stream applications are launched independently, these properties must be set correctly.","2447":"By default, {1332/} is {1333/}, and {1334/} is {1335/}.","2448":"In a scaled-up scenario, correct configuration of these two properties is important for addressing partitioning behavior (see below) in general, and the two properties are always required by certain binders (e.g., the {58/} binder) in order to ensure that data are split correctly across multiple consumer instances.","2449":"Partitioning","2450":"Configuring Output Bindings for Partitioning","2451":"An output binding is configured to send partitioned data by setting one and only one of its {1336/} or {1337/} properties, as well as its {1338/} property.","2452":"For example, the following is a valid and typical configuration:","2453":"Based on the above example configuration, data will be sent to the target partition using the following logic.","2454":"A partition key's value is calculated for each message sent to a partitioned output channel based on the {1339/}.","2455":"The {1340/} is a SpEL expression which is evaluated against the outbound message for extracting the partitioning key.","2456":"If a SpEL expression is not sufficient for your needs, you can instead calculate the partition key value by setting the property {1341/} to a class which implements the {1342/} interface.","2457":"While the SpEL expression should usually suffice, more complex cases may use the custom implementation strategy.","2458":"In that case, the property 'partitionKeyExtractorClass' can be set as follows:","2459":"Once the message key is calculated, the partition selection process will determine the target partition as a value between {1343/} and {1344/}.","2460":"The default calculation, applicable in most scenarios, is based on the formula {1345/}.","2461":"This can be customized on the binding, either by setting a SpEL expression to be evaluated against the 'key' (via the {1346/} property) or by setting a {1347/} implementation (via the {1348/} property).","2462":"The binding level properties for 'partitionSelectorExpression' and 'partitionSelectorClass' can be specified similar to the way 'partitionKeyExpression' and 'partitionKeyExtractorClass' properties are specified in the above examples.","2463":"Additional properties can be configured for more advanced scenarios, as described in the following section.","2464":"{41/}-managed custom {1349/} implementations","2465":"In the example above, a custom strategy such as {1350/} is instantiated by the {22/} Stream directly.","2466":"In some cases, it is necessary for such a custom strategy implementation to be created as a {41/} bean, for being able to be managed by {41/}, so that it can perform dependency injection, property binding, etc. This can be done by configuring it as a @Bean in the application context and using the fully qualified class name as the bean's name, as in the following example.","2467":"As a {41/} bean, the custom strategy benefits from the full lifecycle of a {41/} bean.","2468":"For example, if the implementation need access to the application context directly, it can make implement 'ApplicationContextAware'.","2469":"Configuring Input Bindings for Partitioning","2470":"An input binding (with the channel name {1351/}) is configured to receive partitioned data by setting its {1352/} property, as well as the {1353/} and {1354/} properties on the application itself, as in the following example:","2471":"The {1355/} value represents the total number of application instances between which the data need to be partitioned, and the {1356/} must be a unique value across the multiple instances, between {1357/} and {1358/}.","2472":"The instance index helps each application instance to identify the unique partition (or, in the case of {58/}, the partition set) from which it receives data.","2473":"It is important to set both values correctly in order to ensure that all of the data is consumed and that the application instances receive mutually exclusive datasets.","2474":"While a scenario which using multiple instances for partitioned data processing may be complex to set up in a standalone case, {22/} Dataflow can simplify the process significantly by populating both the input and output values correctly as well as relying on the runtime infrastructure to provide information about the instance index and instance count.","2475":"Testing","2476":"{22/} Stream provides support for testing your microservice applications without connecting to a messaging system.","2477":"You can do that by using the {1359/} provided by the {1360/} library, which can be added as a test dependency to the application:","2478":"Note","2479":"The {1361/} uses the {19/} autoconfiguration mechanism to supersede the other binders found on the classpath.","2480":"Therefore, when adding a binder as a dependency, make sure that the {1362/} scope is being used.","2481":"The {1363/} allows users to interact with the bound channels and inspect what messages are sent and received by the application","2482":"For outbound message channels, the {1364/} registers a single subscriber and retains the messages emitted by the application in a {1365/}.","2483":"They can be retrieved during tests and have assertions made against them.","2484":"The user can also send messages to inbound message channels, so that the consumer application can consume the messages.","2485":"The following example shows how to test both input and output channels on a processor.","2486":"In the example above, we are creating an application that has an input and an output channel, bound through the {1366/} interface.","2487":"The bound interface is injected into the test so we can have access to both channels.","2488":"We are sending a message on the input channel and we are using the {1367/} provided by {22/} Stream's test support to capture the message has been sent to the output channel as a result.","2489":"Once we have received the message, we can validate that the component functions correctly.","2490":"Health Indicator","2491":"{22/} Stream provides a health indicator for binders.","2492":"It is registered under the name of {1368/} and can be enabled or disabled by setting the {1369/} property.","2493":"Metrics Emitter","2494":"{22/} Stream provides a module called {1370/} that can be used to emit any available metric from {19/} metrics endpoint to a named channel.","2495":"This module allow operators to collect metrics from stream applications without relying on polling their endpoints.","2496":"The module is activated when you set the destination name for metrics binding, eg {1371/}.","2497":"{1372/} can be configured in a similar fashion to any other producer binding.","2498":"The default {1373/} setting of {1374/} is {1375/}.","2499":"The following properties can be used for customizing the emission of metrics:","2500":"spring.cloud.stream.metrics.key","2501":"The name of the metric being emitted.","2502":"Should be an unique value per application.","2503":"Default","2504":"spring.cloud.stream.metrics.prefix","2505":"Prefix string to be prepended to the metrics key.","2506":"Default: ``","2507":"spring.cloud.stream.metrics.properties","2508":"Just like the {1376/} option, it allows white listing application properties that will be added to the metrics payload","2509":"Default: null.","2510":"A detailed overview of the metrics export process can be found in the {19/} reference documentation .","2511":"{22/} Stream provides a metric exporter named {1377/} that can be configured via regular {19/} metrics configuration properties .","2512":"The exporter can be configured either by using the global {19/} configuration settings for exporters, or by using exporter-specific properties.","2513":"For using the global configuration settings, the properties should be prefixed by {1378/} (eg {1379/}).","2514":"These configuration options will apply to all exporters (unless they have been configured differently).","2515":"Alternatively, if it is intended to use configuration settings that are different from the other exporters (eg for restricting the number of metrics published), the {22/} Stream provided metrics exporter can be configured using the prefix {1380/} (eg {1381/}).","2516":"Note","2517":"Due to {19/}’s relaxed binding the value of a property being included can be slightly different than the original value.","2518":"As a rule of thumb, the metric exporter will attempt to normalize all the properties in a consistent format using the dot notation (e.g. {1382/} becomes {1383/}).","2519":"The goal of normalization is to make downstream consumers of those metrics capable of receiving property names consistently, regardless of how they are set on the monitored application ({1384/} or {1385/} would always yield {1386/}).","2520":"Below is a sample of the data published to the channel in JSON format by the following command:","2521":"The resulting JSON is:","2522":"Samples","2523":"For {22/} Stream samples, please refer to the {28/}-samples repository on GitHub.","2524":"Getting Started","2525":"To get started with creating {22/} Stream applications, visit the {41/} Initializr and create a new Maven project named \"GreetingSource\".","2526":"Select {19/} {supported-spring-boot-version} in the dropdown.","2527":"In the Search for dependencies text box type {1387/} or {1388/} depending on what binder you want to use.","2528":"Next, create a new class, {1389/}, in the same package as the {1390/} class.","2529":"Give it the following code:","2530":"The {1391/} annotation is what triggers the creation of {20/} infrastructure components.","2531":"Specifically, it will create a {58/} connection factory, a {58/} outbound channel adapter, and the message channel defined inside the Source interface:","2532":"The auto-configuration also creates a default poller, so that the {1392/} method will be invoked once per second.","2533":"The standard {20/} {1393/} annotation sends a message to the source's output channel, using the return value as the payload of the message.","2534":"To test-drive this setup, run a {58/} message broker.","2535":"An easy way to do this is to use a Docker image:","2536":"Build the application:","2537":"The consumer application is coded in a similar manner.","2538":"Go back to Initializr and create another project, named LoggingSink.","2539":"Then create a new class, {1394/}, in the same package as the class {1395/} and with the following code:","2540":"Build the application:","2541":"To connect the GreetingSource application to the LoggingSink application, each application must share the same destination name.","2542":"Starting up both applications as shown below, you will see the consumer application printing \"hello world\" and a timestamp to the console:","2543":"(The different server port prevents collisions of the HTTP port used to service the {19/} Actuator endpoints in the two applications.)","2544":"The output of the LoggingSink application will look something like the following:","2545":"{48/} Implementations","2546":"Apache {6/}","2547":"Usage","2548":"For using the Apache {58/} binder, you just need to add it to your {22/} Stream application, using the following Maven coordinates:","2549":"Alternatively, you can also use the {22/} Stream {58/} Starter.","2550":"Apache {6/} Overview","2551":"A simplified diagram of how the Apache {58/} binder operates can be seen below.","2552":"Figure 13. {6/}","2553":"The Apache {6/} implementation maps each destination to an Apache {58/} topic.","2554":"The consumer group maps directly to the same Apache {58/} concept.","2555":"Partitioning also maps directly to Apache {58/} partitions as well.","2556":"Configuration Options","2557":"This section contains the configuration options used by the Apache {58/} binder.","2558":"For common configuration options and properties pertaining to binder, refer to the core documentation.","2560":"spring.cloud.stream.kafka.binder.brokers","2561":"A list of brokers to which the {58/} binder will connect.","2562":"Default: {1396/}.","2563":"spring.cloud.stream.kafka.binder.defaultBrokerPort","2564":"{1397/} allows hosts specified with or without port information (eg, {1398/}).","2565":"This sets the default port when no port is configured in the broker list.","2566":"Default: {1399/}.","2567":"spring.cloud.stream.kafka.binder.zkNodes","2568":"A list of ZooKeeper nodes to which the {58/} binder can connect.","2569":"Default: {1400/}.","2570":"spring.cloud.stream.kafka.binder.defaultZkPort","2571":"{1401/} allows hosts specified with or without port information (eg, {1402/}).","2572":"This sets the default port when no port is configured in the node list.","2573":"Default: {1403/}.","2574":"spring.cloud.stream.kafka.binder.configuration","2575":"Key/Value map of client properties (both producers and consumer) passed to all clients created by the binder.","2576":"Due to the fact that these properties will be used by both producers and consumers, usage should be restricted to common properties, especially security settings.","2577":"Default: Empty map.","2578":"spring.cloud.stream.kafka.binder.headers","2579":"The list of custom headers that will be transported by the binder.","2580":"Default: empty.","2581":"spring.cloud.stream.kafka.binder.offsetUpdateTimeWindow","2582":"The frequency, in milliseconds, with which offsets are saved.","2583":"Ignored if {1404/}.","2584":"Default: {1405/}.","2585":"spring.cloud.stream.kafka.binder.offsetUpdateCount","2586":"The frequency, in number of updates, which which consumed offsets are persisted.","2587":"Ignored if {1406/}.","2588":"Mutually exclusive with {1407/}.","2589":"Default: {1408/}.","2590":"spring.cloud.stream.kafka.binder.requiredAcks","2591":"The number of required acks on the broker.","2592":"Default: {1409/}.","2593":"spring.cloud.stream.kafka.binder.minPartitionCount","2594":"Effective only if {1410/} or {1411/} is set.","2595":"The global minimum number of partitions that the binder will configure on topics on which it produces/consumes data.","2596":"It can be superseded by the {1412/} setting of the producer or by the value of {1413/} * {1414/} settings of the producer (if either is larger).","2597":"Default: {1415/}.","2598":"spring.cloud.stream.kafka.binder.replicationFactor","2599":"The replication factor of auto-created topics if {1416/} is active.","2600":"Default: {1417/}.","2601":"spring.cloud.stream.kafka.binder.autoCreateTopics","2602":"If set to {1418/}, the binder will create new topics automatically.","2603":"If set to {1419/}, the binder will rely on the topics being already configured.","2604":"In the latter case, if the topics do not exist, the binder will fail to start.","2605":"Of note, this setting is independent of the {1420/} setting of the broker and it does not influence it: if the server is set to auto-create topics, they may be created as part of the metadata retrieval request, with default broker settings.","2606":"Default: {1421/}.","2607":"spring.cloud.stream.kafka.binder.autoAddPartitions","2608":"If set to {1422/}, the binder will create add new partitions if required.","2609":"If set to {1423/}, the binder will rely on the partition size of the topic being already configured.","2610":"If the partition count of the target topic is smaller than the expected value, the binder will fail to start.","2611":"Default: {1424/}.","2612":"spring.cloud.stream.kafka.binder.socketBufferSize","2613":"Size (in bytes) of the socket buffer to be used by the {58/} consumers.","2614":"Default: {1425/}.","2615":"{58/} Consumer {31/}","2616":"The following properties are available for {58/} consumers only and\nmust be prefixed with {1426/}.","2617":"autoRebalanceEnabled","2618":"When {1427/}, topic partitions will be automatically rebalanced between the members of a consumer group.","2619":"When {1428/}, each consumer will be assigned a fixed set of partitions based on {1429/} and {1430/}.","2620":"This requires both {1431/} and {1432/} properties to be set appropriately on each launched instance.","2621":"The property {1433/} must typically be greater than 1 in this case.","2622":"Default: {1434/}.","2623":"autoCommitOffset","2624":"Whether to autocommit offsets when a message has been processed.","2625":"If set to {1435/}, a header with the key {1436/} of the type {1437/} header will be present in the inbound message.","2626":"Applications may use this header for acknowledging messages.","2627":"See the examples section for details.","2628":"When this property is set to {1438/}, {58/} binder will set the ack mode to {1439/}.","2629":"Default: {1440/}.","2630":"autoCommitOnError","2631":"Effective only if {1441/} is set to {1442/}.","2632":"If set to {1443/} it suppresses auto-commits for messages that result in errors, and will commit only for successful messages, allows a stream to automatically replay from the last successfully processed message, in case of persistent failures.","2633":"If set to {1444/}, it will always auto-commit (if auto-commit is enabled).","2634":"If not set (default), it effectively has the same value as {1445/}, auto-committing erroneous messages if they are sent to a DLQ, and not committing them otherwise.","2635":"Default: not set.","2636":"recoveryInterval","2637":"The interval between connection recovery attempts, in milliseconds.","2638":"Default: {1446/}.","2639":"resetOffsets","2640":"Whether to reset offsets on the consumer to the value provided by {1447/}.","2641":"Default: {1448/}.","2642":"startOffset","2643":"The starting offset for new groups, or when {1449/} is {1450/}.","2644":"Allowed values: {1451/}, {1452/}.","2645":"If the consumer group is set explicitly for the consumer 'binding' (via {1453/}), then 'startOffset' is set to {1454/};","2646":"otherwise it is set to {1455/} for the {1456/} consumer group.","2647":"Default: null (equivalent to {1457/}).","2648":"enableDlq","2649":"When set to true, it will send enable DLQ behavior for the consumer.","2650":"By default, messages that result in errors will be forwarded to a topic named {1458/}.","2651":"The DLQ topic name can be configurable via the property {1459/}.","2652":"This provides an alternative option to the more common {58/} replay scenario for the case when the number of errors is relatively small and replaying the entire original topic may be too cumbersome.","2653":"Default: {1460/}.","2654":"configuration","2655":"Map with a key/value pair containing generic {58/} consumer properties.","2656":"Default: Empty map.","2657":"dlqName","2658":"The name of the DLQ topic to receive the error messages.","2659":"Default: null (If not specified, messages that result in errors will be forwarded to a topic named {1461/}).","2660":"{58/} Producer {31/}","2661":"The following properties are available for {58/} producers only and\nmust be prefixed with {1462/}.","2662":"bufferSize","2663":"Upper limit, in bytes, of how much data the {58/} producer will attempt to batch before sending.","2664":"Default: {1463/}.","2665":"sync","2666":"Whether the producer is synchronous.","2667":"Default: {1464/}.","2668":"batchTimeout","2669":"How long the producer will wait before sending in order to allow more messages to accumulate in the same batch.","2670":"(Normally the producer does not wait at all, and simply sends all the messages that accumulated while the previous send was in progress.) A non-zero value may increase throughput at the expense of latency.","2671":"Default: {1465/}.","2672":"configuration","2673":"Map with a key/value pair containing generic {58/} producer properties.","2674":"Default: Empty map.","2675":"Note","2676":"The {58/} binder will use the {1466/} setting of the producer as a hint to create a topic with the given partition count (in conjunction with the {1467/}, the maximum of the two being the value being used).","2677":"Exercise caution when configuring both {1468/} for a binder and {1469/} for an application, as the larger value will be used.","2678":"If a topic already exists with a smaller partition count and {1470/} is disabled (the default), then the binder will fail to start.","2679":"If a topic already exists with a smaller partition count and {1471/} is enabled, new partitions will be added.","2680":"If a topic already exists with a larger number of partitions than the maximum of ({1472/} and {1473/}), the existing partition count will be used.","2681":"Usage examples","2682":"In this section, we illustrate the use of the above properties for specific scenarios.","2683":"Example: Setting {1474/} false and relying on manual acking.","2684":"This example illustrates how one may manually acknowledge offsets in a consumer application.","2685":"This example requires that {1475/} is set to false.","2686":"Use the corresponding input channel name for your example.","2687":"Example: security configuration","2688":"Apache {58/} 0.9 supports secure connections between client and brokers.","2689":"To take advantage of this feature, follow the guidelines in the Apache {58/} Documentation as well as the {58/} 0.9 security guidelines from the Confluent documentation .","2690":"Use the {1476/} option to set security properties for all clients created by the binder.","2691":"For example, for setting {1477/} to {1478/}, set:","2692":"All the other security properties can be set in a similar manner.","2693":"When using Kerberos, follow the instructions in the reference documentation for creating and referencing the JAAS configuration.","2694":"{22/} Stream supports passing JAAS configuration information to the application using a JAAS configuration file and using {19/} properties.","2695":"Using JAAS configuration files","2696":"The JAAS, and (optionally) krb5 file locations can be set for {22/} Stream applications by using system properties.","2697":"Here is an example of launching a {22/} Stream application with SASL and Kerberos using a JAAS configuration file:","2698":"Using {19/} properties","2699":"As an alternative to having a JAAS configuration file, {22/} Stream provides a mechanism for setting up the JAAS configuration for {22/} Stream applications using {19/} properties.","2700":"The following properties can be used for configuring the login context of the {58/} client.","2701":"spring.cloud.stream.kafka.binder.jaas.loginModule","2702":"The login module name.","2703":"Not necessary to be set in normal cases.","2704":"Default: {1479/}.","2705":"spring.cloud.stream.kafka.binder.jaas.controlFlag","2706":"The control flag of the login module.","2707":"Default: {1480/}.","2708":"spring.cloud.stream.kafka.binder.jaas.options","2709":"Map with a key/value pair containing the login module options.","2710":"Default: Empty map.","2711":"Here is an example of launching a {22/} Stream application with SASL and Kerberos using {19/} configuration properties:","2712":"This represents the equivalent of the following JAAS file:","2713":"If the topics required already exist on the broker, or will be created by an administrator, autocreation can be turned off and only client JAAS properties need to be sent.","2714":"As an alternative to setting {1481/} you can simply remove the broker dependency from the application.","2715":"See Excluding {58/} broker jar from the classpath of the binder based application for details.","2716":"Note","2717":"Do not mix JAAS configuration files and {19/} properties in the same application.","2718":"If the {1482/} system property is already present, {22/} Stream will ignore the {19/} properties.","2719":"Note","2720":"Exercise caution when using the {1483/} and {1484/} if using Kerberos.","2721":"Usually applications may use principals that do not have administrative rights in {58/} and {37/}, and relying on {22/} Stream to create/modify topics may fail.","2722":"In secure environments, we strongly recommend creating topics and managing ACLs administratively using {58/} tooling.","2723":"Using the binder with Apache {58/} 0.10","2724":"The default {58/} support in {22/} Stream {58/} binder is for {58/} version 0.10.1.1.","2725":"The binder also supports connecting to other 0.10 based versions and 0.9 clients.","2726":"In order to do this, when you create the project that contains your application, include {1485/} as you normally would do for the default binder.","2727":"Then add these dependencies at the top of the {1486/} section in the pom.xml file to override the dependencies.","2728":"Here is an example for downgrading your application to 0.10.0.1.","2729":"Since it is still on the 0.10 line, the default {1487/} and {1488/} versions can be retained.","2730":"Here is another example of using 0.9.0.1 version.","2731":"Note","2732":"The versions above are provided only for the sake of the example.","2733":"For best results, we recommend using the most recent 0.10-compatible versions of the projects.","2734":"Excluding {58/} broker jar from the classpath of the binder based application","2735":"The Apache {6/} uses the administrative utilities which are part of the Apache {58/} server library to create and reconfigure topics.","2736":"If the inclusion of the Apache {58/} server library and its dependencies is not necessary at runtime because the application will rely on the topics being configured administratively, the {58/} binder allows for Apache {58/} server dependency to be excluded from the application.","2737":"If you use non default versions for {58/} dependencies as advised above, all you have to do is not to include the kafka broker dependency.","2738":"If you use the default {58/} version, then ensure that you exclude the kafka broker jar from the {1489/} dependency as following.","2739":"If you exclude the Apache {58/} server dependency and the topic is not present on the server, then the Apache {58/} broker will create the topic if auto topic creation is enabled on the server.","2740":"Please keep in mind that if you are relying on this, then the {58/} server will use the default number of partitions and replication factors.","2741":"On the other hand, if auto topic creation is disabled on the server, then care must be taken before running the application to create the topic with the desired number of partitions.","2742":"If you want to have full control over how partitions are allocated, then leave the default settings as they are, i.e. do not exclude the kafka broker jar and ensure that {1490/} is set to {1491/}, which is the default.","2743":"{7/} Topic Processing","2744":"Because it can't be anticipated how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.","2745":"If the reason for the dead-lettering is transient, you may wish to route the messages back to the original topic.","2746":"However, if the problem is a permanent issue, that could cause an infinite loop.","2747":"The following {1492/} application is an example of how to route those messages back to the original topic, but moves them to a third \"parking lot\" topic after three attempts.","2748":"The application is simply another {28/} application that reads from the dead-letter topic.","2749":"It terminates when no messages are received for 5 seconds.","2750":"The examples assume the original destination is {1493/} and the consumer group is {1494/}.","2751":"There are several considerations.","2752":"Consider only running the rerouting when the main application is not running.","2753":"Otherwise, the retries for transient errors will be used up very quickly.","2754":"Alternatively, use a two-stage approach - use this application to route to a third topic, and another to route from there back to the main topic.","2755":"Since this technique uses a message header to keep track of retries, it won't work with {1495/}.","2756":"In that case, consider adding some data to the payload (that can be ignored by the main application).","2757":"{1496/} has to be added to the {1497/} property {1498/} on both this, and the main application so that the header is transported between the applications.","2758":"Since kafka is publish/subscribe, replayed messages will be sent to each consumer group, even those that successfully processed a message the first time around.","2759":"application.properties","2760":"Application","2762":"Usage","2763":"For using the {45/} binder, you just need to add it to your {22/} Stream application, using the following Maven coordinates:","2764":"Alternatively, you can also use the {22/} Stream {45/} Starter.","2765":"{18/} Overview","2766":"A simplified diagram of how the {45/} binder operates can be seen below.","2767":"Figure 14. {18/}","2768":"The {18/} implementation maps each destination to a {1499/}.","2769":"For each consumer group, a {1500/} will be bound to that {1501/}.","2770":"Each consumer instance have a corresponding {45/} {1502/} instance for its group's {1503/}.","2771":"For partitioned producers/consumers the queues are suffixed with the partition index and use the partition index as routing key.","2772":"Using the {1504/} option, you can optionally configure the binder to create and configure dead-letter queues (DLQs) (and a dead-letter exchange {1505/}).","2773":"The dead letter queue has the name of the destination, appended with {1506/}.","2774":"If retry is enabled ({1507/}) failed messages will be delivered to the DLQ.","2775":"If retry is disabled ({1508/}), you should set {1509/} to {1510/} (default) so that a failed message will be routed to the DLQ, instead of being requeued.","2776":"In addition, {1511/} causes the binder to publish a failed message to the DLQ (instead of rejecting it);","2777":"this enables additional information to be added to the message in headers, such as the stack trace in the {1512/} header.","2778":"This option does not need retry enabled;","2779":"you can republish a failed message after just one attempt.","2780":"Starting with version 1.2 , you can configure the delivery mode of republished messsages;","2781":"see property {1513/}.","2782":"Important","2783":"Setting {1514/} to {1515/} will cause the message to be requeued and redelivered continually, which is likely not what you want unless the failure issue is transient.","2784":"In general, it's better to enable retry within the binder by setting {1516/} to greater than one, or set {1517/} to {1518/}.","2785":"See {18/} {31/} for more information about these properties.","2786":"The framework does not provide any standard mechanism to consume dead-letter messages (or to re-route them back to the primary queue).","2787":"Some options are described in {7/} Queue Processing .","2788":"Note","2789":"When multiple {45/} binders are used in a {22/} Stream application, it is important to disable 'RabbitAutoConfiguration' to avoid the same configuration from RabbitAutoConfiguration being applied to the two binders.","2790":"Configuration Options","2791":"This section contains settings specific to the {18/} and bound channels.","2792":"For general binding configuration options and properties,\nplease refer to the {22/} Stream core documentation.","2794":"By default, the {45/} binder uses {19/}'s {1519/}, and it therefore supports all {19/} configuration options for {45/}.","2795":"(For reference, consult the {19/} documentation .) {45/} configuration options use the {1520/} prefix.","2796":"In addition to {19/} options, the {45/} binder supports the following properties:","2797":"spring.cloud.stream.rabbit.binder.adminAddresses","2798":"A comma-separated list of {45/} management plugin URLs.","2799":"Only used when {1521/} contains more than one entry.","2800":"Each entry in this list must have a corresponding entry in {1522/}.","2801":"Default: empty.","2802":"spring.cloud.stream.rabbit.binder.nodes","2803":"A comma-separated list of {45/} node names.","2804":"When more than one entry, used to locate the server address where a queue is located.","2805":"Each entry in this list must have a corresponding entry in {1523/}.","2806":"Default: empty.","2807":"spring.cloud.stream.rabbit.binder.compressionLevel","2808":"Compression level for compressed bindings.","2809":"See {1524/}.","2810":"Default: {1525/} (BEST_LEVEL).","2811":"{45/} Consumer {31/}","2812":"The following properties are available for Rabbit consumers only and\nmust be prefixed with {1526/}.","2813":"acknowledgeMode","2814":"The acknowledge mode.","2815":"Default: {1527/}.","2816":"autoBindDlq","2817":"Whether to automatically declare the DLQ and bind it to the binder DLX.","2818":"Default: {1528/}.","2819":"bindingRoutingKey","2820":"The routing key with which to bind the queue to the exchange (if {1529/} is {1530/}).","2821":"for partitioned destinations {1531/} will be appended.","2822":"Default: {1532/}.","2823":"bindQueue","2824":"Whether to bind the queue to the destination exchange;","2825":"set to {1533/} if you have set up your own infrastructure and have previously created/bound the queue.","2826":"Default: {1534/}.","2827":"deadLetterQueueName","2828":"name of the DLQ","2829":"Default: {1535/}","2830":"deadLetterExchange","2831":"a DLX to assign to the queue;","2832":"if autoBindDlq is true","2833":"Default: 'prefix+DLX'","2834":"deadLetterRoutingKey","2835":"a dead letter routing key to assign to the queue;","2836":"if autoBindDlq is true","2837":"Default: {1536/}","2838":"declareExchange","2839":"Whether to declare the exchange for the destination.","2840":"Default: {1537/}.","2841":"delayedExchange","2842":"Whether to declare the exchange as a {1538/} - requires the delayed message exchange plugin on the broker.","2843":"The {1539/} argument is set to the {1540/}.","2844":"Default: {1541/}.","2845":"dlqDeadLetterExchange","2846":"if a DLQ is declared, a DLX to assign to that queue","2847":"Default: {1542/}","2848":"dlqDeadLetterRoutingKey","2849":"if a DLQ is declared, a dead letter routing key to assign to that queue;","2850":"default none","2851":"Default: {1543/}","2852":"dlqExpires","2853":"how long before an unused dead letter queue is deleted (ms)","2854":"Default: {1544/}","2855":"dlqMaxLength","2856":"maximum number of messages in the dead letter queue","2857":"Default: {1545/}","2858":"dlqMaxLengthBytes","2859":"maximum number of total bytes in the dead letter queue from all messages","2860":"Default: {1546/}","2861":"dlqMaxPriority","2862":"maximum priority of messages in the dead letter queue (0-255)","2863":"Default: {1547/}","2864":"dlqTtl","2865":"default time to live to apply to the dead letter queue when declared (ms)","2866":"Default: {1548/}","2867":"durableSubscription","2868":"Whether subscription should be durable.","2869":"Only effective if {1549/} is also set.","2870":"Default: {1550/}.","2871":"exchangeAutoDelete","2872":"If {1551/} is true, whether the exchange should be auto-delete (removed after the last queue is removed).","2873":"Default: {1552/}.","2874":"exchangeDurable","2875":"If {1553/} is true, whether the exchange should be durable (survives broker restart).","2876":"Default: {1554/}.","2877":"exchangeType","2878":"The exchange type;","2879":"{1555/}, {1556/} or {1557/} for non-partitioned destinations;","2880":"{1558/} or {1559/} for partitioned destinations.","2881":"Default: {1560/}.","2882":"expires","2883":"how long before an unused queue is deleted (ms)","2884":"Default: {1561/}","2885":"headerPatterns","2886":"Patterns for headers to be mapped from inbound messages.","2887":"Default: {1562/} (all headers).","2888":"maxConcurrency","2889":"the maximum number of consumers","2890":"Default: {1563/}.","2891":"maxLength","2892":"maximum number of messages in the queue","2893":"Default: {1564/}","2894":"maxLengthBytes","2895":"maximum number of total bytes in the queue from all messages","2896":"Default: {1565/}","2897":"maxPriority","2898":"maximum priority of messages in the queue (0-255)","2899":"Default","2900":"prefetch","2901":"Prefetch count.","2902":"Default: {1566/}.","2903":"prefix","2904":"A prefix to be added to the name of the {1567/} and queues.","2905":"Default: \"\".","2906":"recoveryInterval","2907":"The interval between connection recovery attempts, in milliseconds.","2908":"Default: {1568/}.","2909":"requeueRejected","2910":"Whether delivery failures should be requeued when retry is disabled or republishToDlq is false.","2911":"Default: {1569/}.","2912":"republishDeliveryMode","2913":"When {1570/} is {1571/}, specify the delivery mode of the republished message.","2914":"Default: {1572/}","2915":"republishToDlq","2916":"By default, messages which fail after retries are exhausted are rejected.","2917":"If a dead-letter queue (DLQ) is configured, {45/} will route the failed message (unchanged) to the DLQ.","2918":"If set to {1573/}, the binder will republish failed messages to the DLQ with additional headers, including the exception message and stack trace from the cause of the final failure.","2919":"Default: false","2920":"transacted","2921":"Whether to use transacted channels.","2922":"Default: {1574/}.","2923":"ttl","2924":"default time to live to apply to the queue when declared (ms)","2925":"Default: {1575/}","2926":"txSize","2927":"The number of deliveries between acks.","2928":"Default: {1576/}.","2929":"Rabbit Producer {31/}","2930":"The following properties are available for Rabbit producers only and\nmust be prefixed with {1577/}.","2931":"autoBindDlq","2932":"Whether to automatically declare the DLQ and bind it to the binder DLX.","2933":"Default: {1578/}.","2934":"batchingEnabled","2935":"Whether to enable message batching by producers.","2936":"Default: {1579/}.","2937":"batchSize","2938":"The number of messages to buffer when batching is enabled.","2939":"Default: {1580/}.","2940":"batchBufferLimit","2941":"Default: {1581/}.","2942":"batchTimeout","2943":"Default: {1582/}.","2944":"bindingRoutingKey","2945":"The routing key with which to bind the queue to the exchange (if {1583/} is {1584/}).","2946":"Only applies to non-partitioned destinations.","2947":"Only applies if {1585/} are provided and then only to those groups.","2948":"Default: {1586/}.","2949":"bindQueue","2950":"Whether to bind the queue to the destination exchange;","2951":"set to {1587/} if you have set up your own infrastructure and have previously created/bound the queue.","2952":"Only applies if {1588/} are provided and then only to those groups.","2953":"Default: {1589/}.","2954":"compress","2955":"Whether data should be compressed when sent.","2956":"Default: {1590/}.","2957":"deadLetterQueueName","2958":"name of the DLQ\nOnly applies if {1591/} are provided and then only to those groups.","2959":"Default: {1592/}","2960":"deadLetterExchange","2961":"a DLX to assign to the queue;","2962":"if autoBindDlq is true Only applies if {1593/} are provided and then only to those groups.","2963":"Default: 'prefix+DLX'","2964":"deadLetterRoutingKey","2965":"a dead letter routing key to assign to the queue;","2966":"if autoBindDlq is true Only applies if {1594/} are provided and then only to those groups.","2967":"Default: {1595/}","2968":"declareExchange","2969":"Whether to declare the exchange for the destination.","2970":"Default: {1596/}.","2971":"delay","2972":"A SpEL expression to evaluate the delay to apply to the message ({1597/} header) - has no effect if the exchange is not a delayed message exchange.","2973":"Default: No {1598/} header is set.","2974":"delayedExchange","2975":"Whether to declare the exchange as a {1599/} - requires the delayed message exchange plugin on the broker.","2976":"The {1600/} argument is set to the {1601/}.","2977":"Default: {1602/}.","2978":"deliveryMode","2979":"Delivery mode.","2980":"Default: {1603/}.","2981":"dlqDeadLetterExchange","2982":"if a DLQ is declared, a DLX to assign to that queue\nOnly applies if {1604/} are provided and then only to those groups.","2983":"Default: {1605/}","2984":"dlqDeadLetterRoutingKey","2985":"if a DLQ is declared, a dead letter routing key to assign to that queue;","2986":"default none Only applies if {1606/} are provided and then only to those groups.","2987":"Default: {1607/}","2988":"dlqExpires","2989":"how long before an unused dead letter queue is deleted (ms)\nOnly applies if {1608/} are provided and then only to those groups.","2990":"Default: {1609/}","2991":"dlqMaxLength","2992":"maximum number of messages in the dead letter queue\nOnly applies if {1610/} are provided and then only to those groups.","2993":"Default: {1611/}","2994":"dlqMaxLengthBytes","2995":"maximum number of total bytes in the dead letter queue from all messages\nOnly applies if {1612/} are provided and then only to those groups.","2996":"Default: {1613/}","2997":"dlqMaxPriority","2998":"maximum priority of messages in the dead letter queue (0-255)\nOnly applies if {1614/} are provided and then only to those groups.","2999":"Default: {1615/}","3000":"dlqTtl","3001":"default time to live to apply to the dead letter queue when declared (ms)\nOnly applies if {1616/} are provided and then only to those groups.","3002":"Default: {1617/}","3003":"exchangeAutoDelete","3004":"If {1618/} is true, whether the exchange should be auto-delete (removed after the last queue is removed).","3005":"Default: {1619/}.","3006":"exchangeDurable","3007":"If {1620/} is true, whether the exchange should be durable (survives broker restart).","3008":"Default: {1621/}.","3009":"exchangeType","3010":"The exchange type;","3011":"{1622/}, {1623/} or {1624/} for non-partitioned destinations;","3012":"{1625/} or {1626/} for partitioned destinations.","3013":"Default: {1627/}.","3014":"expires","3015":"how long before an unused queue is deleted (ms)\nOnly applies if {1628/} are provided and then only to those groups.","3016":"Default: {1629/}","3017":"headerPatterns","3018":"Patterns for headers to be mapped to outbound messages.","3019":"Default: {1630/} (all headers).","3020":"maxLength","3021":"maximum number of messages in the queue\nOnly applies if {1631/} are provided and then only to those groups.","3022":"Default: {1632/}","3023":"maxLengthBytes","3024":"maximum number of total bytes in the queue from all messages\nOnly applies if {1633/} are provided and then only to those groups.","3025":"Default: {1634/}","3026":"maxPriority","3027":"maximum priority of messages in the queue (0-255)\nOnly applies if {1635/} are provided and then only to those groups.","3028":"Default","3029":"prefix","3030":"A prefix to be added to the name of the {1636/} exchange.","3031":"Default: \"\".","3032":"routingKeyExpression","3033":"A SpEL expression to determine the routing key to use when publishing messages.","3034":"Default: {1637/} or {1638/} for partitioned destinations.","3035":"transacted","3036":"Whether to use transacted channels.","3037":"Default: {1639/}.","3038":"ttl","3039":"default time to live to apply to the queue when declared (ms)\nOnly applies if {1640/} are provided and then only to those groups.","3040":"Default: {1641/}","3041":"Note","3042":"In the case of {45/}, content type headers can be set by external applications.","3043":"{22/} Stream supports them as part of an extended internal protocol used for any type of transport (including transports, such as {58/}, that do not normally support headers).","3044":"Retry With the {18/}","3045":"Overview","3046":"When retry is enabled within the binder, the listener container thread is suspended for any back off periods that are configured.","3047":"This might be important when strict ordering is required with a single consumer but for other use cases it prevents other messages from being processed on that thread.","3048":"An alternative to using binder retry is to set up dead lettering with time to live on the dead-letter queue (DLQ), as well as dead-letter configuration on the DLQ itself.","3049":"See {18/} {31/} for more information about the properties discussed here.","3050":"Example configuration to enable this feature:","3051":"Set {1642/} to {1643/} - the binder will create a DLQ;","3052":"you can optionally specify a name in {1644/}","3053":"Set {1645/} to the back off time you want to wait between redeliveries","3054":"Set the {1646/} to the default exchange - expired messages from the DLQ will be routed to the original queue since the default {1647/} is the queue name ({1648/})","3055":"To force a message to be dead-lettered, either throw an {1649/}, or set {1650/} to {1651/} and throw any exception.","3056":"The loop will continue without end, which is fine for transient problems but you may want to give up after some number of attempts.","3057":"Fortunately, {45/} provides the {1652/} header which allows you to determine how many cycles have occurred.","3058":"To acknowledge a message after giving up, throw an {1653/}.","3059":"Putting it All Together","3060":"This configuration creates an exchange {1654/} with queue {1655/} bound to a topic exchange with a wildcard routing key {1656/}.","3061":"It creates a DLQ bound to a direct exchange {1657/} with routing key {1658/}.","3062":"When messages are rejected, they are routed to the DLQ.","3063":"After 5 seconds, the message expires and is routed to the original queue using the queue name as the routing key.","3064":"{19/} application","3065":"Notice that the count property in the {1659/} header is a {1660/}.","3066":"{7/} Queue Processing","3067":"Because it can't be anticipated how users would want to dispose of dead-lettered messages, the framework does not provide any standard mechanism to handle them.","3068":"If the reason for the dead-lettering is transient, you may wish to route the messages back to the original queue.","3069":"However, if the problem is a permanent issue, that could cause an infinite loop.","3070":"The following {1661/} application is an example of how to route those messages back to the original queue, but moves them to a third \"parking lot\" queue after three attempts.","3071":"The second example utilizes the {45/} Delayed Message Exchange to introduce a delay to the requeued message.","3072":"In this example, the delay increases for each attempt.","3073":"These examples use a {1662/} to receive messages from the DLQ, you could also use {1663/} in a batch process.","3074":"The examples assume the original destination is {1664/} and the consumer group is {1665/}.","3075":"Non-Partitioned Destinations","3076":"The first two examples are when the destination is not partitioned.","3077":"Partitioned Destinations","3078":"With partitioned destinations, there is one DLQ for all partitions and we determine the original queue from the headers.","3079":"republishToDlq=false","3080":"When {1666/} is {1667/}, {45/} publishes the message to the DLX/DLQ with an {1668/} header containing information about the original destination.","3081":"republishToDlq=true","3082":"When {1669/} is {1670/}, the republishing recoverer adds the original exchange and routing key to headers.","3084":"{9/} links nodes of a distributed system with a lightweight message broker.","3085":"This can then be used to broadcast state changes (eg configuration changes) or other management instructions.","3086":"A key idea is that the Bus is like a distributed Actuator for a {19/} application that is scaled out, but it can also be used as a communication channel between apps.","3087":"The only implementation currently is with an AMQP broker as the transport, but the same basic feature set (and some more depending on the transport) is on the roadmap for other transports.","3088":"Note","3089":"{22/} is released under the non-restrictive Apache 2.0 license.","3090":"If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at github .","3091":"Quick Start","3092":"{9/} works by adding {19/} autconfiguration if it detects itself on the classpath.","3093":"All you need to do to enable the bus is to add {1671/} or {1672/} to your dependency management and {22/} takes care of the rest.","3094":"Make sure the broker ({45/} or {58/}) is available and configured: running on localhost you shouldn't have to do anything, but if you are running remotely use {22/} Connectors, or {19/} conventions to define the broker credentials, eg for Rabbit","3095":"application.yml","3096":"The bus currently supports sending messages to all nodes listening or all nodes for a particular service (as defined by {62/}).","3097":"More selector criteria may be added in the future (ie. only service X nodes in data center Y, etc…).","3098":"There are also some http endpoints under the {1673/} actuator namespace.","3099":"There are currently two implemented.","3100":"The first, {1674/}, sends key/value pairs to update each node's {41/} Environment.","3101":"The second, {1675/}, will reload each application's configuration, just as if they had all been pinged on their {1676/} endpoint.","3102":"Note","3103":"\nThe Bus starters cover Rabbit and {58/}, because those are the two most common implementations, but {22/} Stream is quite flexible and binder will work combined with {1677/}.\n","3104":"Addressing an Instance","3105":"The HTTP endpoints accept a \"destination\" parameter, eg \"/bus/refresh?destination=customers:9000\", where the destination is an {1678/} ID.","3106":"If the ID is owned by an instance on the Bus then it will process the message and all other instances will ignore it.","3107":"{19/} sets the ID for you in the {1679/} to a combination of the {1680/}, active profiles and {1681/} by default.","3108":"Addressing all instances of a service","3109":"The \"destination\" parameter is used in a {41/} {1682/} (with the path separator as a colon {1683/}) to determine if an instance will process the message.","3110":"Using the example from above, \"/bus/refresh?destination=customers:**\" will target all instances of the \"customers\" service regardless of the profiles and ports set as the {1684/} ID.","3111":"Application Context ID must be unique","3112":"The bus tries to eliminate processing an event twice, once from the original {1685/} and once from the queue.","3113":"To do this, it checks the sending application context id againts the current application context id.","3114":"If multiple instances of a service have the same application context id, events will not be processed.","3115":"Running on a local machine, each service will be on a different port and that will be part of the application context id.","3116":"Cloud Foundry supplies an index to differentiate.","3117":"To ensure that the application context id is the unique, set {1686/} to something unique for each instance of a service.","3118":"For example, in lattice, set {1687/} in application.properties (or bootstrap.properties if using configserver).","3119":"Customizing the Message Broker","3120":"{9/} uses {22/} Stream to broadcast the messages so to get messages to flow you only need to include the binder implementation of your choice in the classpath.","3121":"There are convenient starters specifically for the bus with AMQP ({45/}) and {58/} ({1688/}).","3122":"Generally speaking {22/} Stream relies on {19/} autoconfiguration conventions for configuring middleware, so for instance the AMQP broker address can be changed with {1689/} configuration properties.","3123":"{9/} has a handful of native configuration properties in {1690/} (eg {1691/} is the name of the topic to use the the externall middleware).","3124":"Normally the defaults will suffice.","3125":"To lean more about how to customize the message broker settings\nconsult the {22/} Stream documentation.","3126":"Tracing {33/}","3127":"Bus events (subclasses of {1692/}) can be traced by setting {1693/}.","3128":"If you do this then the {19/} {1694/} (if it is present) will show each event sent and all the acks from each service instance.","3129":"Example (from the {1695/} endpoint):","3130":"This trace shows that a {1696/} was sent from\n{1697/}, broadcast to all services, and it was received\n(acked) by {1698/} and {1699/}.","3131":"To handle the ack signals yourself you could add an {1700/} for the {1701/} and {1702/} types to your app (and enable tracing).","3132":"Or you could tap into the {1703/} and mine the data from there.","3133":"Note","3134":"Any Bus application can trace acks, but sometimes it will be useful to do this in a central service that can do more complex queries on the data.","3135":"Or forward it to a specialized tracing service.","3136":"Broadcasting Your Own {39/}","3137":"The Bus can carry any event of type {1704/}, but the default transport is JSON and the deserializer needs to know which types are going to be used ahead of time.","3138":"To register a new type it needs to be in a subpackage of {1705/}.","3139":"To customise the event name you can use {1706/} on your custom class or rely on the default strategy which is to use the simple name of the class.","3140":"Note that both the producer and the consumer will need access to the class definition.","3141":"Registering events in custom packages","3142":"If you cannot or don't want to use a subpackage of {1707/} for your custom events, you must specify which packages to scan for events of type {1708/} using {1709/}.","3143":"Packages specified with {1710/} include subpackages.","3144":"For example, if you have a custom event called {1711/}:","3145":"you can register this event with the deserializer in the following way:","3146":"Without specifying a value, the package of the class where {1712/} is used will be registered.","3147":"In this example {1713/} will be registered using the package of {1714/}.","3148":"You can also explicitly specify the packages to scan using the {1715/}, {1716/} or {1717/} properties on {1718/}.","3149":"For example:","3150":"All examples of {1719/} above are equivalent, in that the {1720/} package will be registered by explicitly specifying the packages on {1721/}.","3151":"Note, you can specify multiple base packages to scan.","3152":"{22/} Sleuth","3153":"Adrian Cole, Spencer Gibb, Marcin Grzejszczak, Dave Syer","3154":"Dalston.RELEASE","3155":"{22/} Sleuth implements a distributed tracing solution for {22/}.","3156":"Terminology","3157":"{22/} Sleuth borrows Dapper’s terminology.","3158":"{59/}: The basic unit of work.","3159":"For example, sending an RPC is a new span, as is sending a response to an RPC.","3160":"{59/}'s are identified by a unique 64-bit ID for the span and another 64-bit ID for the trace the span is a part of.","3161":"Spans also have other data, such as descriptions, timestamped events, key-value annotations (tags), the ID of the span that caused them, and process ID's (normally IP address).","3162":"Spans are started and stopped, and they keep track of their timing information.","3163":"Once you create a span, you must stop it at some point in the future.","3164":"Tip","3165":"The initial span that starts a trace is called a {1722/}.","3166":"The value of span id of that span is equal to trace id.","3167":"Trace: A set of {61/} forming a tree-like structure.","3168":"For example, if you are running a distributed big-data store, a trace might be formed by a put request.","3169":"Annotation: is used to record existence of an event in time.","3170":"Some of the core annotations used to define the start and stop of a request are:","3171":"cs - Client Sent - The client has made a request.","3172":"This annotation depicts the start of the span.","3173":"sr - Server Received - The server side got the request and will start processing it.","3174":"If one subtracts the cs timestamp from this timestamp one will receive the network latency.","3175":"ss - Server Sent - Annotated upon completion of request processing (when the response got sent back to the client).","3176":"If one subtracts the sr timestamp from this timestamp one will receive the time needed by the server side to process the request.","3177":"cr - Client Received - Signifies the end of the span.","3178":"The client has successfully received the response from the server side.","3179":"If one subtracts the cs timestamp from this timestamp one will receive the whole time needed by the client to receive the response from the server.","3180":"Visualization of what {59/} and Trace will look in a system together with the {46/} annotations:","3181":"Each color of a note signifies a span (7 {61/} - from A to G ).","3182":"If you have such information in the note:","3183":"That means that the current span has Trace-Id set to X , {59/}-Id set to D .","3184":"It also has emitted Client Sent event.","3185":"This is how the visualization of the parent / child relationship of {61/} would look like:","3186":"Purpose","3187":"In the following sections the example from the image above will be taken into consideration.","3188":"Distributed tracing with {46/}","3189":"Altogether there are 7 {61/} .","3190":"If you go to traces in {46/} you will see this number in the second trace:","3191":"However if you pick a particular trace then you will see 4 {61/}:","3192":"Note","3193":"When picking a particular trace you will see merged {61/}.","3194":"That means that if there were 2 {61/} sent to {46/} with Server Received and Server Sent / Client Received and Client Sent annotations then they will presented as a single span.","3195":"Why is there a difference between the 7 and 4 {61/} in this case?","3196":"2 {61/} come from {1723/} span.","3197":"It has the Server Received (SR) and Server Sent (SS) annotations.","3198":"2 {61/} come from the RPC call from {1724/} to {1725/} to the {1726/} endpoint.","3199":"It has the Client Sent (CS) and Client Received (CR) annotations on {1727/} side.","3200":"It also has Server Received (SR) and Server Sent (SS) annotations on the {1728/} side.","3201":"Physically there are 2 {61/} but they form 1 logical span related to an RPC call.","3202":"2 {61/} come from the RPC call from {1729/} to {1730/} to the {1731/} endpoint.","3203":"It has the Client Sent (CS) and Client Received (CR) annotations on {1732/} side.","3204":"It also has Server Received (SR) and Server Sent (SS) annotations on the {1733/} side.","3205":"Physically there are 2 {61/} but they form 1 logical span related to an RPC call.","3206":"2 {61/} come from the RPC call from {1734/} to {1735/} to the {1736/} endpoint.","3207":"It has the Client Sent (CS) and Client Received (CR) annotations on {1737/} side.","3208":"It also has Server Received (SR) and Server Sent (SS) annotations on the {1738/} side.","3209":"Physically there are 2 {61/} but they form 1 logical span related to an RPC call.","3210":"So if we count the physical {61/} we have 1 from {1739/}, 2 from {1740/} calling {1741/}, 2 form {1742/} calling {1743/} and 2 from {1744/} calling {1745/}.","3211":"Altogether 7 {61/}.","3212":"Logically we see the information of Total Spans: 4 because we have 1 span related to the incoming request\nto {1746/} and 3 {61/} related to RPC calls.","3213":"Visualizing errors","3214":"{46/} allows you to visualize errors in your trace.","3215":"When an exception was thrown and wasn't caught then we're setting proper tags on the span which {46/} can properly colorize.","3216":"You could see in the list of traces one trace that was in red color.","3217":"That's because there was an exception thrown.","3218":"If you click that trace then you’ll see a similar picture","3219":"Then if you click on one of the {61/} you’ll see the following","3220":"As you can see you can easily see the reason for an error and the whole stacktrace related to it.","3221":"Live examples","3222":"Click Pivotal Web Services icon to see it live!Click Pivotal Web Services icon to see it live!","3223":"The dependency graph in {46/} would look like this:","3224":"Click Pivotal Web Services icon to see it live!Click Pivotal Web Services icon to see it live!","3225":"Log correlation","3226":"When grepping the logs of those four applications by trace id equal to e.g. {1747/} one would get the following:","3227":"If you're using a log aggregating tool like Kibana , Splunk etc. you can order the events that took place.","3228":"An example of Kibana would look like this:","3229":"If you want to use Logstash here is the Grok pattern for Logstash:","3230":"Note","3231":"\nIf you want to use Grok together with the logs from Cloud Foundry you have to use this pattern:\n","3232":"JSON Logback with Logstash","3233":"Often you do not want to store your logs in a text file but in a JSON file that Logstash can immediately pick.","3234":"To do that you have to do the following (for readability we're passing the dependencies in the {1748/} notation.","3235":"Dependencies setup","3236":"Ensure that Logback is on the classpath ({1749/})","3237":"Add Logstash Logback encode - example for version {1750/} : {1751/}","3238":"Logback setup","3239":"Below you can find an example of a Logback configuration (file named logback-spring.xml) that:","3240":"logs information from the application in a JSON format to a {1752/} file","3241":"has commented out two additional appenders - console and standard log file","3242":"has the same logging pattern as the one presented in the previous section","3243":"Note","3244":"If you're using a custom {1753/} then you have to pass the {1754/} in {1755/} instead of {1756/} property file.","3245":"Otherwise your custom logback file won't read the property properly.","3246":"Propagating {59/} Context","3247":"The span context is the state that must get propagated to any child Spans across process boundaries.","3248":"Part of the {59/} Context is the Baggage.","3249":"The trace and span IDs are a required part of the span context.","3250":"Baggage is an optional part.","3251":"Baggage is a set of key:value pairs stored in the span context.","3252":"Baggage travels together with the trace and is attached to every span.","3253":"{22/} Sleuth will understand that a header is baggage related if the HTTP header is prefixed with {1757/} and for messaging it starts with {1758/}.","3254":"Important","3255":"There's currently no limitation of the count or size of baggage items.","3256":"However, keep in mind that too many can decrease system throughput or increase RPC latency.","3257":"In extreme cases, it could crash the app due to exceeding transport-level message or header capacity.","3258":"Example of setting baggage on a span:","3259":"Baggage vs. {59/} Tags","3260":"Baggage travels with the trace (ie every child span contains the baggage of its parent).","3261":"{46/} has no knowledge of baggage and will not even receive that information.","3262":"Tags are attached to a specific span - they are presented for that particular span only.","3263":"However you can search by tag to find the trace, where there exists a span having the searched tag value.","3264":"If you want to be able to lookup a span based on baggage, you should add corresponding entry as a tag in the root span.","3265":"Adding to the project","3266":"Only Sleuth (log correlation)","3267":"If you want to profit only from {22/} Sleuth without the {46/} integration just add\nthe {1759/} module to your project.","3268":"Maven","3269":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3270":"Add the dependency to {1760/}","3271":"Gradle","3272":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3273":"Add the dependency to {1761/}","3274":"Sleuth with {46/} via HTTP","3275":"If you want both Sleuth and {46/} just add the {1762/} dependency.","3276":"Maven","3277":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3278":"Add the dependency to {1763/}","3279":"Gradle","3280":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3281":"Add the dependency to {1764/}","3282":"Sleuth with {46/} via {22/} Stream","3283":"If you want both Sleuth and {46/} just add the {1765/} dependency.","3284":"Maven","3285":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3286":"Add the dependency to {1766/}","3287":"Add the dependency to {1767/} - that way all dependant dependencies will be downloaded","3288":"Add a binder (e.g. Rabbit binder) to tell {22/} Stream what it should bind to","3289":"Gradle","3290":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3291":"Add the dependency to {1768/}","3292":"Add the dependency to {1769/} - that way all dependant dependencies will be downloaded","3293":"Add a binder (e.g. Rabbit binder) to tell {22/} Stream what it should bind to","3294":"{22/} Sleuth Stream {46/} Collector","3295":"If you want to start a {22/} Sleuth Stream {46/} collector just add the {1770/}\ndependency","3296":"Maven","3297":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3298":"Add the dependency to {1771/}","3299":"Add the dependency to {1772/} - that way all dependant dependencies will be downloaded","3300":"Add a binder (e.g. Rabbit binder) to tell {22/} Stream what it should bind to","3301":"Gradle","3302":"In order not to pick versions by yourself it’s much better if you add the dependency management via\nthe {41/} BOM","3303":"Add the dependency to {1773/}","3304":"Add the dependency to {1774/} - that way all dependant dependencies will be downloaded","3305":"Add a binder (e.g. Rabbit binder) to tell {22/} Stream what it should bind to","3306":"and then just annotate your main class with {1775/} annotation:","3307":"Additional resources","3308":"Marcin Grzejszczak talking about {22/} Sleuth and {46/}","3309":"click here to see the video","3310":"Features","3311":"Adds trace and span ids to the Slf4J MDC, so you can extract all the logs from a given trace or span in a log aggregator.","3312":"Example logs:","3313":"notice the {1776/} entries from the MDC:","3314":"spanId - the id of a specific operation that took place","3315":"appname - the name of the application that logged the span","3316":"traceId - the id of the latency graph that contains the span","3317":"exportable - whether the log should be exported to {46/} or not.","3318":"When would you like the span not to be exportable?","3319":"In the case in which you want to wrap some operation in a {59/} and have it written to the logs only.","3320":"Provides an abstraction over common distributed tracing data models: traces, {61/} (forming a DAG), annotations, key-value annotations.","3321":"Loosely based on HTrace, but {46/} (Dapper) compatible.","3322":"Sleuth records timing information to aid in latency analysis.","3323":"Using sleuth, you can pinpoint causes of latency in your applications.","3324":"Sleuth is written to not log too much, and to not cause your production application to crash.","3325":"propagates structural data about your call-graph in-band, and the rest out-of-band.","3326":"includes opinionated instrumentation of layers such as HTTP","3327":"includes sampling policy to manage volume","3328":"can report to a {46/} system for query and visualization","3329":"Instruments common ingress and egress points from {41/} applications (servlet filter, async endpoints,\nrest template, scheduled actions, message channels, zuul filters, feign client).","3330":"Sleuth includes default logic to join a trace across http or messaging boundaries.","3331":"For example, http propagation works via {46/}-compatible request headers.","3332":"This propagation logic is defined and customized via {1777/} and {1778/} implementations.","3333":"Sleuth gives you the possibility to propagate context (also known as baggage) between processes.","3334":"That means that if you set on a {59/} a baggage element then it will be sent downstream either via HTTP or messaging to other processes.","3335":"Provides a way to create / continue {61/} and add tags and logs via annotations.","3336":"Provides simple metrics of accepted / dropped {61/}.","3337":"If {1779/} then the app will generate and collect {46/}-compatible traces.","3338":"By default it sends them via HTTP to a {46/} server on localhost (port 9411).","3339":"Configure the location of the service using {1780/}.","3340":"If {1781/} then the app will generate and collect traces via {22/} Stream .","3341":"Your app automatically becomes a producer of tracer messages that are sent over your broker of choice (eg {45/}, Apache {58/}, Redis).","3342":"Important","3343":"If using {46/} or Stream, configure the percentage of {61/} exported using {1782/} (default 0.1, ie 10%).","3344":"Otherwise you might think that Sleuth is not working cause it's omitting some {61/}.","3345":"Note","3346":"the SLF4J MDC is always set and logback users will immediately see the trace and span ids in logs per the example above.","3347":"Other logging systems have to configure their own formatter to get the same result.","3348":"The default is {1783/} set to {1784/} (this is a {19/} feature for logback users).","3349":"This means that if you're not using SLF4J this pattern WILL NOT be automatically applied .","3350":"Sampling","3351":"In distributed tracing the data volumes can be very high so sampling can be important (you usually don't need to export all {61/} to get a good picture of what is happening).","3352":"{22/} Sleuth has a {1785/} strategy that you can implement to take control of the sampling algorithm.","3353":"Samplers do not stop span (correlation) ids from being generated, but they do prevent the tags and events being attached and exported.","3354":"By default you get a strategy that continues to trace if a span is already active, but new ones are always marked as non-exportable.","3355":"If all your apps run with this sampler you will see traces in logs, but not in any remote store.","3356":"For testing the default is often enough, and it probably is all you need if you are only using the logs (eg with an ELK aggregator).","3357":"If you are exporting span data to {46/} or {22/} Stream, there is also an {1786/} that exports everything and a {1787/} that samples a fixed fraction of {61/}.","3358":"Note","3359":"the {1788/} is the default if you are using {1789/} or {1790/}.","3360":"You can configure the exports using {1791/}.","3361":"The passed value needs to be a double from {1792/} to {1793/} so it's not a percentage.","3362":"For backwards compatibility reasons we're not changing the property name.","3363":"A sampler can be installed just by creating a bean definition, e.g:","3364":"Tip","3365":"You can set the HTTP header {1794/} to {1795/} or when doing messaging you can set {1796/} header to {1797/}.","3366":"Then the current span will be forced to be exportable regardless of the sampling decision.","3367":"Instrumentation","3368":"{22/} Sleuth instruments all your {41/} application automatically, so you shouldn't have to do anything to activate it.","3369":"The instrumentation is added using a variety of technologies according to the stack that is available, eg for a servlet web application we use a {1798/}, and for {20/} we use {1799/}.","3370":"You can customize the keys used in span tags.","3371":"To limit the volume of span data, by default an HTTP request will be tagged only with a handful of metadata like the status code, host and URL.","3372":"You can add request headers by configuring {1800/} (a list of header names).","3373":"Note","3374":"\nRemember that tags are only collected and exported if there is a\n{1801/} that allows it (by default there is not, so there is no\ndanger of accidentally collecting too much data without configuring\nsomething).\n","3375":"Note","3376":"Currently the instrumentation in {22/} Sleuth is eager - it means that we're actively trying to pass the tracing context between threads.","3377":"Also timing events are captured even when sleuth isn't exporting data to a tracing system.","3378":"This approach may change in the future towards being lazy on this matter.","3379":"{59/} lifecycle","3380":"You can do the following operations on the {59/} by means of org.springframework.cloud.sleuth.Tracer interface:","3381":"start - when you start a span its name is assigned and start timestamp is recorded.","3382":"close - the span gets finished (the end time of the span is recorded) and if the span is exportable then it will be eligible for collection to {46/}.","3383":"The span is also removed from the current thread.","3384":"continue - a new instance of span will be created whereas it will be a copy of the\none that it continues.","3385":"detach - the span doesn't get stopped or closed.","3386":"It only gets removed from the current thread.","3387":"create with explicit parent - you can create a new span and set an explicit parent to it","3388":"Tip","3389":"{41/} creates the instance of {1802/} for you.","3390":"In order to use it all you need is to just autowire it.","3391":"Creating and closing {61/}","3392":"You can manually create {61/} by using the Tracer interface.","3393":"In this example we could see how to create a new instance of span.","3394":"Assuming that there already was a span present in this thread then it would become the parent of that span.","3395":"Important","3396":"Always clean after you create a span!","3397":"Don't forget to close a span if you want to send it to {46/}.","3398":"Important","3399":"If your span contains a name greater than 50 chars, then that name will be truncated to 50 chars.","3400":"Your names have to be explicit and concrete.","3401":"Big names lead to latency issues and sometimes even thrown exceptions.","3402":"Continuing {61/}","3403":"Sometimes you don't want to create a new span but you want to continue one.","3404":"Example of such a situation might be (of course it all depends on the use-case):","3405":"AOP - If there was already a span created before an aspect was reached then you might not want to create a new span.","3406":"{47/} - executing a {47/} command is most likely a logical part of the current processing.","3407":"It's in fact only a technical implementation detail that you wouldn't necessarily want to reflect in tracing as a separate being.","3408":"The continued instance of span is equal to the one that it continues:","3409":"To continue a span you can use the Tracer interface.","3410":"Important","3411":"Always clean after you create a span!","3412":"Don't forget to detach a span if some work was done started in one thread (eg thread X) and it's waiting for other threads (eg Y, Z) to finish.","3413":"Then the {61/} in the threads Y, Z should be detached at the end of their work.","3414":"When the results are collected the span in thread X should be closed.","3415":"Creating {61/} with an explicit parent","3416":"There is a possibility that you want to start a new span and provide an explicit parent of that span.","3417":"Let's assume that the parent of a span is in one thread and you want to start a new span in another thread.","3418":"The {1803/} method of the {1804/} interface is the method you are looking for.","3419":"Important","3420":"After having created such a span remember to close it.","3421":"Otherwise you will see a lot of warnings in your logs related to the fact that you have a span present in the current thread other than the one you're trying to close.","3422":"What's worse your {61/} won't get closed properly thus will not get collected to {46/}.","3423":"Naming {61/}","3424":"Picking a span name is not a trivial task.","3425":"{59/} name should depict an operation name.","3426":"The name should be low cardinality (eg not include identifiers).","3427":"Since there is a lot of instrumentation going on some of the span names will be\nartificial like:","3428":"{1805/} when received by a Controller with a method name {1806/}","3429":"{1807/} for asynchronous operations done via wrapped {1808/} and {1809/}.","3430":"{1810/} annotated methods will return the simple name of the class.","3431":"Fortunately, for the asynchronous processing you can provide explicit naming.","3432":"@SpanName annotation","3433":"You can name the span explicitly via the {1811/} annotation.","3434":"In this case, when processed in the following manner:","3435":"The span will be named {1812/}.","3436":"toString() method","3437":"It's pretty rare to create separate classes for {1813/} or {1814/}.","3438":"Typically one creates an anonymous instance of those classes.","3439":"You can't annotate such classes thus to override that, if there is no {1815/} annotation present, we're checking if the class has a custom implementation of the {1816/} method.","3440":"So executing such code:","3441":"will lead in creating a span named {1817/}.","3442":"Managing {61/} with annotations","3443":"Rationale","3444":"The main arguments for this features are","3445":"api-agnostic means to collaborate with a span","3446":"use of annotations allows users to add to a span with no library dependency on a span api.","3447":"This allows Sleuth to change its core api less impact to user code.","3448":"reduced surface area for basic span operations.","3449":"without this feature one has to use the span api, which has lifecycle commands that could be used incorrectly.","3450":"By only exposing scope, tag and log functionality, users can collaborate without accidentally breaking span lifecycle.","3451":"collaboration with runtime generated code","3452":"with libraries such as {41/} Data / {55/} the implementations of interfaces are generated at runtime thus span wrapping of objects was tedious.","3453":"Now you can provide annotations over interfaces and arguments of those interfaces","3454":"Creating new {61/}","3455":"If you really don't want to take care of creating local {61/} manually you can profit from the {1818/} annotation.","3456":"Also we give you the {1819/} annotation to add tags in an automated fashion.","3457":"Let’s look at some examples of usage.","3458":"Annotating the method without any parameter will lead to a creation of a new span whose name\nwill be equal to annotated method name.","3459":"If you provide the value in the annotation (either directly or via the {1820/} parameter) then\nthe created span will have the name as the provided value.","3460":"You can combine both the name and a tag.","3461":"Let's focus on the latter.","3462":"In this case whatever the value of the annotated method's parameter runtime value will be - that will be the value of the tag.","3463":"In our sample the tag key will be {1821/} and the tag value will be {1822/}.","3464":"You can place the {1823/} annotation on both the class and an interface.","3465":"If you override the interface's method and provide a different value of the {1824/} annotation then the most concrete one wins (in this case {1825/} will be set).","3466":"Continuing {61/}","3467":"If you want to just add tags and annotations to an existing span it's enough to use the {1826/} annotation as presented below.","3468":"Note that in contrast with the {1827/} annotation you can also add logs via the {1828/} parameter:","3469":"That way the span will get continued and:","3470":"logs with name {1829/} and {1830/} will be created","3471":"if an exception will be thrown a log {1831/} will also be created","3472":"tag with key {1832/} and value {1833/} will be created","3473":"More advanced tag setting","3474":"There are 3 different ways to add tags to a span.","3475":"All of them are controlled by the {1834/} annotation.","3476":"Precedence is:","3477":"try with the bean of {1835/} type and provided name","3478":"if one hasn't provided the bean name, try to evaluate an expression.","3479":"We're searching for a {1836/} bean.","3480":"The default implementation uses SPEL expression resolution.","3481":"if one hasn’t provided any expression to evaluate just return a {1837/} value of the parameter","3482":"Custom extractor","3483":"The value of the tag for following method will be computed by an implementation of {1838/} interface.","3484":"Its class name has to be passed as the value of the {1839/} attribute.","3485":"Having such an annotated method:","3486":"and such a {1840/} bean implementation","3487":"Will lead to setting of a tag value equal to {1841/}.","3488":"Resolving expressions for value","3489":"Having such an annotated method:","3490":"and no custom implementation of a {1842/} will lead to evaluation of the SPEL expression and a tag with value {1843/} will be set on the span.","3491":"If you want to use some other expression resolution mechanism you can create your own implementation of the bean.","3492":"Using toString method","3493":"Having such an annotated method:","3494":"if executed with a value of {1844/} will lead to setting of a tag with a String value of {1845/}.","3495":"Customizations","3496":"Thanks to the {1846/} and {1847/} you can customize the way {61/}\nare created and propagated.","3497":"There are currently two built-in ways to pass tracing information between processes:","3498":"via {20/}","3499":"via HTTP","3500":"{59/} ids are extracted from {46/}-compatible (B3) headers (either {1848/} or HTTP headers), to start or join an existing trace.","3501":"Trace information is injected into any outbound requests so the next hop can extract them.","3502":"The key change in comparison to the previous versions of Sleuth is that Sleuth is implementing the Open Tracing's {1849/} notion.","3503":"In Sleuth it's called {1850/}.","3504":"Basically the idea is that any means of communication (eg message, http request, etc.) can be abstracted via a {1851/}.","3505":"This abstraction defines how one can insert data into the carrier and how to retrieve it from there.","3506":"Thanks to this if you want to instrument a new HTTP library that uses a {1852/} as a mean of sending HTTP requests then you have to create an implementation of a {1853/} that delegates calls to {1854/} in terms of retrieval and insertion of HTTP headers.","3508":"For {20/} there are 2 interfaces responsible for creation of a {59/} from a {1855/}.","3509":"These are:","3510":"You can override them by providing your own implementation.","3511":"HTTP","3512":"For HTTP there are 2 interfaces responsible for creation of a {59/} from a {1856/}.","3513":"These are:","3514":"You can override them by providing your own implementation.","3515":"Example","3516":"Let’s assume that instead of the standard {46/} compatible tracing HTTP header names\nyou have","3517":"for trace id - {1857/}","3518":"for span id - {1858/}","3519":"This is a an example of a {1859/}","3520":"And you could register it like this:","3521":"{22/} Sleuth does not add trace/span related headers to the Http Response for security reasons.","3522":"If you need the headers then a custom {1860/} that injects the headers into the Http Response and a Servlet filter which makes use of this can be added the following way:","3523":"And you could register them like this:","3524":"Custom SA tag in {46/}","3525":"Sometimes you want to create a manual {59/} that will wrap a call to an external service which is not instrumented.","3526":"What you can do is to create a span with the {1861/} tag that will contain a value of the service that you want to call.","3527":"Below you can see an example of a call to Redis that is wrapped in such a span.","3528":"Important","3529":"Remember not to add both {1862/} tag and the {1863/} tag!","3530":"You have to add only {1864/}.","3531":"Custom service name","3532":"By default Sleuth assumes that when you send a span to {46/}, you want the span's service name to be equal to {1865/} value.","3533":"That's not always the case though.","3534":"There are situations in which you want to explicitly provide a different service name for all {61/} coming from your application.","3535":"To achieve that it's enough to just pass the following property to your application to override that value (example for {1866/} service name):","3536":"Host locator","3537":"In order to define the host that is corresponding to a particular span we need to resolve the host name and port.","3538":"The default approach is to take it from server properties.","3539":"If those for some reason are not set then we're trying to retrieve the host name from the network interfaces.","3540":"If you have the discovery client enabled and prefer to retrieve the host address from the registered\ninstance in a service registry then you have to set the property (it’s applicable for both HTTP and\nStream based span reporting).","3541":"{52/} as Messages","3542":"You can accumulate and send span data over {22/} Stream by including the {1867/} jar as a dependency, and adding a Channel {48/} implementation (eg {1868/} for {45/} or {1869/} for {58/}).","3543":"This will automatically turn your app into a producer of messages with payload type {1870/}.","3544":"{46/} Consumer","3545":"There is a special convenience annotation for setting up a message consumer for the {59/} data and pushing it into a {46/} {1871/}.","3546":"This application","3547":"will listen for the {59/} data on whatever transport you provide via a {22/} Stream {1872/} (eg include {1873/} for {45/}, and similar starters exist for Redis and {58/}).","3548":"If you add the following UI dependency","3549":"Then you’ll have your app a\n{46/} server, which hosts\nthe UI and api on port 9411.","3550":"The default {1874/} is in-memory (good for demos and getting started quickly).","3551":"For a more robust solution you can add MySQL and {1875/} to your classpath and enable the JDBC {1876/} via configuration, eg:","3552":"Note","3553":"\nThe {1877/} is also annotated with\n{1878/} so the process will also expose the standard\n{46/} server endpoints for collecting {61/} over HTTP, and for\nquerying in the {46/} Web UI.\n","3554":"Custom Consumer","3555":"A custom consumer can also easily be implemented using {1879/} and binding to the {1880/}.","3556":"Example:","3557":"Note","3558":"\nthe sample consumer application above explicitly excludes\n{1881/} so it doesn’t send messages to itself,\nbut this is optional (you might actually want to trace requests into\nthe consumer app).\n","3559":"In order to customize the polling mechanism you can create a bean of {1882/} type with name equal to {1883/}.","3560":"Here you can find an example of such a configuration.","3561":"Metrics","3562":"Currently {22/} Sleuth registers very simple metrics related to {61/}.","3563":"It's using the {19/}'s metrics support to calculate the number of accepted and dropped {61/}.","3564":"Each time a span gets sent to {46/} the number of accepted {61/} will increase.","3565":"If there's an error then the number of dropped {61/} will get increased.","3566":"Integrations","3567":"Runnable and Callable","3568":"If you’re wrapping your logic in {1884/} or {1885/} it’s enough to wrap those classes in their Sleuth representative.","3569":"Example for {1886/}:","3570":"Example for {1887/}:","3571":"That way you will ensure that a new {59/} is created and closed for each execution.","3573":"Custom Concurrency Strategy","3574":"We're registering a custom that wraps all {1888/} instances into their Sleuth representative - the {1889/}.","3575":"The strategy either starts or continues a span depending on the fact whether tracing was already going on before the {47/} command was called.","3576":"To disable the custom {47/} Concurrency Strategy set the {1890/} to {1891/}.","3577":"Manual Command setting","3578":"Assuming that you have the following {1892/}:","3579":"In order to pass the tracing information you have to wrap the same logic in the Sleuth version of the {1893/} which is the\n{1894/}:","3580":"RxJava","3581":"We're registering a custom that wraps all {1895/} instances into their Sleuth representative - the {1896/}.","3582":"The hook either starts or continues a span depending on the fact whether tracing was already going on before the Action was scheduled.","3583":"To disable the custom RxJavaSchedulersHook set the {1897/} to {1898/}.","3584":"You can define a list of regular expressions for thread names, for which you don't want a {59/} to be created.","3585":"Just provide a comma separated list of regular expressions in the {1899/} property.","3586":"HTTP integration","3587":"Features from this section can be disabled by providing the {1900/} property with value equal to {1901/}.","3588":"HTTP Filter","3589":"Via the {1902/} all sampled incoming requests result in creation of a {59/}.","3590":"That {59/}'s name is {1903/} + the path to which the request was sent.","3591":"Eg if the request was sent to {1904/} then the name will be {1905/}.","3592":"You can configure which URIs you would like to skip via the {1906/} property.","3593":"If you have {1907/} on classpath then its value of {1908/} gets appended to the provided skip pattern.","3594":"HandlerInterceptor","3595":"Since we want the span names to be precise we're using a {1909/} that either wraps an existing {1910/} or is added directly to the list of existing {1911/}.","3596":"The {1912/} adds a special request attribute to the given {1913/}.","3597":"If the the {1914/} doesn't see this attribute set it will create a \"fallback\" span which is an additional span created on the server side so that the trace is presented properly in the UI.","3598":"Seeing that most likely signifies that there is a missing instrumentation.","3599":"In that case please file an issue in {22/} Sleuth.","3600":"Async Servlet support","3601":"If your controller returns a {1915/} or a {1916/} {22/} Sleuth will continue the existing span instead of creating a new one.","3602":"HTTP client integration","3603":"Synchronous Rest Template","3604":"We're injecting a {1917/} interceptor that ensures that all the tracing information is passed to the requests.","3605":"Each time a call is made a new {59/} is created.","3606":"It gets closed upon receiving the response.","3607":"In order to block the synchronous {1918/} features just set {1919/} to {1920/}.","3608":"Important","3609":"You have to register {1921/} as a bean so that the interceptors will get injected.","3610":"If you create a {1922/} instance with a {1923/} keyword then the instrumentation WILL NOT work.","3611":"Asynchronous Rest Template","3612":"Important","3613":"A traced version of an {1924/} bean is registered for you out of the box.","3614":"If you have your own bean you have to wrap it in a {1925/} representation.","3615":"The best solution is to only customize the {1926/} and / or {1927/}.","3616":"If you have your own {1928/} and you don't wrap it your calls WILL NOT GET TRACED .","3617":"Custom instrumentation is set to create and close Spans upon sending and receiving requests.","3618":"You can customize the {1929/} and the {1930/} by registering your beans.","3619":"Remember to use tracing compatible implementations (eg don't forget to wrap {1931/} in a {1932/}).","3620":"Example of custom request factories:","3621":"To block the {1933/} features set {1934/} to {1935/}.","3622":"To disable creation of the default {1936/} set {1937/} to {1938/}.","3623":"If you don't want to create {1939/} at all set {1940/} to {1941/}.","3625":"By default {22/} Sleuth provides integration with feign via the {1942/}.","3626":"You can disable it entirely by setting {1943/} to false.","3627":"If you do so then no {55/} related instrumentation will take place.","3628":"Part of {55/} instrumentation is done via a {1944/}.","3629":"You can disable it by providing the {1945/} equal to {1946/}.","3630":"If you set it like this then {22/} Sleuth will not instrument any of your custom {55/} components.","3631":"All the default instrumentation however will be still there.","3632":"Asynchronous communication","3633":"@Async annotated methods","3634":"In {22/} Sleuth we're instrumenting async related components so that the tracing information is passed between threads.","3635":"You can disable this behaviour by setting the value of {1947/} to {1948/}.","3636":"If you annotate your method with {1949/} then we’ll automatically create a new {59/} with the following characteristics:","3637":"the {59/} name will be the annotated method name","3638":"the {59/} will be tagged with that method’s class name and the method name too","3639":"@Scheduled annotated methods","3640":"In {22/} Sleuth we're instrumenting scheduled method execution so that the tracing information is passed between threads.","3641":"You can disable this behaviour by setting the value of {1950/} to {1951/}.","3642":"If you annotate your method with {1952/} then we’ll automatically create a new {59/} with the following characteristics:","3643":"the {59/} name will be the annotated method name","3644":"the {59/} will be tagged with that method’s class name and the method name too","3645":"If you want to skip {59/} creation for some {1953/} annotated classes you can set the\n{1954/} with a regular expression that will match the fully qualified name of the\n{1955/} annotated class.","3646":"Tip","3647":"If you are using {1956/} and {1957/} together, {59/} will be created for each {47/} metrics and sent to {46/}.","3648":"This may be annoying.","3649":"You can prevent this by setting {1958/}","3650":"Executor, ExecutorService and ScheduledExecutorService","3651":"We're providing {1959/}, {1960/} and {1961/}.","3652":"Those implementations are creating Spans each time a new task is submitted, invoked or scheduled.","3653":"Here you can see an example of how to pass tracing information with {1962/} when working with {1963/}:","3654":"Messaging","3655":"{22/} Sleuth integrates with {20/} .","3656":"It creates {61/} for publish and subscribe events.","3657":"To disable {20/} instrumentation, set {1964/} to false.","3658":"You can provide the {1965/} pattern to explicitly provide the names of channels that you want to include for tracing.","3659":"By default all channels are included.","3660":"Important","3661":"When using the {1966/} to build a {20/} {1967/} remember to use the untraced version of the {1968/}.","3662":"Decorating {20/} Executor Channel with {1969/} will cause the {61/} to be improperly closed.","3664":"We're registering {60/} filters to propagate the tracing information (the request header is enriched with tracing data).","3665":"To disable {60/} support set the {1970/} property to {1971/}.","3666":"Running examples","3667":"You can find the running examples deployed in the Pivotal Web Services .","3668":"Check them out in the following links:","3669":"{46/} for apps presented in the samples to the top","3670":"{46/} for Brewery on PWS, its Github Code","3672":"Dalston.RELEASE","3673":"This project provides {49/} integrations for {19/} apps through autoconfiguration and binding to the {41/} Environment and other {41/} programming model idioms.","3674":"With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with {49/} based components.","3675":"The patterns provided include Service Discovery, Control Bus and Configuration.","3676":"Intelligent Routing ({60/}) and Client Side Load Balancing ({43/}), Circuit Breaker ({47/}) are provided by integration with {5/}.","3677":"Install {49/}","3678":"Please see the installation documentation for instructions on how to install {49/}.","3680":"A {14/} client must be available to all {22/} {49/} applications.","3681":"By default, the Agent client is expected to be at {1972/}.","3682":"See the Agent documentation for specifics on how to start an Agent client and how to connect to a cluster of {14/} Servers.","3683":"For development, after you have installed consul, you may start a {14/} using the following command:","3684":"This will start an agent in server mode on port 8500, with the ui available at http://localhost:8500","3685":"Service Discovery with {49/}","3686":"Service Discovery is one of the key tenets of a microservice based architecture.","3687":"Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.","3688":"{49/} provides Service Discovery services via an HTTP API and DNS .","3689":"{22/} {49/} leverages the HTTP API for service registration and discovery.","3690":"This does not prevent non-{22/} applications from leveraging the DNS interface.","3691":"{49/} Agents servers are run in a cluster that communicates via a gossip protocol and uses the Raft consensus protocol .","3692":"How to activate","3693":"To activate {49/} Service Discovery use the starter with group {1973/} and artifact id {1974/}.","3694":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","3695":"Registering with {49/}","3696":"When a client registers with {49/}, it provides meta-data about itself such as host and port, id, name and tags.","3697":"An HTTP Check is created by default that {49/} hits the {1975/} endpoint every 10 seconds.","3698":"If the health check fails, the service instance is marked as critical.","3699":"Example {49/} client:","3700":"(ie utterly normal {19/} app).","3701":"If the {49/} client is located somewhere other than {1976/}, the configuration is required to locate the client.","3702":"Example:","3703":"application.yml","3704":"Caution","3705":"\nIf you use {22/} {49/} Config, the above values will need to be placed in {1977/} instead of {1978/}.\n","3706":"The default service name, instance id and port, taken from the {1979/}, are {1980/}, the {41/} Context ID and {1981/} respectively.","3707":"{1982/} make the app into both a {49/} \"service\" (i.e. it registers itself) and a \"client\" (i.e. it can query {49/} to locate other services).","3708":"HTTP Health Check","3709":"The health check for a {49/} instance defaults to \"/health\", which is the default locations of a useful endpoint in a {19/} Actuator application.","3710":"You need to change these, even for an Actuator application if you use a non-default context path or servlet path (eg {1983/}) or management endpoint path (eg {1984/}).","3711":"The interval that {49/} uses to check the health endpoint may also be configured.","3712":"\"10s\" and \"1m\" represent 10 seconds and 1 minute respectively.","3713":"Example:","3714":"application.yml","3715":"Metadata and {49/} tags","3716":"{49/} does not yet support metadata on services.","3717":"{22/}'s {1985/} has a {1986/} field.","3718":"{22/} {49/} uses {49/} tags to approximate metadata until {49/} officially supports metadata.","3719":"Tags with the form {1987/} will be split and used as a {1988/} key and value respectively.","3720":"Tags without the equal {1989/} sign, will be used as both the key and value.","3721":"application.yml","3722":"The above configuration will result in a map with {1990/} and {1991/}.","3723":"Making the {49/} Instance ID Unique","3724":"By default a consul instance is registered with an ID that is equal to its {41/} Application Context ID.","3725":"By default, the {41/} Application Context ID is {1992/}.","3726":"For most cases, this will allow multiple instances of one service to run on one machine.","3727":"If further uniqueness is required, Using {22/} you can override this by providing a unique identifier in {1993/}.","3728":"For example:","3729":"application.yml","3730":"With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique.","3731":"In Cloudfoundry the {1994/} will be populated automatically in a {19/} application, so the random value will not be needed.","3732":"Using the DiscoveryClient","3733":"{22/} has support for {55/} (a REST client builder) and also {41/} {1995/} using the logical service names instead of physical URLs.","3734":"You can also use the {1996/} which provides a simple API for discovery clients that is not specific to Netflix, e.g.","3735":"Distributed Configuration with {49/}","3736":"{49/} provides a Key/Value Store for storing configuration and other metadata.","3737":"{22/} {49/} Config is an alternative to the Config Server and Client .","3738":"Configuration is loaded into the {41/} Environment during the special \"bootstrap\" phase.","3739":"Configuration is stored in the {1997/} folder by default.","3740":"Multiple {1998/} instances are created based on the application's name and the active profiles that mimicks the {16/} order of resolving properties.","3741":"For example, an application with the name \"testApp\" and with the \"dev\" profile will have the following property sources created:","3742":"The most specific property source is at the top, with the least specific at the bottom.","3743":"{31/} is the {1999/} folder are applicable to all applications using consul for configuration.","3744":"{31/} in the {2000/} folder are only available to the instances of the service named \"testApp\".","3745":"Configuration is currently read on startup of the application.","3746":"Sending a HTTP POST to {2001/} will cause the configuration to be reloaded.","3747":"Watching the key value store (which {49/} supports) is not currently possible, but will be a future addition to this project.","3748":"How to activate","3749":"To get started with {49/} Configuration use the starter with group {2002/} and artifact id {2003/}.","3750":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","3751":"This will enable auto-configuration that will setup {22/} {49/} Config.","3752":"Customizing","3753":"{49/} Config may be customized using the following properties:","3754":"bootstrap.yml","3755":"{2004/} setting this value to \"false\" disables {49/} Config","3756":"{2005/} sets the base folder for configuration values","3757":"{2006/} sets the folder name used by all applications","3758":"{2007/} sets the value of the separator used to separate the profile name in property sources with profiles","3759":"Config Watch","3760":"The {49/} Config Watch takes advantage of the ability of consul to watch a key prefix .","3761":"The Config Watch makes a blocking {49/} HTTP API call to determine if any relevant configuration data has changed for the current application.","3762":"If there is new configuration data a Refresh Event is published.","3763":"This is equivalent to calling the {2008/} actuator endpoint.","3764":"To change the frequency of when the Config Watch is called change {2009/}.","3765":"The default value is 1000, which is in milliseconds.","3766":"To disable the Config Watch set {2010/}.","3767":"YAML or {31/} with Config","3768":"It may be more convenient to store a blob of properties in YAML or {31/} format as opposed to individual key/value pairs.","3769":"Set the {2011/} property to {2012/} or {2013/}.","3770":"For example to use YAML:","3771":"bootstrap.yml","3772":"YAML must be set in the appropriate {2014/} key in consul.","3773":"Using the defaults above the keys would look like:","3774":"You could store a YAML document in any of the keys listed above.","3775":"You can change the data key using {2015/}.","3776":"git2consul with Config","3777":"git2consul is a {49/} community project that loads files from a git repository to individual keys into {49/}.","3778":"By default the names of the keys are names of the files.","3779":"YAML and {31/} files are supported with file extensions of {2016/} and {2017/} respectively.","3780":"Set the {2018/} property to {2019/}.","3781":"For example:","3782":"bootstrap.yml","3783":"Given the following keys in {2020/}, the {2021/} profile and an application name of {2022/}:","3784":"the following property sources would be created:","3785":"The value of each key needs to be a properly formatted YAML or {31/} file.","3786":"Fail Fast","3787":"It may be convenient in certain circumstances (like local development or certain test scenarios) to not fail if consul isn't available for configuration.","3788":"Setting {2023/} in {2024/} will cause the configuration module to log a warning rather than throw an exception.","3789":"This will allow the application to continue startup normally.","3790":"{49/} Retry","3791":"If you expect that the consul agent may occasionally be unavailable when your app starts, you can ask it to keep trying after a failure.","3792":"You need to add {2025/} and {2026/} to your classpath.","3793":"The default behaviour is to retry 6 times with an initial backoff interval of 1000ms and an exponential multiplier of 1.1 for subsequent backoffs.","3794":"You can configure these properties (and others) using {2027/} configuration properties.","3795":"This works with both {22/} {49/} Config and Discovery registration.","3796":"Tip","3797":"To take full control of the retry add a {2028/} of type {2029/} with id \"consulRetryInterceptor\".","3798":"{41/} Retry has a {2030/} that makes it easy to create one.","3799":"{9/} with {49/}","3800":"How to activate","3801":"To get started with the {49/} Bus use the starter with group {2031/} and artifact id {2032/}.","3802":"See the {22/} Project page for details on setting up your build system with the current {22/} Release Train.","3803":"See the {9/} documentation for the available actuator endpoints and howto send custom messages.","3804":"Circuit Breaker with {47/}","3805":"Applications can use the {47/} Circuit Breaker provided by the {5/} project by including this starter in the projects pom.xml: {2033/}.","3806":"{47/} doesn't depend on the Netflix Discovery Client.","3807":"The {2034/} annotation should be placed on a configuration class (usually the main class).","3808":"Then methods can be annotated with {2035/} to be protected by a circuit breaker.","3809":"See the documentation for more details.","3810":"{47/} metrics aggregation with {50/} and {49/}","3811":"{50/} (provided by the {5/} project), aggregates multiple instances {47/} metrics streams, so the dashboard can display an aggregate view.","3812":"{50/} uses the {2036/} interface to lookup relevant instances.","3813":"To use {50/} with {22/} {49/}, configure the {50/} application in a manner similar to the following examples:","3814":"pom.xml","3815":"Notice that the {50/} dependency is not a starter.","3816":"The turbine starter includes support for Netflix {62/}.","3817":"application.yml","3818":"The {2037/} and {2038/} sections must match, so it’s useful to put the comma-separated list of service ID’s into a separate configuration property.","3819":"{50/}.java","3821":"This project provides {37/} integrations for {19/} apps through autoconfiguration and binding to the {41/} Environment and other {41/} programming model idioms.","3822":"With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with {37/} based components.","3823":"The patterns provided include Service Discovery and Configuration.","3824":"Intelligent Routing ({60/}) and Client Side Load Balancing ({43/}), Circuit Breaker ({47/}) are provided by integration with {5/}.","3825":"Install {37/}","3826":"Please see the installation documentation for instructions on how to install {37/}.","3827":"Service Discovery with {37/}","3828":"Service Discovery is one of the key tenets of a microservice based architecture.","3829":"Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle.","3830":"Curator (A java library for {37/}) provides Service Discovery services via Service Discovery Extension .","3831":"{1/} leverages this extension for service registration and discovery.","3832":"How to activate","3833":"Including a dependency on {2039/} will enable auto-configuration that will setup {1/} Discovery.","3834":"Note","3835":"\nYou still need to include {2040/} for web functionality.\n","3836":"Registering with {37/}","3837":"When a client registers with {37/}, it provides meta-data about itself such as host and port, id and name.","3838":"Example {37/} client:","3839":"(ie utterly normal {19/} app).","3840":"If {37/} is located somewhere other than {2041/}, the configuration is required to locate the server.","3841":"Example:","3842":"application.yml","3843":"Caution","3844":"\nIf you use {1/} Config, the above values will need to be placed in {2042/} instead of {2043/}.\n","3845":"The default service name, instance id and port, taken from the {2044/}, are {2045/}, the {41/} Context ID and {2046/} respectively.","3846":"{2047/} makes the app into both a {37/} \"service\" (i.e. it registers itself) and a \"client\" (i.e. it can query {37/} to locate other services).","3847":"Using the DiscoveryClient","3848":"{22/} has support for {55/} (a REST client builder) and also {41/} {2048/} using the logical service names instead of physical URLs.","3849":"You can also use the {2049/} which provides a simple API for discovery clients that is not specific to Netflix, e.g.","3850":"Using {1/} with {5/} Components","3851":"{5/} supplies useful tools that work regardless of which {2050/} implementation is used.","3852":"{55/}, {50/}, {43/} and {60/} all work with {1/}.","3853":"{43/} with {37/}","3854":"{1/} provides an implementation of {43/}'s {2051/}.","3855":"When the {2052/} is used, {43/} is auto-configured to use the {2053/} by default.","3856":"{1/} and Service Registry","3857":"{1/} implements the {2054/} interface allowing developers to register arbitrary service in a programmatic way.","3858":"The {2055/} class offers a {2056/} method to create a {2057/} object that can be used by the {2058/}.","3859":"Instance Status","3860":"Netflix {62/} supports having instances registered with the server that are {2059/} and not returned as active service instances.","3861":"This is very useful for behaviors such as blue/green deployments.","3862":"The Curator Service Discovery recipe does not support this behavior.","3863":"Taking advantage of the flexible payload has let {1/} implement {2060/} by updating some specific metadata and then filtering on that metadata in the {43/} {2061/}.","3864":"The {2062/} filters out all non-null instance statuses that do not equal {2063/}.","3865":"If the instance status field is empty, it is considered {2064/} for backwards compatibility.","3866":"To change the status of an instance POST {2065/} to the {2066/} instance status actuator endpoint.","3867":"{37/} Dependencies","3868":"Using the {37/} Dependencies","3869":"{1/} gives you a possibility to provide dependencies of your application as properties.","3870":"As dependencies you can understand other applications that are registered in {37/} and which you would like to call via {55/} (a REST client builder) and also {41/} {2067/} .","3871":"You can also benefit from the {37/} Dependency Watchers functionality that lets you control and monitor what is the state of your dependencies and decide what to do with that.","3872":"How to activate {37/} Dependencies","3873":"Including a dependency on {2068/} will enable auto-configuration that will setup {1/} Dependencies.","3874":"If you have to have the {2069/} section properly set up - check the subsequent section for more details then the feature is active","3875":"You can have the dependencies turned off even if you've provided the dependencies in your properties.","3876":"Just set the property {2070/} to false (defaults to {2071/}).","3877":"Setting up {37/} Dependencies","3878":"Let’s take a closer look at an example of dependencies representation:","3879":"application.yml","3880":"Let's now go through each part of the dependency one by one.","3881":"The root property name is {2072/}.","3882":"Aliases","3883":"Below the root property you have to represent each dependency has by an alias due to the constraints of {43/} (the application id has to be placed in the URL thus you can't pass any complex path like /foo/bar/name).","3884":"The alias will be the name that you will use instead of serviceId for {2073/}, {2074/} or {2075/}.","3885":"In the aforementioned examples the aliases are {2076/} and {2077/}.","3886":"Example of {55/} usage with {2078/} would be:","3887":"Path","3888":"Represented by {2079/} yaml property.","3889":"Path is the path under which the dependency is registered under {37/}.","3890":"Like presented before {43/} operates on URLs thus this path is not compliant with its requirement.","3891":"That is why {1/} maps the alias to the proper path.","3892":"Load balancer type","3893":"Represented by {2080/} yaml property.","3894":"If you know what kind of load balancing strategy has to be applied when calling this particular dependency then you can provide it in the yaml file and it will be automatically applied.","3895":"You can choose one of the following load balancing strategies","3896":"STICKY - once chosen the instance will always be called","3897":"RANDOM - picks an instance randomly","3898":"ROUND_ROBIN - iterates over instances over and over again","3899":"Content-Type template and version","3900":"Represented by {2081/} and {2082/} yaml property.","3901":"If you version your api via the {2083/} header then you don't want to add this header to each of your requests.","3902":"Also if you want to call a new version of the API you don't want to roam around your code to bump up the API version.","3903":"That's why you can provide a {2084/} with a special {2085/} placeholder.","3904":"That placeholder will be filled by the value of the {2086/} yaml property.","3905":"Let's take a look at an example.","3906":"Having the following {2087/}:","3907":"and the following {2088/}:","3908":"Will result in setting up of a {2089/} header for each request:","3909":"Default headers","3910":"Represented by {2090/} map in yaml","3911":"Sometimes each call to a dependency requires setting up of some default headers.","3912":"In order not to do that in code you can set them up in the yaml file.","3913":"Having the following {2091/} section:","3914":"Results in adding the {2092/} and {2093/} headers with appropriate list of values in your HTTP request.","3915":"Obligatory dependencies","3916":"Represented by {2094/} property in yaml","3917":"If one of your dependencies is required to be up and running when your application is booting then it’s enough to set up the {2095/} property in the yaml file.","3918":"If your application can't localize the required dependency during boot time it will throw an exception and the {41/} Context will fail to set up.","3919":"In other words your application won't be able to start if the required dependency is not registered in {37/}.","3920":"You can read more about {1/} Presence Checker in the following sections.","3921":"Stubs","3922":"You can provide a colon separated path to the JAR containing stubs of the dependency.","3923":"Example","3924":"means that for a particular dependencies can be found under:","3925":"groupId: {2096/}","3926":"artifactId: {2097/}","3927":"classifier: {2098/} - this is the default value","3928":"This is actually equal to","3929":"since {2099/} is the default classifier.","3930":"Configuring {1/} Dependencies","3931":"There is a bunch of properties that you can set to enable / disable parts of {37/} Dependencies functionalities.","3932":"{2100/} - if you don’t set this property you won’t benefit from {37/} Dependencies","3933":"{2101/} (enabled by default) - {43/} requires explicit global configuration or a particular one for a dependency.","3934":"By turning on this property runtime load balancing strategy resolution is possible and you can profit from the {2102/} section of the {37/} Dependencies.","3935":"The configuration that needs this property has an implementation of {2103/} that delegates to the {2104/} presented in the next bullet","3936":"{2105/} (enabled by default) - thanks to this property the custom {2106/} knows that the part of the URI passed to {43/} might actually be the alias that has to be resolved to a proper path in {37/}.","3937":"Without this property you won't be able to register applications under nested paths.","3938":"{2107/} (enabled by default) - this property registers such a {2108/} that automatically will append appropriate headers and content types with version as presented in the Dependency configuration.","3939":"Without this setting of those two parameters will not be operational.","3940":"{2109/} (enabled by default) - when enabled will modify the request headers of {2110/} annotated {2111/} so that it passes headers and content type with version set in Dependency configuration.","3941":"Wihtout this setting of those two parameters will not be operational.","3942":"{1/} Dependency Watcher","3943":"The Dependency Watcher mechanism allows you to register listeners to your dependencies.","3944":"The functionality is in fact an implementation of the {2112/} pattern.","3945":"When a dependency changes its state (UP or DOWN) then some custom logic can be applied.","3946":"How to activate","3947":"{1/} Dependencies functionality needs to be enabled to profit from Dependency Watcher mechanism.","3948":"Registering a listener","3949":"In order to register a listener you have to implement an interface {2113/} and register it as a bean.","3950":"The interface gives you one method:","3951":"If you want to register a listener for a particular dependency then the {2114/} would be the discriminator for your concrete implementation.","3952":"{2115/} will provide you with information whether your dependency has changed to {2116/} or {2117/}.","3953":"Presence Checker","3954":"Bound with Dependency Watcher is the functionality called Presence Checker.","3955":"It allows you to provide custom behaviour upon booting of your application to react accordingly to the state of your dependencies.","3956":"The default implementation of the abstract {2118/} class is the\n{2119/} which works in the following way.","3957":"If the dependency is marked us {2120/} and it’s not in {37/} then upon booting your application will throw an exception and shutdown","3958":"If dependency is not {2121/} the {2122/} will log that application is missing at {2123/} level","3959":"The functionality can be overriden since the {2124/} is registered only when there is no bean of {2125/}.","3960":"Distributed Configuration with {37/}","3961":"{37/} provides a hierarchical namespace that allows clients to store arbitrary data, such as configuration data.","3962":"{1/} Config is an alternative to the Config Server and Client .","3963":"Configuration is loaded into the {41/} Environment during the special \"bootstrap\" phase.","3964":"Configuration is stored in the {2126/} namespace by default.","3965":"Multiple {2127/} instances are created based on the application's name and the active profiles that mimicks the {16/} order of resolving properties.","3966":"For example, an application with the name \"testApp\" and with the \"dev\" profile will have the following property sources created:","3967":"The most specific property source is at the top, with the least specific at the bottom.","3968":"{31/} is the {2128/} namespace are applicable to all applications using zookeeper for configuration.","3969":"{31/} in the {2129/} namespace are only available to the instances of the service named \"testApp\".","3970":"Configuration is currently read on startup of the application.","3971":"Sending a HTTP POST to {2130/} will cause the configuration to be reloaded.","3972":"Watching the configuration namespace (which {37/} supports) is not currently implemented, but will be a future addition to this project.","3973":"How to activate","3974":"Including a dependency on {2131/} will enable auto-configuration that will setup {1/} Config.","3975":"Customizing","3976":"{37/} Config may be customized using the following properties:","3977":"bootstrap.yml","3978":"{2132/} setting this value to \"false\" disables {37/} Config","3979":"{2133/} sets the base namespace for configuration values","3980":"{2134/} sets the name used by all applications","3981":"{2135/} sets the value of the separator used to separate the profile name in property sources with profiles","3982":"Unresolved directive in spring-cloud.adoc - include::/Users/sgibb/workspace/spring/spring-cloud-samples/scripts/docs/../cli/docs/src/main/asciidoc/spring-cloud-cli.adoc[]","3984":"{3/} offers a set of primitives for building secure applications and services with minimum fuss.","3985":"A declarative model which can be heavily configured externally (or centrally) lends itself to the implementation of large systems of co-operating, remote components, usually with a central indentity management service.","3986":"It is also extremely easy to use in a service platform like Cloud Foundry.","3987":"Building on {19/} and {41/} Security OAuth2 we can quickly create systems that implement common patterns like single sign on, token relay and token exchange.","3988":"Note","3989":"{22/} is released under the non-restrictive Apache 2.0 license.","3990":"If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at github .","3991":"Quickstart","3992":"OAuth2 Single Sign On","3993":"Here’s a {22/} \"Hello World\" app with HTTP Basic\nauthentication and a single user account:","3994":"app.groovy","3995":"You can run it with {2136/} and watch the logs for the password (username is \"user\").","3996":"So far this is just the default for a {19/} app.","3997":"Here’s a {22/} app with OAuth2 SSO:","3998":"app.groovy","3999":"Spot the difference?","4000":"This app will actually behave exactly the same as the previous one, because it doesn't know it's OAuth2 credentals yet.","4001":"You can register an app in github quite easily, so try that if you want a production app on your own domain.","4002":"If you are happy to test on localhost:8080, then set up these properties in your application configuration:","4003":"application.yml","4004":"run the app above and it will redirect to github for authorization.","4005":"If you are already signed into github you won't even notice that it has authenticated.","4006":"These credentials will only work if your app is running on port 8080.","4007":"To limit the scope that the client asks for when it obtains an access token you can set {2137/} (comma separated or an array in YAML).","4008":"By default the scope is empty and it is up to to Authorization Server to decide what the defaults should be, usually depending on the settings in the client registration that it holds.","4009":"Note","4010":"The examples above are all Groovy scripts.","4011":"If you want to write the same code in Java (or Groovy) you need to add {41/} Security OAuth2 to the classpath (eg see the sample here ).","4012":"OAuth2 Protected Resource","4013":"You want to protect an API resource with an OAuth2 token?","4014":"Here's a simple example (paired with the client above):","4015":"app.groovy","4016":"and","4017":"application.yml","4018":"More Detail","4019":"Single Sign On","4020":"Note","4021":"All of the OAuth2 SSO and resource server features moved to {19/} in version 1.3.","4022":"You can find documentation in the {19/} user guide .","4023":"Token Relay","4024":"A Token Relay is where an OAuth2 consumer acts as a Client and forwards the incoming token to outgoing resource requests.","4025":"The consumer can be a pure Client (like an SSO application) or a Resource Server.","4026":"Client Token Relay","4027":"If your app is a user facing OAuth2 client (ie has declared {2138/} or {2139/}) then it has an {2140/} in request scope from {19/}.","4028":"You can create your own {2141/} from this context and an autowired {2142/}, and then the context will always forward the access token downstream, also refreshing the access token automatically if it expires.","4029":"(These are features of {41/} Security and {19/}.)","4030":"Note","4031":"{19/} (1.4.1) does not create an {2143/} automatically if you are using {2144/} tokens.","4032":"In that case you need to create your own {2145/} and configure it with {2146/}.","4033":"Client Token Relay in {60/} Proxy","4034":"If your app also has a {41/} Cloud {60/} embedded reverse proxy (using {2147/}) then you can ask it to forward OAuth2 access tokens downstream to the services it is proxying.","4035":"Thus the SSO app above can be enhanced simply like this:","4036":"app.groovy","4037":"and it will (in addition to logging the user in and grabbing a token) pass the authentication token downstream to the {2148/} services.","4038":"If those services are implemented with {2149/} then they will get a valid token in the correct header.","4039":"How does it work?","4040":"The {2150/} annotation pulls in {2151/} (which you could do manually in a traditional app), and that in turn triggers some autoconfiguration for a {2152/}, which itself is activated because {60/} is on the classpath (via {2153/}).","4041":"The filter just extracts an access token from the currently authenticated user, and puts it in a request header for the downstream requests.","4042":"Resource Server Token Relay","4043":"If your app has {2154/} you might want to relay the incoming token downstream to other services.","4044":"If you use a {2155/} to contact the downstream services then this is just a matter of how to create the template with the right context.","4045":"If your service uses {2156/} to authenticate incoming tokens (ie it is using the {2157/} configuration), then you can simply create an {2158/} using an autowired {2159/} (it will be populated by the authentication process before it hits the backend code).","4046":"Equivalently (with {19/} 1.4), you could inject a {2160/} and grab its {2161/} in your configuration.","4047":"For example:","4048":"MyConfiguration.java","4049":"This rest template will then have the same {2162/}\n(request-scoped) that is used by the authentication filter, so you can\nuse it to send requests with the same access token.","4050":"If your app is not using {2163/} but is still a client (ie it declares {2164/} or {2165/}), then with {41/} Security Cloud any {2166/} that the user creates from an {2167/} {2168/} will also forward tokens.","4051":"This feature is implemented by default as an MVC handler interceptor, so it only works in {41/} MVC.","4052":"If you are not using MVC you could use a custom filter or AOP interceptor wrapping an {2169/} to provide the same feature.","4053":"Here’s a basic\nexample showing the use of an autowired rest template created\nelsewhere (\"foo.com\" is a Resource Server accepting the same tokens as\nthe surrounding app):","4054":"MyController.java","4055":"If you don’t want to forward tokens (and that is a valid\nchoice, since you might want to act as yourself, rather than the\nclient that sent you the token), then you only need to create your own\n{2170/} instead of autowiring the default one.","4056":"{55/} clients will also pick up an interceptor that uses the\n{2171/} if it is available, so they should also do a\ntoken relay anywhere where a {2172/} would.","4057":"Configuring Authentication Downstream of a {60/} Proxy","4058":"You can control the authorization behaviour downstream of an {2173/} through the {2174/} settings.","4059":"Example:","4060":"application.yml","4061":"In this example the \"customers\" service gets an OAuth2 token relay, the \"stores\" service gets a passthrough (the authorization header is just passed downstream), and the \"recommendations\" service has its authorization header removed.","4062":"The default behaviour is to do a token relay if there is a token available, and passthru otherwise.","4063":"See\n\nProxyAuthenticationProperties for full details.","4064":"{22/} for Cloud Foundry","4065":"{22/} for Cloudfoundry makes it easy to run {22/} apps in Cloud Foundry (the Platform as a Service).","4066":"Cloud Foundry has the notion of a \"service\", which is middlware that you \"bind\" to an app, essentially providing it with an environment variable containing credentials (eg the location and username to use for the service).","4067":"The {2175/} project provides basic support for\nsome enhanced features of webapps in Cloud Foundry: binding\nautomatically to single-sign-on services and optionally enabling\nsticky routing for discovery.","4068":"The {2176/} project provides an\nimplementation of {4/} {2177/} so you can\n{2178/} and provide your credentials as\n{2179/} and then you\ncan use the {2180/} directly or via a {2181/}\n(also {2182/} if you are not connecting to\nPivotal Web Services).","4069":"The first time you use it the discovery client might be slow owing to\nthe fact that it has to get an access token from Cloud Foundry.","4070":"Discovery","4071":"Here’s a {22/} app with Cloud Foundry discovery:","4072":"app.groovy","4073":"If you run it without any service bindings:","4074":"It will show its app name in the home page.","4075":"The {2183/} can lists all the apps in a space, according to the credentials it is authenticated with, where the space defaults to the one the client is running in (if any).","4076":"If neither org nor space are configured, they default per the user's profile in Cloud Foundry.","4077":"Single Sign On","4078":"Note","4079":"All of the OAuth2 SSO and resource server features moved to {19/} in version 1.3.","4080":"You can find documentation in the {19/} user guide .","4081":"This project provides automatic binding from CloudFoundry service credentials to the {19/} features.","4082":"If you have a CloudFoundry service called \"sso\", for instance, with credentials containing \"client_id\", \"client_secret\" and \"auth_domain\", it will bind automatically to the {41/} OAuth2 client that you enable with {2184/} (from {19/}).","4083":"The name of the service can be parameterized using {2185/}.","4085":"Documentation Authors: Adam Dudczak, Mathias Düsterhöft, Marcin Grzejszczak, Dennis Kieselhorst, Jakub Kubryński, Karol Lassak,\nOlga Maciaszek-Sharma, Mariusz Smykuła, Dave Syer","4086":"Dalston.RELEASE","4088":"What you always need is confidence in pushing new features into a new application or service in a distributed system.","4089":"This project provides support for Consumer Driven {36/} and service schemas in {41/} applications, covering a range of options for writing tests, publishing them as assets, asserting that a contract is kept by producers and consumers, for HTTP and message-based interactions.","4090":"{2/} WireMock","4091":"Modules giving you the possibility to use WireMock with different servers by using the \"ambient\" server embedded in a {19/} application.","4092":"Check out the samples for more details.","4093":"Important","4094":"The {22/} Release Train BOM imports {2186/} which in turn has exclusions for the dependencies needed by WireMock.","4095":"This might lead to a situation that even if you're not using {2/} then your dependencies will be influenced anyways.","4096":"If you have a {19/} application that uses Tomcat as an embedded server, for example (the default with {2187/}), then you can simply add {2188/} to your classpath and add {2189/} in order to be able to use Wiremock in your tests.","4097":"Wiremock runs as a stub server and you can register stub behaviour using a Java API or via static JSON declarations as part of your test.","4098":"Here's a simple example:","4099":"To start the stub server on a different port use {2190/} (for example), and for a random port use the value 0. The stub server port will be bindable in the test application context as \"wiremock.server.port\".","4100":"Using {2191/} adds a bean of type {2192/} to your test application context, where it will be cached in between methods and classes having the same context, just like for normal {41/} integration tests.","4101":"Registering Stubs Automatically","4102":"If you use {2193/} then it will register WireMock JSON stubs from the file system or classpath, by default from {2194/}.","4103":"You can customize the locations using the {2195/} attribute in the annotation, which can be a resource pattern (ant-style) or a directory, in which case {2196/} is appended.","4104":"Example:","4105":"Note","4106":"Actually WireMock always loads mappings from {2197/} as well as the custom locations in the stubs attribute.","4107":"To change this behaviour you have to also specify a files root as described next.","4108":"Using Files to Specify the Stub Bodies","4109":"WireMock can read response bodies from files on the classpath or file system.","4110":"In that case you will see in the JSON DSL that the response has a \"bodyFileName\" instead of a (literal) \"body\".","4111":"The files are resolved relative to a root directory {2198/} by default.","4112":"To customize this location you can set the {2199/} attribute in the {2200/} annotation to the location of the parent directory (ie the place {2201/} is a subdirectory).","4113":"You can use {41/} resource notation to refer to {2202/} or {2203/} locations (but generic URLs are not supported).","4114":"A list of values can be given and WireMock will resolve the first file that exists when it needs to find a response body.","4115":"Note","4116":"when you configure the {2204/} root, then it affects the automatic loading of stubs as well (they come from the root location in a subdirectory called \"mappings\").","4117":"The value of {2205/} has no effect on the stubs loaded explicitly from the {2206/} attribute.","4118":"Alternative: Using JUnit Rules","4119":"For a more conventional WireMock experience, using JUnit {2207/} to\nstart and stop the server, just use the {2208/} convenience\nclass to obtain an {2209/} instance:","4120":"The use {2210/} means that the server will shut down after all the methods in this class.","4121":"WireMock and {41/} MVC Mocks","4122":"{2/} provides a convenience class that can load JSON WireMock stubs into a {41/} {2211/}.","4123":"Here's an example:","4124":"The {2212/} is prepended to all mock calls, and the {2213/} method takes a stub path resource pattern as an argument.","4125":"So in this example the stub defined at {2214/} is loaded into the mock server, so if the {2215/} is asked to visit {2216/} it will get the responses as declared there.","4126":"More than one stub pattern can be specified, and each one can be a directory (for a recursive list of all \".json\"), or a fixed filename (like in the example above) or an ant-style pattern.","4127":"The JSON format is the normal WireMock format which you can read about in the WireMock website.","4128":"Currently we support Tomcat, Jetty and Undertow as {19/} embedded servers, and Wiremock itself has \"native\" support for a particular version of Jetty (currently 9.2).","4129":"To use the native Jetty you need to add the native wiremock dependencies and exclude the {19/} container if there is one.","4130":"Generating Stubs using RestDocs","4131":"{41/} RestDocs can be used to generate documentation (eg in asciidoctor format) for an HTTP API with {41/} MockMvc or RestEasy.","4132":"At the same time as you generate documentation for your API, you can also generate WireMock stubs, by using {2/} WireMock.","4133":"Just write your normal RestDocs test cases and use {2217/} to have stubs automatically in the restdocs output directory.","4134":"For example:","4135":"From this test will be generated a WireMock stub at \"target/snippets/stubs/resource.json\".","4136":"It matches all GET requests to the \"/resource\" path.","4137":"Without any additional configuration this will create a stub with a request matcher for the HTTP method and all headers except \"host\" and \"content-length\".","4138":"To match the request more precisely, for example to match the body of a POST or PUT, we need to explicitly create a request matcher.","4139":"This will do two things: 1) create a stub that only matches the way you specify, 2) assert that the request in the test case also matches the same conditions.","4140":"The main entry point for this is {2218/} which can be used as a substitute for the {2219/} convenience method.","4141":"For example:","4142":"So this contract is saying: any valid POST with an \"id\" field will get back an the same response as in this test.","4143":"You can chain together calls to {2220/} to add additional matchers.","4144":"The JayWay documentation can help you to get up to speed with JSON Path if it is unfamiliar to you.","4145":"Instead of the {2221/} and {2222/} convenience methods, you can also use the WireMock APIs to verify the request matches the created stub.","4146":"Example:","4147":"The WireMock API is rich - you can match headers, query parameters, and request body by regex as well as by json path - so this can useful to create stubs with a wider range of parameters.","4148":"The above example will generate a stub something like this:","4149":"post-resource.json","4150":"Note","4151":"\nYou can use either the {2223/} method or the {2224/}\nand {2225/} methods to create request matchers, but not both.\n","4152":"On the consumer side, assuming the {2226/} generated above is\navailable on the classpath, you can create a stub using WireMock in a\nnumber of different ways, including as described above using\n{2227/}.","4153":"Generating {36/} using RestDocs","4154":"Another thing that can be generated with {41/} RestDocs is the {22/} {23/} file and documentation.","4155":"If you combine that with {22/} WireMock then you're getting both the contracts and stubs.","4156":"Tip","4157":"You might wonder why this functionality is in the WireMock module.","4158":"Come to think of it, it does make sense since it makes little sense to generate only contracts and not generate the stubs.","4159":"That's why we suggest to do both.","4160":"Let’s imagine the following test:","4161":"This will lead in the creation of the stub as presented in the previous\nsection, contract will get generated and a documentation file too.","4162":"The contract will be called {2228/} and look more like this.","4163":"the generated document (example for Asciidoc) will contain a formatted contract\n(the location of this file would be {2229/}).","4164":"{2/} Verifier","4165":"Introduction","4166":"Important","4167":"The documentation to the deprecated Accurest project in version 1.1.0 is available here.","4168":"Tip","4169":"\nThe Accurest project was initially started by Marcin Grzejszczak and Jakub Kubrynski (codearte.io)\n","4170":"Just to make long story short - {2/} Verifier is a tool that enables Consumer Driven Contract (CDC) development of JVM-based applications.","4171":"It is shipped with Contract Definition Language (DSL).","4172":"Contract definitions are used to produce following resources:","4173":"JSON stub definitions to be used by WireMock when doing integration testing on the client code ( client tests ).","4174":"Test code must still be written by hand, test data is produced by {2/} Verifier.","4175":"Messaging routes if you're using one.","4176":"We're integrating with {20/}, {22/} Stream, {41/} AMQP and Apache Camel.","4177":"You can however set your own integrations if you want to","4178":"Acceptance tests (in JUnit or Spock) used to verify if server-side implementation of the API is compliant with the contract ( server tests ).","4179":"Full test is generated by {2/} Verifier.","4180":"{2/} Verifier moves TDD to the level of software architecture.","4181":"{2/} video","4182":"You can check out the video from the Warsaw JUG about {2/}:","4183":"Why?","4184":"Let us assume that we have a system comprising of multiple microservices:","4185":"Testing issues","4186":"If we wanted to test the application in top left corner if it can communicate with other services then we could do one of two things:","4187":"deploy all microservices and perform end to end tests","4188":"mock other microservices in unit / integration tests","4189":"Both have their advantages but also a lot of disadvantages.","4190":"Let's focus on the latter.","4191":"Deploy all microservices and perform end to end tests","4192":"Advantages:","4193":"simulates production","4194":"tests real communication between services","4195":"Disadvantages:","4196":"to test one microservice we would have to deploy 6 microservices, a couple of databases etc.","4197":"the environment where the tests would be conducted would be locked for a single suite of tests (i.e. nobody else would be able to run the tests in the meantime).","4198":"long to run","4199":"very late feedback","4200":"extremely hard to debug","4201":"Mock other microservices in unit / integration tests","4202":"Advantages:","4203":"very fast feedback","4204":"no infrastructure requirements","4205":"Disadvantages:","4206":"the implementor of the service creates stubs thus they might have nothing to do with the reality","4207":"you can go to production with passing tests and failing production","4208":"To solve the aforementioned issues {2/} Verifier with {13/} were created.","4209":"Their main idea is to give you very fast feedback, without the need to set up the whole world of microservices.","4210":"If you work on stubs then the only applications you need are those that your application is using directly.","4211":"{2/} Verifier gives you the certainty that the stubs that you're using were created by the service that you're calling.","4212":"Also if you can use them it means that they were tested against the producer's side.","4213":"In other words - you can trust those stubs.","4214":"Purposes","4215":"The main purposes of {2/} Verifier with {13/} are:","4216":"to ensure that WireMock / Messaging stubs (used when developing the client) are doing exactly what actual server-side implementation will do,","4217":"to promote ATDD method and Microservices architectural style,","4218":"to provide a way to publish changes in contracts that are immediately visible on both sides,","4219":"to generate boilerplate test code used on the server side.","4220":"Important","4221":"{2/} Verifier's purpose is NOT to start writing business features in the contracts.","4222":"Let's assume that we have a business use case of fraud check.","4223":"If a user can be a fraud for 100 different reasons, we would assume that you would create 2 contracts.","4224":"One for the positive and one for the negative fraud case.","4225":"Contract tests are used to test contracts between applications and not to simulate full behaviour.","4226":"Client Side","4227":"During the tests you want to have a WireMock instance / Messaging route up and running that simulates the service Y. You would like to feed that instance with a proper stub definition.","4228":"That stub definition would need to be valid and should also be reusable on the server side.","4229":"Summing it up: On this side, in the stub definition, you can use patterns for request stubbing and you need exact\nvalues for responses.","4230":"Server Side","4231":"Being a service Y since you are developing your stub, you need to be sure that it's actually resembling your concrete implementation.","4232":"You can't have a situation where your stub acts in one way and your application on production behaves in a different way.","4233":"That’s why from the provided stub acceptance tests will be generated that will ensure\nthat your application behaves in the same way as you define in your stub.","4234":"Summing it up: On this side, in the stub definition, you need exact values as request and can use patterns/methods\nfor response verification.","4235":"Step by step guide to CDC","4236":"Let's take an example of Fraud Detection and Loan Issuance process.","4237":"The business scenario is such that we want to issue loans to people but don't want them to steal the money from us.","4238":"The current implementation of our system grants loans to everybody.","4239":"Let's assume that the {2230/} is a client to the {2231/} server.","4240":"In the current sprint we are required to develop a new feature - if a client wants to borrow too much money then we mark him as fraud.","4241":"Technical remark - Fraud Detection will have artifact id {2232/}, Loan Issuance {2233/} and both have group id {2234/}.","4242":"Social remark - both client and server development teams need to communicate directly and discuss changes while going through the process.","4243":"CDC is all about communication.","4244":"The server side code is available here and the client side code here.","4245":"Tip","4246":"In this case the ownership of the contracts lays on the producer side.","4247":"It means that physically all the contract are present in the producer's repository","4248":"Technical note","4249":"If using the SNAPSHOT / Milestone / Release Candidate versions please add the following section to your","4250":"Maven","4251":"Gradle","4252":"Consumer side (Loan Issuance)","4253":"As a developer of the Loan Issuance service (a consumer of the Fraud Detection server):","4254":"start doing TDD by writing a test to your feature","4255":"We've just written a test of our new feature.","4256":"If a loan application for a big amount is received we should reject that loan application with some description.","4257":"write the missing implementation","4258":"At some point in time you need to send a request to the Fraud Detection service.","4259":"Let's assume that we'd like to send the request containing the id of the client and the amount he wants to borrow from us.","4260":"We'd like to send it to the {2235/} url via the {2236/} method.","4261":"For simplicity we’ve hardcoded the port of the Fraud Detection service at {2237/} and our application is running on {2238/}.","4262":"If we’d start the written test it would obviously break since we have no service running on port {2239/}.","4263":"clone the Fraud Detection service repository locally","4264":"We'll start playing around with the server side contract.","4265":"That's why we need to first clone it.","4266":"define the contract locally in the repo of Fraud Detection service","4267":"As consumers we need to define what exactly we want to achieve.","4268":"We need to formulate our expectations.","4269":"That's why we write the following contract.","4270":"Important","4271":"We're placing the contract under {2240/} folder.","4272":"The {2241/} folder is important cause we'll reference that folder in the producer's test base class name.","4273":"The Contract is written using a statically typed Groovy DSL.","4274":"You might be wondering what are those {2242/} parts.","4275":"By using this notation {2/} allows you to define parts of a JSON / URL / etc. which are dynamic.","4276":"In case of an identifier or a timestamp you don't want to hardcode a value.","4277":"You want to allow some different ranges of values.","4278":"That's why for the consumer side you can set regular expressions matching those values.","4279":"You can provide the body either by means of a map notation or String with interpolations.","4280":"Consult the docs for more information.","4281":"We highly recommend using the map notation!","4282":"Tip","4283":"It's really important that you understand the map notation to set up contracts.","4284":"Please read the Groovy docs regarding JSON","4285":"The aforementioned contract is an agreement between two sides that:","4286":"if an HTTP request is sent with","4287":"a method {2243/} on an endpoint {2244/}","4288":"JSON body with {2245/} matching the regular expression {2246/} and {2247/} equal to {2248/}","4289":"and with a header {2249/} equal to {2250/}","4290":"then an HTTP response would be sent to the consumer that","4291":"has status {2251/}","4292":"contains JSON body with the {2252/} field containing a value {2253/} and the {2254/} field having value {2255/}","4293":"and a {2256/} header with a value of {2257/}","4294":"Once we’re ready to check the API in practice in the integration tests we need to just install the stubs locally","4295":"add the {2/} Verifier plugin","4296":"We can add either Maven or Gradle plugin - in this example we'll show how to add Maven.","4297":"First we need to add the {2258/} BOM.","4298":"Next, the {2259/} Maven plugin","4299":"Since the plugin was added we get the {2260/} features which from the provided contracts:","4300":"generate and run tests","4301":"produce and install stubs","4302":"We don't want to generate tests since we, as consumers, want only to play with the stubs.","4303":"That's why we need to skip the tests generation and execution.","4304":"When we execute:","4305":"In the logs we’ll see something like this:","4306":"This line is extremely important","4307":"It’s confirming that the stubs of the {2261/} have been installed in the local repository.","4308":"run the integration tests","4309":"In order to profit from the {0/} functionality of automatic stub downloading you have to do the following in our consumer side project ({2262/}).","4310":"Add the {2263/} BOM","4311":"Add the dependency to {2264/}","4312":"Annotate your test class with {2265/}.","4313":"In the annotation provide the group id and artifact id for the {13/} to download stubs of your collaborators.","4314":"Also provide the offline work switch since you're playing with the collaborators offline (optional step).","4315":"Now if you run your tests you’ll see sth like this:","4316":"Which means that {13/} has found your stubs and started a server for app with group id {2266/}, artifact id {2267/} with version {2268/} of the stubs and with {2269/} classifier on port {2270/}.","4317":"file a PR","4318":"What we did until now is an iterative process.","4319":"We can play around with the contract, install it locally and work on the consumer side until we're happy with the contract.","4320":"Once we're satisfied with the results and the test passes publish a PR to the server side.","4321":"Currently the consumer side work is done.","4322":"Producer side (Fraud Detection server)","4323":"As a developer of the Fraud Detection server (a server to the Loan Issuance service):","4324":"initial implementation","4325":"As a reminder here you can see the initial implementation","4326":"take over the PR","4327":"You have to add the dependencies needed by the autogenerated tests","4328":"In the configuration of the Maven plugin we passed the {2271/} property","4329":"Important","4330":"We've decided to use the \"convention based\" naming by setting the {2272/} property.","4331":"That means that 2 last packages will be combined into a name of the base test class.","4332":"In our case the contracts were placed under {2273/}.","4333":"Since we don't have 2 packages starting from the {2274/} folder we're picking only one which is {2275/}.","4334":"We're adding the {2276/} suffix and we're capitalizing {2277/}.","4335":"That gives us the {2278/} test class name.","4336":"That's because all the generated tests will extend that class.","4337":"Over there you can set up your {41/} Context or whatever is necessary.","4338":"In our case we're using Rest Assured MVC to start the server side {2279/}.","4339":"Now, if you run the {2280/} you would get sth like this:","4340":"That's because you have a new contract from which a test was generated and it failed since you haven't implemented the feature.","4341":"The autogenerated test would look like this:","4342":"As you can see all the {2281/} parts of the Contract that were present in the {2282/} blocks got injected into the test.","4343":"What's important here to note is that on the producer side we also are doing TDD.","4344":"We have expectations in form of a test.","4345":"This test is shooting a request to our own application to an URL, headers and body defined in the contract.","4346":"It also is expecting very precisely defined values in the response.","4347":"In other words you have is your {2283/} part of {2284/}, {2285/} and {2286/}.","4348":"Time to convert the {2287/} into the {2288/}.","4349":"write the missing implementation","4350":"Now since we now what is the expected input and expected output let’s write the missing implementation.","4351":"If we execute {2289/} again the tests will pass.","4352":"Since the {2290/} plugin adds the tests to the {2291/} you can actually run those tests from your IDE.","4353":"deploy your app","4354":"Once you've finished your work it's time to deploy your change.","4355":"First merge the branch","4356":"Then we assume that your CI would run sth like {2292/} which would publish both the application and the stub artifcats.","4357":"Consumer side (Loan Issuance) final step","4358":"As a developer of the Loan Issuance service (a consumer of the Fraud Detection server):","4359":"merge branch to master","4360":"work online","4361":"Now you can disable the offline work for {0/} ad provide where the repository with your stubs is placed.","4362":"At this moment the stubs of the server side will be automatically downloaded from Nexus / Artifactory.","4363":"You can switch off the value of the {2293/} parameter in your annotation.","4364":"Below you can see an example of achieving the same by changing the properties.","4365":"And that’s it!","4366":"Dependencies","4367":"The best way to add the dependencies is to just use the proper {2294/} dependency.","4368":"For {2295/} use {2296/} and when you’re using a plugin just add\n{2297/}.","4369":"Additional links","4370":"Below you can find some resources related to {2/} Verifier and {13/}.","4371":"Note that some can be outdated since the {2/} Verifier project is under constant development.","4372":"Readings","4373":"Slides from Marcin Grzejszczak’s talk about Accurest","4374":"Accurest related articles from Marcin Grzejszczak’s blog","4375":"{2/} related articles from Marcin Grzejszczak’s blog","4376":"Groovy docs regarding JSON","4377":"Samples","4378":"Here you can find some samples.","4379":"FAQ","4380":"Why use {2/} Verifier and not X ?","4381":"For the time being {2/} Verifier is a JVM based tool.","4382":"So it could be your first pick when you're already creating software for the JVM.","4383":"This project has a lot of really interesting features but especially quite a few of them definitely make {2/} Verifier stand out on the \"market\" of Consumer Driven Contract (CDC) tooling.","4384":"Out of many the most interesting are:","4385":"Possibility to do CDC with messaging","4386":"Clear and easy to use, statically typed DSL","4387":"Possibility to copy paste your current JSON file to the contract and only edit its elements","4388":"Automatic generation of tests from the defined Contract","4389":"{13/} functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory","4390":"{22/} integration - no discovery service is needed for integration tests","4391":"What is this value(consumer(), producer()) ?","4392":"One of the biggest challenges related to stubs is their reusability.","4393":"Only if they can be vastly used, will they serve their purpose.","4394":"What typically makes that difficult are the hard-coded values of request / response elements.","4395":"For example dates or ids.","4396":"Imagine the following JSON request","4397":"and JSON response","4398":"Imagine the pain required to set proper value of the {2298/} field (let's assume that this content is generated by the database) by changing the clock in the system or providing stub implementations of data providers.","4399":"The same is related to the field called {2299/}.","4400":"Will you create a stubbed implementation of UUID generator?","4401":"Makes little sense…","4402":"So as a consumer you would like to send a request that matches any form of a time or any UUID.","4403":"That way your system will work as usual - will generate data and you won't have to stub anything out.","4404":"Let's assume that in case of the aforementioned JSON the most important part is the {2300/} field.","4405":"You can focus on that and provide matching for other fields.","4406":"In other words you would like the stub to work like this:","4407":"As far as the response goes as a consumer you need a concrete value that you can operate on.","4408":"So such a JSON is valid","4409":"As you could see in the previous sections we generate tests from contracts.","4410":"So from the producer's side the situation looks much different.","4411":"We're parsing the provided contract and in the test we want to send a real request to your endpoints.","4412":"So for the case of a producer for the request we can't have any sort of matching.","4413":"We need concrete values that the producer's backend can work on.","4414":"Such a JSON would be a valid one:","4415":"On the other hand from the point of view of the validity of the contract the response doesn't necessarily have to contain concrete values of {2301/} or {2302/}.","4416":"Let's say that you generate those on the producer side - again, you'd have to do a lot of stubbing to ensure that you always return the same values.","4417":"That's why from the producer's side what you might want is the following response:","4418":"How can you then provide one time a matcher for the consumer and a concrete value for the producer and vice versa?","4419":"In {2/} we're allowing you to provide a dynamic value .","4420":"That means that it can differ for both sides of the communication.","4421":"You can pass the values:","4422":"Either via the {2303/} method","4423":"or using the {2304/} method","4424":"You can read more about this in the {23/} section.","4425":"Calling {2305/} or {2306/} tells {2/} that you will be passing a dynamic value.","4426":"Inside the {2307/} method you pass the value that should be used on the consumer side (in the generated stub).","4427":"Inside the {2308/} method you pass the value that should be used on the producer side (in the generated test).","4428":"Tip","4429":"\nIf on one side you have passed the regular expression and you haven’t passed the other, then the\nother side will get auto-generated.\n","4430":"Most often you will use that method together with the {2309/} helper method.","4431":"Eg {2310/}.","4432":"To sum it up the contract for the aforementioned scenario would look more or less like this (the regular expression\nfor time and UUID are simplified and most likely invalid but we want to keep things very simple in this example):","4433":"Important","4434":"\nPlease read the Groovy docs related to JSON to understand how to\nproperly structure the request / response bodies.\n","4435":"How to do Stubs versioning?","4436":"API Versioning","4437":"Let's try to answer a question what versioning really means.","4438":"If you're referring to the API version then there are different approaches.","4439":"use Hypermedia, links and do not version your API by any means","4440":"pass versions through headers / urls","4441":"I will not try to answer a question which approach is better.","4442":"Whatever suit your needs and allows you to generate business value should be picked.","4443":"Let's assume that you do version your API.","4444":"In that case you should provide as many contracts as many versions you support.","4445":"You can create a subfolder for every version or append it to th contract name - whatever suits you more.","4446":"JAR versioning","4447":"If by versioning you mean the version of the JAR that contains the stubs then there are essentially two main approaches.","4448":"Let's assume that you're doing Continuous Delivery / Deployment which means that you're generating a new version of the jar each time you go through the pipeline and that jar can go to production at any time.","4449":"For example your jar version looks like this (it got built on the 20.10.2016 at 20:15:21) :","4450":"In that case your generated stub jar will look like this.","4451":"In this case you should inside your {2311/} or {2312/} when referencing stubs provide the latest version of the stubs.","4452":"You can do that by passing the {2313/} sign.","4453":"Example","4454":"If the versioning however is fixed (eg {2314/} or {2315/}) then you have to set the concrete value of the jar version.","4455":"Example for 2.1.1.","4456":"Dev or prod stubs","4457":"You can manipulate the classifier to run the tests against current development version of the stubs of other services or the ones that were deployed to production.","4458":"If you alter your build to deploy the stubs with the {2316/} classifier once you reach production deployment then you can run tests in one case with dev stubs and one with prod stubs.","4459":"Example of tests using development version of stubs","4460":"Example of tests using production version of stubs","4461":"You can pass those values also via properties from your deployment pipeline.","4462":"Common repo with contracts","4463":"Another way of storing contracts other than having them with the producer is keeping them in a common place.","4464":"It can be related to security issues where the consumers can't clone the producer's code.","4465":"Also if you keep contracts in a single place then you, as a producer, will know how many consumers you have and which consumer will you break with your local changes.","4466":"Repo structure","4467":"Let's assume that we have a producer with coordinates {2317/} and 3 consumers: {2318/}, {2319/}, {2320/}.","4468":"Then in the repository with common contracts you would have the following setup (which you can checkout here :","4469":"As you can see the under the slash-delimited groupid {2321/} artifact id folder ({2322/}) you have expectations of the 3 consumers ({2323/}, {2324/} and {2325/}).","4470":"Expectations are the standard Groovy DSL contract files as described throughout this documentation.","4471":"This repository has to produce a JAR file that maps one to one to the contents of the repo.","4472":"Example of a {2326/} inside the {2327/} folder.","4473":"As you can see there are no dependencies other than the {2/} Maven Plugin.","4474":"Those poms are necessary for the consumer side to run {2328/} to locally install stubs of the producer project.","4475":"The {2329/} in the root folder can look like this:","4476":"It's using the assembly plugin in order to build the JAR with all the contracts.","4477":"Example of such setup is here:","4478":"Workflow","4479":"The workflow would look similar to the one presented in the {2330/}.","4480":"The only difference is that the producer doesn't own the contracts anymore.","4481":"So the consumer and the producer have to work on common contracts in a common repository.","4482":"Consumer","4483":"When the consumer wants to work on the contracts offline, instead of cloning the producer code, the\nconsumer team clones the common repository, goes to the required producer’s folder (e.g. {2331/})\nand runs {2332/} to install locally the stubs converted from the contracts.","4484":"Tip","4485":"\nYou need to have Maven installed locally","4486":"Producer","4487":"As a producer it’s enough to alter the {2/} Verifier to provide the URL and the dependency\nof the JAR containing the contracts:","4488":"With this setup the JAR with groupid {2333/} and artifactid {2334/} will be downloaded from {2335/}.","4489":"It will be then unpacked in a local temporary folder and contracts present under the {2336/} will be picked as the ones used to generate the tests and the stubs.","4490":"Due to this convention the producer team will know which consumer teams will be broken when some incompatible changes are done.","4491":"The rest of the flow looks the same.","4492":"Can I have multiple base classes for tests?","4493":"Yes!","4494":"Check out the Different base classes for contracts sections of either Gradle or Maven plugins.","4495":"How can I debug the request/response being sent by the generated tests client?","4496":"The generated tests all boil down to RestAssured in some form or fashion which relies on Apache HttpClient .","4497":"HttpClient has a facility called wire logging which logs the entire request and response to HttpClient.","4498":"{19/} has a logging common application property for doing this sort of thing, just add this to your application properties","4499":"Can I reference the request from the response?","4500":"Yes!","4501":"With version 1.1.0 we've added such a possibility.","4502":"On the HTTP stub server side we're providing support for this for WireMock.","4503":"In case of other HTTP server stubs you'll have to implement the approach yourself.","4504":"{2/} Verifier HTTP","4505":"Gradle Project","4506":"Prerequisites","4507":"In order to use {2/} Verifier with WireMock you have to use Gradle or Maven plugin.","4508":"Warning","4509":"If you want to use Spock in your projects you have to add separately the {2337/} and {2338/} modules.","4510":"Check Spock docs for more information","4511":"Add gradle plugin with dependencies","4512":"Snapshot versions for Gradle","4513":"Add the additional snapshot repository to your build.gradle to use snapshot versions which are automatically uploaded after every successful build:","4514":"Add stubs","4515":"By default {2/} Verifier is looking for stubs in {2339/} directory.","4516":"Directory containing stub definitions is treated as a class name, and each stub definition is treated as a single test.","4517":"We assume that it contains at least one directory which will be used as test class name.","4518":"If there is more than one level of nested directories all except the last one will be used as package name.","4519":"So with following structure","4520":"{2/} Verifier will create test class {2340/} with two methods","4521":"Run plugin","4522":"Plugin registers itself to be invoked before {2341/} task.","4523":"You have nothing to do as long as you want it to be part of your build process.","4524":"If you just want to generate tests please invoke {2342/} task.","4525":"Default setup","4526":"Default Gradle Plugin setup creates the following Gradle part of the build (it’s a pseudocode)","4527":"Configure plugin","4528":"To change default configuration just add {2343/} snippet to your Gradle config","4529":"Configuration options","4530":"testMode - defines mode for acceptance tests.","4531":"By default MockMvc which is based on {41/}'s MockMvc.","4532":"It can also be changed to JaxRsClient or to Explicit for real HTTP calls.","4533":"imports - array with imports that should be included in generated tests (for example ['org.myorg.Matchers']).","4534":"By default empty array []","4535":"staticImports - array with static imports that should be included in generated tests(for example ['org.myorg.Matchers.*']).","4536":"By default empty array []","4537":"basePackageForTests - specifies base package for all generated tests.","4538":"By default set to org.springframework.cloud.verifier.tests","4539":"baseClassForTests - base class for all generated tests.","4540":"By default {2344/} if using Spock tests.","4541":"packageWithBaseClasses - instead of providing a fixed value for base class you can provide a package where all the base classes lay.","4542":"Takes precedence over baseClassForTests .","4543":"baseClassMappings - explicitly map contract package to a FQN of a base class.","4544":"Takes precedence over packageWithBaseClasses and baseClassForTests .","4545":"ruleClassForTests - specifies Rule which should be added to generated test classes.","4546":"ignoredFiles - Ant matcher allowing defining stub files for which processing should be skipped.","4547":"By default empty array []","4548":"contractsDslDir - directory containing contracts written using the GroovyDSL.","4549":"By default {2345/}","4550":"generatedTestSourcesDir - test source directory where tests generated from Groovy DSL should be placed.","4551":"By default {2346/}","4552":"stubsOutputDir - dir where the generated WireMock stubs from Groovy DSL should be placed","4553":"targetFramework - the target test framework to be used;","4554":"currently Spock and JUnit are supported with JUnit being the default framework","4555":"The following properties are used when you want to provide where the JAR with contract lays","4556":"contractDependency - the Dependency that provides {2347/} coordinates.","4557":"You can use the {2348/} closure to set it up","4558":"contractsPath - if contract deps are downloaded will default to {2349/} where {2350/} will be slash separated.","4559":"Otherwise will scan contracts under provided directory","4560":"contractsWorkOffline - in order not to download the dependencies each time you can download them once and work offline afterwards (reuse local Maven repo)","4561":"Single base class for all tests","4562":"When using {2/} Verifier in default MockMvc you need to create a base specification for all generated acceptance tests.","4563":"In this class you need to point to endpoint which should be verified.","4564":"In case of using {2351/} mode, you can use base class to initialize the whole tested app similarly as in regular integration tests.","4565":"In case of {2352/} mode this base class should also contain {2353/} field, right now the only option to test JAX-RS API is to start a web server.","4566":"Different base classes for contracts","4567":"If your base classes differ between contracts you can tell the {2/} plugin which class should get extended by the autogenerated tests.","4568":"You have two options:","4569":"follow a convention by providing the {2354/}","4570":"provide explicit mapping via {2355/}","4571":"Convention","4572":"The convention is such that if you have a contract under eg {2356/} and provide the value of the {2357/} property to {2358/} then we will assume that there is a {2359/} class under {2360/} package.","4573":"In other words we take last two parts of package if they exist and form a class with a {2361/} suffix.","4574":"Takes precedence over baseClassForTests .","4575":"Example of usage in the {2362/} closure:","4576":"Mapping","4577":"You can manually map a regular expression of the contract's package to fully qualified name of the base class for the matched contract.","4578":"Let's take a look at the following example:","4579":"Let’s assume that you have contracts under\n - {2363/}\n - {2364/}","4580":"By providing the {2365/} we have a fallback in case mapping didn't succeed (you could also provide the {2366/} as fallback).","4581":"That way the tests generated from {2367/} contracts will be extending the {2368/} whereas the rest of tests will extend {2369/}.","4582":"Invoking generated tests","4583":"To ensure that provider side is complaint with defined contracts, you need to invoke:","4584":"{2/} Verifier on consumer side","4585":"In consumer service you need to configure {2/} Verifier plugin in exactly the same way as in case of provider.","4586":"If you don't want to use {13/} then you need to copy contracts stored in {2370/} and generate WireMock json stubs using:","4587":"Note that {2371/} option has to be set for stub generation to work.","4588":"When present, json stubs can be used in consumer automated tests.","4589":"Underneath LoanApplication makes a call to FraudDetection service.","4590":"This request is handled by WireMock server configured using stubs generated by {2/} Verifier.","4591":"Using in your Maven project","4592":"Add maven plugin","4593":"Add the {2/} BOM","4594":"Next, the {2372/} Maven plugin","4595":"You can read more in the {2/} Maven Plugin Docs","4596":"Snapshot versions for Maven","4597":"For Snapshot / Milestone versions you have to add the following section to your {2373/}","4598":"Add stubs","4599":"By default {2/} Verifier is looking for stubs in {2374/} directory.","4600":"Directory containing stub definitions is treated as a class name, and each stub definition is treated as a single test.","4601":"We assume that it contains at least one directory which will be used as test class name.","4602":"If there is more than one level of nested directories all except the last one will be used as package name.","4603":"So with following structure","4604":"{2/} Verifier will create test class {2375/} with two methods\n - {2376/}\n - {2377/}","4605":"Run plugin","4606":"Plugin goal {2378/} is assigned to be invoked in phase {2379/}.","4607":"You have nothing to do as long as you want it to be part of your build process.","4608":"If you just want to generate tests please invoke {2380/} goal.","4609":"Configure plugin","4610":"To change default configuration just add {2381/} section to plugin definition or {2382/} definition.","4611":"Important configuration options","4612":"testMode - defines mode for acceptance tests.","4613":"By default {2383/} which is based on {41/}'s MockMvc.","4614":"It can also be changed to {2384/} or to {2385/} for real HTTP calls.","4615":"basePackageForTests - specifies base package for all generated tests.","4616":"By default set to {2386/}.","4617":"ruleClassForTests - specifies Rule which should be added to generated test classes.","4618":"baseClassForTests - base class for generated tests.","4619":"By default {2387/} if using Spock tests.","4620":"contractsDir - directory containing contracts written using the GroovyDSL.","4621":"By default {2388/}.","4622":"testFramework - the target test framework to be used;","4623":"currently Spock and JUnit are supported with JUnit being the default framework","4624":"packageWithBaseClasses - instead of providing a fixed value for base class you can provide a package where all the base classes lay.","4625":"The convention is such that if you have a contract under {2389/} and provide the value of this property to {2390/} then we will assume that there is a {2391/} class under {2392/} package.","4626":"Takes precedence over baseClassForTests","4627":"baseClassMappings - list of base class mappings that where you have to provide {2393/} which is checked against the package in which the contract lays and {2394/} that maps to fully qualified name of the base class for the matched contract.","4628":"If you have a contract under {2395/} and map the property {2396/} → {2397/} then the test class generated from these contracts will extend {2398/}.","4629":"Takes precedence over packageWithBaseClasses and baseClassForTests .","4630":"If you want to download your contract definitions from a Maven repository you can use","4631":"contractsRepositoryUrl - URL to a repo with the artifacts with contracts, if not provided should use the current Maven ones","4632":"contractDependency - the contract dependency that contains all the packaged contracts","4633":"contractsPath - path to concrete contracts in the JAR with packaged contracts.","4634":"Defaults to {2399/} where {2400/} is slash separated.","4635":"contractsWorkOffline - if the dependencies should be downloaded or local Maven only should be reused","4636":"For complete information take a look at Plugin Documentation","4637":"Single base class for all tests","4638":"When using {2/} Verifier in default MockMvc you need to create a base specification for all generated acceptance tests.","4639":"In this class you need to point to endpoint which should be verified.","4640":"In case of using {2401/} mode, you can use base class to initialize the whole tested app similarly as in regular integration tests.","4641":"In case of {2402/} mode this base class should also contain {2403/} field, right now the only option to test JAX-RS API is to start a web server.","4642":"Different base classes for contracts","4643":"If your base classes differ between contracts you can tell the {2/} plugin which class should get extended by the autogenerated tests.","4644":"You have two options:","4645":"follow a convention by providing the {2404/}","4646":"provide explicit mapping via {2405/}","4647":"Convention","4648":"The convention is such that if you have a contract under eg {2406/} and provide the value of the {2407/} property to {2408/} then we will assume that there is a {2409/} class under {2410/} package.","4649":"In other words we take last two parts of package if they exist and form a class with a {2411/} suffix.","4650":"Takes precedence over baseClassForTests .","4651":"Example of usage:","4652":"Mapping","4653":"You can manually map a regular expression of the contract's package to fully qualified name of the base class for the matched contract.","4654":"You have to provide a list {2412/} of {2413/} that takes a {2414/} to {2415/} mapping.","4655":"Let's take a look at the following example:","4656":"Let’s assume that you have contracts under\n - {2416/}\n - {2417/}","4657":"By providing the {2418/} we have a fallback in case mapping didn't succeed (you could also provide the {2419/} as fallback).","4658":"That way the tests generated from {2420/} contracts will be extending the {2421/} whereas the rest of tests will extend {2422/}.","4659":"Invoking generated tests","4660":"{2/} Maven Plugin generates verification code into directory {2423/} and attach this directory to {2424/} goal.","4661":"For Groovy Spock code use:","4662":"To ensure that provider side is complaint with defined contracts, you need to invoke {2425/}","4663":"FAQ with Maven Plugin","4664":"Maven Plugin and STS","4665":"In case you see the following exception while using STS","4666":"when you click on the marker you should see sth like this","4667":"In order to fix this issue just provide the following section in your {2426/}","4668":"{2/} Verifier on consumer side","4669":"You can actually use the {2/} Verifier also for the consumer side!","4670":"You can use the plugin so that it only converts the contracts and generates the stubs.","4671":"To achieve that you need to configure {2/} Verifier plugin in exactly the same way as in case of provider.","4672":"You need to copy contracts stored in {2427/} and generate WireMock json stubs using: {2428/} command.","4673":"By default generated WireMock mapping is stored in directory {2429/}.","4674":"Your project should create from this generated mappings additional artifact with classifier {2430/} for easy deploy to maven repository.","4675":"Sample configuration:","4676":"When present, json stubs can be used in consumer automated tests.","4677":"Underneath {2431/} makes a call to the {2432/} service.","4678":"This request is handled by a WireMock server configured using stubs generated by {2/} Verifier.","4679":"Scenarios","4680":"It's possible to handle scenarios with {2/} Verifier.","4681":"All you need to do is to stick to proper naming convention while creating your contracts.","4682":"The convention requires to include order number followed by the underscore.","4683":"Such tree will cause {2/} Verifier generating WireMock’s scenario with name {2433/} and three steps:","4684":"login marked as {2434/} pointing to:","4685":"showCart marked as {2435/} pointing to:","4686":"logout marked as {2436/} which will close the scenario.","4687":"More details about WireMock scenarios can be found under http://wiremock.org/stateful-behaviour.html","4688":"{2/} Verifier will also generate tests with guaranteed order of execution.","4689":"Stubs and transitive dependencies","4690":"The Maven and Gradle plugin that we're created are adding the tasks that create the stubs jar for you.","4691":"What can be problematic is that when reusing the stubs you can by mistake import all of that stub dependencies!","4692":"When building a Maven artifact even though you have a couple of different jars, all of them share one pom:","4693":"There are three possibilities of working with those dependencies so as not to have any issues with transitive dependencies.","4694":"Mark all application dependencies as optional","4695":"If in the {2437/} application we would mark all of our dependencies as optional, when you include the\n{2438/} stubs in another application (or when that dependency gets downloaded by {13/}) then, since\nall of the depenencies are optional, they will not get downloaded.","4696":"Create a separate artifactid for stubs","4697":"If you create a separate artifactid then you can set it up in whatever way you wish.","4698":"For example by having no dependencies at all.","4699":"Exclude dependencies on the consumer side","4700":"As a consumer, if you add the stub dependency to your classpath you can explicitly exclude the unwanted dependencies.","4701":"{2/} Verifier Messaging","4702":"{2/} Verifier allows you to verify your application that uses messaging as means of communication.","4703":"All of our integrations are working with {41/} but you can also create one yourself and use it.","4704":"Integrations","4705":"You can use one of the four integration configurations:","4706":"Apache Camel","4708":"{22/} Stream","4709":"{41/} AMQP","4710":"Since we’re using {19/} then if you have added one of the aforementioned libraries\nto the classpath then automatically all the messaging configuration will be set up.","4711":"Important","4712":"Remember to put {2439/} on the base class of your generated tests.","4713":"Otherwise messaging part of {2/} Verifier will not work.","4714":"Manual Integration Testing","4715":"The main interface used by the tests is the {2440/}.","4716":"It defines how to send and receive messages.","4717":"You can create your own implementation to achieve the same goal.","4718":"In the a test you can inject a {2441/} to send and receive messages that follow the contract.","4719":"Then add {2442/} to your test, eg","4720":"Note","4721":"\nIf your tests require stubs as well, then\n{2443/} includes the messaging configuration, so\nyou only need the one annotation.\n","4722":"Publisher side test generation","4723":"Having the {2444/} or {2445/} sections in your DSL will result in creation of tests on the publisher's side.","4724":"By default JUnit tests will be created, however there is also a possibility to create Spock tests.","4725":"There are 3 main scenarios that we should take into consideration:","4726":"Scenario 1: there is no input message that produces an output one.","4727":"The output message is triggered by a component inside the application (eg scheduler)","4728":"Scenario 2: the input message triggers an output message","4729":"Scenario 3: the input message is consumed and there is no output message","4730":"Scenario 1 (no input message)","4731":"For the given contract:","4732":"The following JUnit test will be created:","4733":"And the following Spock test would be created:","4734":"Scenario 2 (output triggered by input)","4735":"For the given contract:","4736":"The following JUnit test will be created:","4737":"And the following Spock test would be created:","4738":"Scenario 3 (no output message)","4739":"For the given contract:","4740":"The following JUnit test will be created:","4741":"And the following Spock test would be created:","4742":"Consumer Stub Side generation","4743":"Unlike the HTTP part - in Messaging we need to publish the Groovy DSL inside the JAR with a stub.","4744":"Then it's parsed on the consumer side and proper stubbed routes are created.","4745":"For more information please consult the {13/} Messaging sections.","4746":"Maven","4747":"Gradle","4749":"One of the issues that you could have encountered while using {2/} Verifier was to pass the generated WireMock JSON stubs from the server side to the client side (or various clients).","4750":"The same takes place in terms of client side generation for messaging.","4751":"Copying the JSON files / setting the client side for messaging manually is out of the question.","4752":"That’s why we’ll introduce {0/} that can download and run the stubs\nautomatically for you.","4753":"Snapshot versions","4754":"Add the additional snapshot repository to your build.gradle to use snapshot versions which are automatically uploaded after every successful build:","4755":"Maven","4756":"Gradle","4757":"Publishing stubs as JARs","4758":"The easiest approach would be to centralize the way stubs are kept.","4759":"For example you can keep them as JARs in a Maven repository.","4760":"Tip","4761":"For both Maven and Gradle the setup comes out of the box.","4762":"But you can customize it if you want to.","4763":"Maven","4764":"Gradle","4765":"Modules","4766":"{13/} Core","4767":"Runs stubs for service collaborators.","4768":"Treating stubs as contracts of services allows to use stub-runner as an implementation of Consumer Driven {36/} .","4769":"{13/} allows you to automatically download the stubs of the provided dependencies, start WireMock servers for them and feed them with proper stub definitions.","4770":"For messaging, special stub routes are defined.","4771":"Running stubs","4772":"Limitations","4773":"Important","4774":"There might be a problem with StubRunner shutting down ports between tests.","4775":"You might have a situation in which you get port conflicts.","4776":"As long as you use the same context across tests everything works fine.","4777":"But when the context are different (eg different stubs or different profiles) then you have to either use {2446/} to shut down the stub servers, or else run them on different ports per test.","4778":"Running using main app","4779":"You can set the following options to the main class:","4780":"HTTP Stubs","4781":"Stubs are defined in JSON documents, whose syntax is defined in WireMock documentation","4782":"Example:","4783":"Viewing registered mappings","4784":"Every stubbed collaborator exposes list of defined mappings under {2447/} endpoint.","4785":"Messaging Stubs","4786":"Depending on the provided {13/} dependency and the DSL the messaging routes are automatically set up.","4787":"{13/} JUnit Rule","4788":"{13/} comes with a JUnit rule thanks to which you can very easily download and run stubs for given group and artifact id:","4789":"After that rule gets executed {13/} connects to your Maven repository and for the given list of dependencies tries to:","4790":"download them","4791":"cache them locally","4792":"unzip them to a temporary folder","4793":"start a WireMock server for each Maven dependency on a random port from the provided range of ports / provided port","4794":"feed the WireMock server with all JSON files that are valid WireMock definitions","4795":"{13/} uses Eclipse Aether mechanism to download the Maven dependencies.","4796":"Check their docs for more information.","4797":"Since the {2448/} implements the {2449/} it allows you to find the started stubs:","4798":"Example of usage in Spock tests:","4799":"Example of usage in JUnit tests:","4800":"Check the Common properties for JUnit and {41/} for more information on how to apply global configuration of {13/}.","4801":"Maven settings","4802":"The stub downloader honors Maven settings for a different local repository folder.","4803":"Authentication details for repositories and profiles are currently not taken into account, so you need to specify it using the properties mentioned above.","4804":"Providing fixed ports","4805":"You can also run your stubs on fixed ports.","4806":"You can do it in two different ways.","4807":"One is to pass it in the properties, and the other via fluent API of JUnit rule.","4808":"Fluent API","4809":"When using the {2450/} you can add a stub to download and then pass the port for the last downloaded stub.","4810":"You can see that for this example the following test is valid:","4811":"{13/} with {41/}","4812":"Sets up {41/} configuration of the {13/} project.","4813":"By providing a list of stubs inside your configuration file the {13/} automatically downloads\nand registers in WireMock the selected stubs.","4814":"If you want to find the URL of your stubbed dependency you can autowire the {2451/} interface and use\nits methods as presented below:","4815":"for the following configuration file:","4816":"Instead of using the properties you can also use the properties inside the {2452/}.","4817":"Below you can find an example of achieving the same result by setting values on the annotation.","4818":"{13/} {41/} registers environment variables in the following manner for every registered WireMock server.","4819":"Example for {13/} ids {2453/}, {2454/}.","4820":"Which you can reference in your code.","4822":"{13/} can integrate with {22/}.","4823":"For real life examples you can check the","4824":"producer app sample","4825":"consumer app sample","4826":"Stubbing Service Discovery","4827":"The most important feature of {2455/} is the fact that it’s stubbing","4828":"that means that regardless of the fact whether you're using {37/}, {49/}, {62/} or anything else, you don't need that in your tests.","4829":"We're starting WireMock instances of your dependencies and we're telling your application whenever you're using {2456/}, load balanced {2457/} or {2458/} directly, to call those stubbed servers instead of calling the real Service Discovery tool.","4830":"For example this test will pass","4831":"for the following configuration file","4832":"Test profiles and service discovery","4833":"In your integration tests you typically don't want to call neither a discovery service (eg {62/}) or Config Server.","4834":"That's why you create an additional test configuration in which you want to disable these features.","4835":"Due to certain limitations of  to achieve this you have disable these properties\nvia a static block like presented below (example for {62/})","4836":"Additional Configuration","4837":"You can match the artifactId of the stub with the name of your app by using the {2459/} map.","4838":"You can disable {13/} {43/} support by providing: {2460/} equal to {2461/} You can disable {13/} support by providing: {2462/} equal to {2463/}","4839":"Tip","4840":"By default all service discovery will be stubbed.","4841":"That means that regardless of the fact if you have an existing {2464/} its results will be ignored.","4842":"However, if you want to reuse it, just set {2465/} to {2466/} and then your existing {2467/} results will be merged with the stubbed ones.","4843":"{13/} Boot Application","4844":"{2/} Verifier {13/} Boot is a {19/} application that exposes REST endpoints to\ntrigger the messaging labels and to access started WireMock servers.","4845":"One of the use-cases is to run some smoke (end to end) tests on a deployed application.","4846":"You can read more about this in the \"Microservice Deployment\" article at Too Much Coding blog.","4847":"How to use it?","4848":"Just add the","4849":"Annotate a class with {2468/}, build a fat-jar and you’re ready to go!","4850":"For the properties check the {13/} {41/} section.","4851":"Endpoints","4852":"HTTP","4853":"GET {2469/} - returns a list of all running stubs in {2470/} notation","4854":"GET {2471/} - returns a port for the given {2472/} notation (when calling the endpoint {2473/} can also be {2474/} only)","4855":"Messaging","4856":"For Messaging","4857":"GET {2475/} - returns a list of all running labels in {2476/} notation","4858":"POST {2477/} - executes a trigger with {2478/}","4859":"POST {2479/} - executes a trigger with {2480/} for the given {2481/} notation (when calling the endpoint {2482/} can also be {2483/} only)","4860":"Example","4861":"{13/} Boot with Service Discovery","4862":"One of the possibilities of using {13/} Boot is to use it as a feed of stubs for \"smoke-tests\".","4863":"What does it mean?","4864":"Let's assume that you don't want to deploy 50 microservice to a test environment in order to check if your application is working fine.","4865":"You've already executed a suite of tests during the build process but you would also like to ensure that the packaging of your application is fine.","4866":"What you can do is to deploy your application to an environment, start it and run a couple of tests on it to see if it's working fine.","4867":"We can call those tests smoke-tests since their idea is to check only a handful of testing scenarios.","4868":"The problem with this approach is such that if you're doing microservices most likely you're using a service discovery tool.","4869":"{13/} Boot allows you to solve this issue by starting the required stubs and register them in a service discovery tool.","4870":"Let's take a look at an example of such a setup with {62/}.","4871":"Let's assume that {62/} was already running.","4872":"As you can see we want to start a {13/} Boot server {2484/}, enable {62/} client {2485/}\nand we want to have the stub runner feature turned on {2486/}.","4873":"Now let's assume that we want to start this application so that the stubs get automatically registered.","4874":"We can do it by running the app {2487/} where {2488/} would contain the following list of properties","4875":"That way your deployed application can send requests to started WireMock servers via the service discovery.","4876":"Most likely points 1-3 could be set by default in {2489/} cause they are not likely to change.","4877":"That way you can provide only the list of stubs to download whenever you start the {13/} Boot.","4878":"Common properties for JUnit and {41/}","4879":"Some of the properties that are repetitive can be set using system properties or configuration properties (for {41/}).","4880":"Here are their names with their default values:","4881":"Property name","4882":"Default value","4883":"Description","4884":"Minimal value of a port for a started WireMock with stubs","4885":"Minimal value of a port for a started WireMock with stubs","4886":"Maven repo url.","4887":"If blank then will call the local maven repo","4888":"Default classifier for the stub artifacts","4889":"If true then will not contact any remote repositories to download stubs","4890":"Array of Ivy notation stubs to download","4891":"Optional username to access the tool that stores the JARs with stubs","4892":"Optional password to access the tool that stores the JARs with stubs","4893":"Stub runner stubs ids","4894":"You can provide the stubs to download via the {2490/} system property.","4895":"They follow the following pattern:","4896":"{2491/}, {2492/} and {2493/} are optional.","4897":"If you don’t provide the {2494/} then a random one will be picked","4898":"If you don't provide the {2495/} then the default one will be taken.","4899":"(NOTE that you can pass an empty classifier like this {2496/})","4900":"If you don’t provide the {2497/} then the {2498/} will be passed and the latest one will be downloaded","4901":"Where {2499/} means the port of the WireMock server.","4902":"Important","4903":"Starting from version 1.0.4 as a version you can provide a range of versions that you would like the {13/} to take into consideration.","4904":"You can read more about the Aether versioning ranges here .","4905":"Taken from Aether Docs:","4906":"This scheme accepts versions of any form, interpreting a version as a sequence of numeric and alphabetic segments.","4907":"The characters '-', '_', and '.'","4908":"as well as the mere transitions from digit to letter and vice versa delimit the version segments.","4909":"Delimiters are treated as equivalent.","4910":"Numeric segments are compared mathematically, alphabetic segments are compared lexicographically and case-insensitively.","4911":"However, the following qualifier strings are recognized and treated specially: \"alpha\" = \"a\" < \"beta\" = \"b\" < \"milestone\" = \"m\" < \"cr\" = \"rc\" < \"snapshot\" < \"final\" = \"ga\" < \"sp\".","4912":"All of those well-known qualifiers are considered smaller/older than other strings.","4913":"An empty segment/string is equivalent to 0.","4914":"In addition to the above mentioned qualifiers, the tokens \"min\" and \"max\" may be used as final version segment to denote the smallest/greatest version having a given prefix.","4915":"For example, \"1.2.min\" denotes the smallest version in the 1.2 line, \"1.2.max\" denotes the greatest version in the 1.2 line.","4916":"A version range of the form \"[MN*]\" is short for \"[MNmin, MNmax]\".","4917":"Numbers and strings are considered incomparable against each other.","4918":"Where version segments of different kind would collide, comparison will instead assume that the previous segments are padded with trailing 0 or \"ga\" segments, respectively, until the kind mismatch is resolved, eg \"1-alpha\" = \"1.0.0-alpha\" < \"1.0.1-ga\" = \"1.0.1\".","4919":"{13/} for Messaging","4920":"{13/} has the functionality to run the published stubs in memory.","4921":"It can integrate with the following frameworks out of the box","4923":"{22/} Stream","4924":"Apache Camel","4925":"{41/} AMQP","4926":"It also provides points of entry to integrate with any other solution on the market.","4927":"Stub triggering","4928":"To trigger a message it’s enough to use the {2500/} interface:","4929":"For convenience the {2501/} interface extends {2502/} so it’s enough to use only one in your tests.","4930":"{2503/} gives you the following options to trigger a message:","4931":"Trigger by label","4932":"Trigger by group and artifact ids","4933":"Trigger by artifact ids","4934":"Trigger all messages","4935":"{13/} Camel","4936":"{2/} Verifier {13/}'s messaging module gives you an easy way to integrate with Apache Camel.","4937":"For the provided artifacts it will automatically download the stubs and register the required routes.","4938":"Adding it to the project","4939":"It's enough to have both Apache Camel and {0/} on classpath.","4940":"Remember to annotate your test class with {2504/}.","4941":"Examples","4942":"Stubs structure","4943":"Let us assume that we have the following Maven repository with a deployed stubs for the\n{2505/} application.","4944":"And the stubs contain the following structure:","4945":"Let’s consider the following contracts (let' number it with 1):","4946":"and number 2","4947":"Scenario 1 (no input message)","4948":"So as to trigger a message via the {2506/} label we’ll use the {2507/} interface as follows","4949":"Next we’ll want to listen to the output of the message sent to {2508/}","4950":"And the received message would pass the following assertions","4951":"Scenario 2 (output triggered by input)","4952":"Since the route is set for you it’s enough to just send a message to the {2509/} destination.","4953":"Next we’ll want to listen to the output of the message sent to {2510/}","4954":"And the received message would pass the following assertions","4955":"Scenario 3 (input with no output)","4956":"Since the route is set for you it’s enough to just send a message to the {2511/} destination.","4957":"{13/} Integration","4958":"{2/} Verifier {13/}'s messaging module gives you an easy way to integrate with {20/}.","4959":"For the provided artifacts it will automatically download the stubs and register the required routes.","4960":"Adding it to the project","4961":"It's enough to have both Apache Camel and {0/} on classpath.","4962":"Remember to annotate your test class with {2512/}.","4963":"Examples","4964":"Stubs structure","4965":"Let us assume that we have the following Maven repository with a deployed stubs for the\n{2513/} application.","4966":"And the stubs contain the following structure:","4967":"Let’s consider the following contracts (let' number it with 1):","4968":"and number 2","4969":"and the following {20/} Route:","4970":"Scenario 1 (no input message)","4971":"So as to trigger a message via the {2514/} label we’ll use the {2515/} interface as follows","4972":"Next we’ll want to listen to the output of the message sent to {2516/}","4973":"And the received message would pass the following assertions","4974":"Scenario 2 (output triggered by input)","4975":"Since the route is set for you it’s enough to just send a message to the {2517/} destination.","4976":"Next we’ll want to listen to the output of the message sent to {2518/}","4977":"And the received message would pass the following assertions","4978":"Scenario 3 (input with no output)","4979":"Since the route is set for you it’s enough to just send a message to the {2519/} destination.","4980":"{13/} Stream","4981":"{2/} Verifier {13/}'s messaging module gives you an easy way to integrate with {41/} Stream.","4982":"For the provided artifacts it will automatically download the stubs and register the required routes.","4983":"Warning","4984":"\nIn {13/}’s integration with Stream the {2520/} or {2521/} Strings are resolved\nfirst as a {2522/} of a channel, and then if there is no such {2523/} it’s resolved as a\nchannel name.\n","4985":"Adding it to the project","4986":"It's enough to have both Apache Camel and {0/} on classpath.","4987":"Remember to annotate your test class with {2524/}.","4988":"Examples","4989":"Stubs structure","4990":"Let us assume that we have the following Maven repository with a deployed stubs for the\n{2525/} application.","4991":"And the stubs contain the following structure:","4992":"Let’s consider the following contracts (let' number it with 1):","4993":"and number 2","4994":"and the following {41/} configuration:","4995":"Scenario 1 (no input message)","4996":"So as to trigger a message via the {2526/} label we’ll use the {2527/} interface as follows","4997":"Next we’ll want to listen to the output of the message sent to a channel whose {2528/} is {2529/}","4998":"And the received message would pass the following assertions","4999":"Scenario 2 (output triggered by input)","5000":"Since the route is set for you it’s enough to just send a message to the {2530/} {2531/}.","5001":"Next we’ll want to listen to the output of the message sent to {2532/}","5002":"And the received message would pass the following assertions","5003":"Scenario 3 (input with no output)","5004":"Since the route is set for you it’s enough to just send a message to the {2533/} destination.","5005":"{13/} {41/} AMQP","5006":"{2/} Verifier {13/}'s messaging module provides an easy way to integrate with {41/} AMQP's Rabbit Template.","5007":"For the provided artifacts it will automatically download the stubs and register the required routes.","5008":"The integration tries to work standalone, that is without interaction with a running {45/} message broker.","5009":"It expects a {2534/} on the application context and uses it as a {30/} test {2535/}.","5010":"Thus it can use the mockito spy functionality to verify and introspect messages sent by the application.","5011":"On the message consumer side, it considers all {2536/} annotated endpoints as well as all `SimpleMessageListenerContainer`s on the application context.","5012":"As messages are usually sent to exchanges in AMQP the message contract contains the exchange name as the destination.","5013":"Message listeners on the other side are bound to queues.","5014":"Bindings connect an exchange to a queue.","5015":"If message contracts are triggered the {41/} AMQP stub runner integration will look for bindings on the application context that match this exchange.","5016":"Then it collects the queues from the {41/} exchanges and tries to find messages listeners bound to these queues.","5017":"The message is triggered to all matching message listeners.","5018":"Adding it to the project","5019":"It's enough to have both {41/} AMQP and {0/} on the classpath and set the property {2537/}.","5020":"Remember to annotate your test class with {2538/}.","5021":"Examples","5022":"Stubs structure","5023":"Let us assume that we have the following Maven repository with a deployed stubs for the\n{2539/} application.","5024":"And the stubs contain the following structure:","5025":"Let’s consider the following contract:","5026":"and the following {41/} configuration:","5027":"Triggering the message","5028":"So to trigger a message using the contract above we’ll use the {2540/} interface as follows.","5029":"The message has the destination {2541/} so the {41/} AMQP stub runner integration looks for bindings related to this exchange.","5030":"The binding definition binds the queue {2542/}.","5031":"So the following listener definition is a match and is invoked with the contract message.","5032":"Also, the following annotated listener represents a match and would be invoked.","5033":"Note","5034":"\nThe message is directly handed over to the {2543/} method of the {2544/} associated with the matching {2545/}.\n","5035":"{41/} AMQP Test Configuration","5036":"In order to avoid that {41/} AMQP is trying to connect to a running broker during our tests we configure a mock {2546/}.","5037":"To disable the mocked ConnectionFactory set the property {2547/}","5039":"Important","5040":"Remember that inside the contract file you have to provide the fully qualified name to the {2548/} class and the {2549/} static import ie {2550/}.","5041":"You can also provide an import to the {2551/} class {2552/} and then call {2553/}","5042":"{23/} is written in Groovy, but don't be alarmed if you didn't use Groovy before.","5043":"Knowledge of the language is not really needed as our DSL uses only a tiny subset of it (namely literals, method calls and closures).","5044":"What's more the DSL is designed to be programmer-readable without any knowledge of the DSL itself - it's statically typed.","5045":"Tip","5046":"\n{2/} supports defining multiple contracts in a single file!\n","5047":"The Contract is present in the {2554/} module of the {2/} Verifier repository.","5048":"Let’s look at full example of a contract definition.","5049":"Not all features of the DSL are used in example above.","5050":"If you didn't find what you are looking for, please check next paragraphs on this page.","5051":"You can easily compile {36/} to WireMock stubs mapping using standalone maven command: {2555/}.","5052":"Limitations","5053":"Warning","5054":"{2/} Verifier doesn't support XML properly.","5055":"Please use JSON or help us implement this feature.","5056":"Warning","5057":"The support for the verification of size of JSON arrays is experimental.","5058":"If you want to turn it on please provide the value of a system property {2556/} equal to {2557/}.","5059":"By default this feature is set to {2558/}.","5060":"You can also provide the {2559/} property in the plugin configuration.","5061":"Warning","5062":"Due to the fact that JSON structure can have any form it's sometimes impossible to parse it properly when using the {2560/} notation when using that in GString.","5063":"That's why we highly recommend using the Groovy Map notation.","5064":"Common Top-Level elements","5065":"Description","5066":"You can add a {2561/} to your contract that is nothing else but an arbitrary text.","5067":"Example:","5068":"Name","5069":"You can provide a name of your contract.","5070":"Let's assume that you've provided a name {2562/}.","5071":"If you do this then the name of the autogenerated test will be equal to {2563/}.","5072":"Also the name of the stub will be {2564/} in case of a WireMock stub.","5073":"Important","5074":"Please ensure that the name doesn't contain any characters that will make the generated test not possible to compile.","5075":"Also remember that if you provide the same name for multiple contracts then your autogenerated tests will fail to compile and your generated stubs will override each other.","5076":"Ignoring contracts","5077":"If you want to ignore a contract you can either set a value of ignored contracts in the plugin configuration\nor just set the {2565/} property on the contract itself:","5078":"HTTP Top-Level Elements","5079":"Following methods can be called in the top-level closure of a contract definition.","5080":"Request and response are mandatory, priority is optional.","5081":"Request","5082":"HTTP protocol requires only method and address to be specified in a request.","5083":"The same information is mandatory in request definition of the Contract.","5084":"It is possible to specify whole {2566/} instead of just path, but {2567/} is the recommended way as it makes the tests host-independent.","5085":"Request may contain query parameters, which are specified in a closure nested in a call to {2568/} or {2569/}.","5086":"It may contain additional request headers…​","5087":"…​and a request body.","5088":"Response","5089":"Minimal response must contain HTTP status code.","5090":"Besides status response may contain headers and body, which are specified the same way as in the request (see previous paragraph).","5091":"Dynamic properties","5092":"The contract can contain some dynamic properties - timestamps / ids etc. You don't want to enforce the consumers to stub their clocks to always return the same value of time so that it gets matched by the stub.","5093":"That's why we allow you to provide the dynamic parts in your contracts in two ways.","5094":"One is to pass them directly in the body and one to set them in a separate section called {2570/} and {2571/}.","5095":"Dynamic properties inside the body","5096":"You can set the properties inside the body either via the {2572/} method","5097":"or if you’re using the Groovy map notation for body you can use the {2573/} method","5098":"All of the aforementioned approaches are equal.","5099":"That means that {2574/} and {2575/} methods are aliases over the {2576/} method.","5100":"Let's take a closer look at what we can do with those values in the subsequent sections.","5101":"Regular expressions","5102":"You can use regular expressions to write your requests in {23/}.","5103":"It is particularly useful when you want to indicate that a given response should be provided for requests that follow a given pattern.","5104":"Also, you can use it when you need to use patterns and not exact values both for your test and your server side tests.","5105":"Please see the example below:","5106":"You can also provide only one side of the communication using a regular expression.","5107":"If you do that then automatically we'll provide the generated string that matches the provided regular expression.","5108":"For example:","5109":"In this example for request and response the opposite side of the communication will have the respective data generated.","5110":"{2/} comes with a series of predefined regular expressions that you can use in your contracts.","5111":"so in your contract you can use it like this","5112":"Passing optional parameters","5113":"It is possible to provide optional parameters in your contract.","5114":"It's only possible to have optional parameter for the:","5115":"STUB side of the Request","5116":"TEST side of the Response","5117":"Example:","5118":"By wrapping a part of the body with the {2577/} method you are in fact creating a regular expression that should be present 0 or more times.","5119":"That way for the example above the following test would be generated if you pick Spock:","5120":"and the following stub:","5121":"Executing custom methods on server side","5122":"It is also possible to define a method call to be executed on the server side during the test.","5123":"Such a method can be added to the class defined as \"baseClassForTests\" in the configuration.","5124":"Example:","5125":"Contract","5126":"Base class","5127":"Important","5128":"You can't use both a String and {2578/} to perform concatenation.","5129":"Eg calling {2579/} will lead to improper results.","5130":"To make this work just call {2580/} and ensure that the {2581/} method returns everything that you need.","5131":"Referencing request from response","5132":"The best situation is to provide fixed values but sometimes you need to reference a request in your response.","5133":"In order to do this you can profit from the {2582/} method that allows you to reference a bunch of elements from the HTTP request.","5134":"You can use the following options:","5135":"{2583/} - return the request URL","5136":"{2584/} - return the first query parameter with a given name","5137":"{2585/} - return the nth query parameter with a given name","5138":"{2586/} - return the first header with a given name","5139":"{2587/} - return the nth header with a given name","5140":"{2588/} - return the full request body","5141":"{2589/} - return the element from the request that matches the JSON Path","5142":"Let’s take a look at the following contract","5143":"Running a JUnit test generation will lead in creation of a test looking more or less like this","5144":"As you can see elements from the request have been properly referenced in the response.","5145":"The generated WireMock stub will look more or less like this:","5146":"So sending a request as the one presented in the {2590/} part of the contract will lead in sending the following\nresponse body","5147":"Important","5148":"This feature will work only with WireMock having version greater or equal to 2.5.1.","5149":"We're using WireMock's {2591/} response transformer.","5150":"It's using Handlebars to convert the Mustache {2592/} templates into proper values.","5151":"Additionally we're registering 2 helper functions.","5152":"{2593/} - that escapes the request body in a format that can be embedded in a JSON.","5153":"Another is {2594/} that for a given parameter knows how to find an object in the request body.","5154":"Dynamic properties in matchers sections","5155":"If you've been working with Pact this might seem familiar.","5156":"Quite a few users are used to having a separation between the body and setting dynamic parts of your contract.","5157":"That's why you can profit from two separate sections.","5158":"One is called {2595/} where you can define the dynamic values that should end up in a stub.","5159":"You can set it in the {2596/} or {2597/} part of your contract.","5160":"The other is called {2598/} which is present in the {2599/} or {2600/} side of the contract.","5161":"Currently we support only JSON Path based matchers with the following matching possibilities.","5162":"For {2601/}:","5163":"{2602/} - the value taken from the response via the provided JSON Path needs\nto be equal to the provided value in the contract","5164":"{2603/} - the value taken from the response via the provided JSON Path needs\nto match the regex","5165":"{2604/} - the value taken from the response via the provided JSON Path needs to\nmatch the regex for ISO Date","5166":"{2605/} - the value taken from the response via the provided JSON Path needs\nto match the regex for ISO DateTime","5167":"{2606/} - the value taken from the response via the provided JSON Path needs to\nmatch the regex for ISO Time","5168":"For {2607/}:","5169":"{2608/} - the value taken from the response via the provided JSON Path needs\nto be equal to the provided value in the contract","5170":"{2609/} - the value taken from the response via the provided JSON Path needs\nto match the regex","5171":"{2610/} - the value taken from the response via the provided JSON Path needs to\nmatch the regex for ISO Date","5172":"{2611/} - the value taken from the response via the provided JSON Path needs\nto match the regex for ISO DateTime","5173":"{2612/} - the value taken from the response via the provided JSON Path needs to\nmatch the regex for ISO Time","5174":"{2613/} - the value taken from the response via the provided JSON Path needs to be of the same type as the type defined in the body of the response in the contract.","5175":"{2614/} can take a closure where you can set {2615/} and {2616/}.","5176":"That way you can assert on the size of the collection.","5177":"{2617/} - the value taken from the response via the provided JSON Path will be passed as an input to the custom method that you're providing.","5178":"Eg {2618/} will result in calling a {2619/} method to which the value matching the JSON Path will get passed.","5179":"Let’s take a look at the following example:","5180":"In this example we're providing the dynamic portions of the contract in the matchers sections.","5181":"For the request part you can see that for all fields but {2620/} we're setting explicitly the values of regular expressions we'd like the stub to contain.","5182":"For the {2621/} the verification will take place in the same way as without the usage of matchers - the test will perform an equality check in this case.","5183":"For the response side in the {2622/} section we're defining all the dynamic parts in a similar manner.","5184":"The only difference is that we have the {2623/} matchers too.","5185":"In that case we're checking 4 fields in the way that we're verifying whether the response from the test has a value whose JSON path matching the given field is of the same type as the one defined in the response body and:","5186":"for {2624/} - we’re just checking the whether the type is the same","5187":"for {2625/} - we’re checking the type and assert if the size is greater or equal to the min occurrence","5188":"for {2626/} - we’re checking the type and assert if the size is smaller or equal to the max occurrence","5189":"for {2627/} - we’re checking the type and assert if the size is between the min and max occurrence","5190":"The resulting test would look more or less like this (note that we’re separating the autogenerated\nassertions and the one from matchers with an {2628/} section):","5191":"and the WireMock stub like this:","5192":"JAX-RS support","5193":"We support JAX-RS 2 Client API.","5194":"Base class needs to define {2629/} and server initialization, right now the only option how to test JAX-RS API is to start a web server.","5195":"Request with a body needs to have a content type set otherwise {2630/} is going to be used.","5196":"In order to use JAX-RS mode, use the following settings:","5197":"Example of a test API generated:","5198":"Async support","5199":"If you’re using asynchronous communication on the server side (your controllers are returning\n{2631/}, {2632/} etc. then inside your contract you have to provide in the {2633/}\nsection a {2634/} method. Example:","5200":"Working with Context Paths","5201":"{2/} supports context paths.","5202":"Important","5203":"The only thing that changes in order to fully support context paths is the switch on the PRODUCER side.","5204":"The autogenerated tests need to be using the EXPLICIT mode.","5205":"The consumer side remains untouched, in order for the generated test to pass you have to switch the EXPLICIT mode.","5206":"Maven","5207":"Gradle","5208":"That way you'll generate a test that DOES NOT use MockMvc.","5209":"It means that you're generating real requests and you need to setup your generated test's base class to work on a real socket.","5210":"Let’s imagine the following contract:","5211":"Here is an example of how to set up a base class and Rest Assured for everything to work correctly.","5212":"That way all:","5213":"all your requests in the autogenerated tests will be sent to the real endpoint with your context path included (e.g. {2635/})","5214":"your contracts reflect that you have a context path, thus your generated stubs will also\nhave that information (e.g. in the stubs you’ll see that you have too call {2636/})","5215":"Messaging Top-Level Elements","5216":"The DSL for messaging looks a little bit different than the one that focuses on HTTP.","5217":"Output triggered by a method","5218":"The output message can be triggered by calling a method (e.g. a Scheduler was started and a message was sent)","5219":"In this case the output message will be sent to {2637/} if a method called {2638/} will be executed.","5220":"In the message publisher’s side we will generate a test that will call that method to trigger the message.","5221":"On the consumer side you can use the {2639/} to trigger the message.","5222":"Output triggered by a message","5223":"The output message can be triggered by receiving a message.","5224":"In this case the output message will be sent to {2640/} if a proper message will be received on the {2641/} destination.","5225":"In the message publisher’s side we will generate a test that will send the input message to the defined destination.","5226":"On the consumer side you can either send a message to the input destination or use the {2642/} to trigger the message.","5227":"Consumer / Producer","5228":"In HTTP you have a notion of {2643/}/{2644/}/{2645/} notation.","5229":"You can use them also in messaging but we're providing also the {2646/} and {2647/} methods as presented below (note you can use either {2648/} or {2649/} methods to provide {2650/} and {2651/} parts)","5230":"Multiple contracts in one file","5231":"It's possible to define multiple contracts in one file.","5232":"An example of such a contract can look like this","5233":"In this example one contract has the {2652/} field and the other doesn't.","5234":"This will lead to generation of two tests that will look more or less like this:","5235":"Notice that for the contract that has the {2653/} field the generated test method is named {2654/}.","5236":"For the one that doesn't have the name it's called {2655/}.","5237":"It corresponds to the name of the file {2656/} and the index of the contract in the list.","5238":"The generated stubs will look like this","5239":"As you can see the first file got the {2657/} parameter from the contract.","5240":"The second got the name of the contract file {2658/} prefixed with the index (in this case contract had index {2659/} in the list of contracts in the file).","5241":"Tip","5242":"\nAs you can see it’s much better if you name your contracts since then your tests\n are far more meaningful.\n","5243":"Customization","5244":"Extending the DSL","5245":"It is possible to provide your own functions to the DSL.","5246":"The key requirement for this feature was to maintain the static compatibility.","5247":"Below you will be able to see an example of:","5248":"creation of a JAR with reusable classes","5249":"referencing of these classes in the DSLs","5250":"The full example can be found here.","5251":"Common JAR","5252":"Below you can find three classes that we will reuse in the DSLs.","5253":"PatternUtils contains functions used by both the consumer and the producer.","5254":"ConsumerUtils contains functions used by the consumer.","5255":"ProducerUtils contains functions used by the producer.","5256":"Adding the dependency to project","5257":"In order for the plugins and IDE to be able to reference the common JAR classes you need\nto pass the dependency to your project.","5258":"Test dependency in project’s dependencies","5259":"First add the common jar dependency as a test dependency.","5260":"That way since your contracts files are available at test resources path, automatically the common jar classes will be visible in your Groovy files.","5261":"Maven","5262":"Gradle","5263":"Test dependency in plugin’s dependencies","5264":"Now you have to add the dependency for the plugin to reuse at runtime.","5265":"Maven","5266":"Gradle","5267":"Referencing classes in DSLs","5268":"Now you can reference your classes in your DSL.","5269":"Example:","5270":"Pluggable architecture","5271":"There are cases where you have your contracts defined in other formats like YAML, RAML or PACT.","5272":"On the other hand you'd like to profit from the test and stubs generation.","5273":"It's really easy to add your own implementation of either of those.","5274":"Also you can customize the way tests are generated (for example you can generate tests for other languages) and you can do the same for stubs generation (you can generate stubs for other stub http server implementations).","5275":"Custom contract converter","5276":"Let’s assume that your contract is written in a YAML file like this:","5277":"Thanks to the interface","5278":"you can register your own implementation of a contract structure converter.","5279":"Your implementation needs to state the condition on which it should start the conversion.","5280":"Also you have to define how to perform that conversion in both ways.","5281":"Important","5282":"\nOnce you create your implementation you have to create a {2660/}\nfile in which you provide the fully qualified name of your implementation.\n","5283":"Example of a {2661/} file","5284":"and the YAML implementation","5285":"Pact converter","5286":"{2/} comes with an out of the box support for Pact representation of contracts.","5287":"In other words instead of using the Groovy DSL you can use Pact files.","5288":"In this section we will present how to add such a support for your project.","5289":"Pact contract","5290":"We will be working on the following example of a Pact contract.","5291":"We've placed this file under the {2662/} folder.","5292":"Pact for producers","5293":"On the producer side you have add to your plugin configuration two additional dependencies.","5294":"One is the {2/} Pact support and the other represents the current Pact version that you're using.","5295":"Maven","5296":"Gradle","5297":"When you execute the build of your application a test, looking more or less like this, will be generated","5298":"and the stub looking like this","5299":"Pact for consumers","5300":"On the producer side you have add to your project dependencies two additional dependencies.","5301":"One is the {2/} Pact support and the other represents the current Pact version that you're using.","5302":"Maven","5303":"Gradle","5304":"Custom test generator","5305":"If you want to generate tests for different languages than Java or you’re\nnot happy with the way we’re building Java tests for you then you can register\nyour own implementation to do that.","5306":"Thanks to the interface","5307":"you can register your own implementation that generates a test.","5308":"Again, it's enough to provide a proper {2663/} file.","5309":"Example:","5310":"Custom stub generator","5311":"If you want to generate stubs for other stub server than WireMock it’s enough to\n plug in your own implementation of this interface:","5312":"you can register your own implementation that generate Stubs.","5313":"Again, it's enough to provide a proper {2664/} file.","5314":"Example:","5315":"The default implementation is the WireMock stub generation.","5316":"Tip","5317":"You can provide multiple stub generator implementations.","5318":"That way for example from a single DSL as input you can eg produce WireMock stubs and Pact files too!","5319":"Custom {13/}","5320":"If you decide to have a custom stub generation you also need a custom way of running\nstubs with your different stub provider.","5321":"Let us assume that you're using Moco to build your stubs.","5322":"You wrote a proper stub generator and your stubs got placed in a JAR file.","5323":"In order for {13/} to know how to run your stubs you have to define a custom HTTP Stub server implementation.","5324":"It can look like this:","5325":"and just register it in your {2665/} file","5326":"that way you’ll be able to run stubs using Moco.","5327":"Important","5328":"If you don't provide any implementation then the default one - WireMock based will be picked.","5329":"If you provide more than one then the first one on the list will be picked.","5330":"Custom Stub Downloader","5331":"You can customize the way your stubs are downloaded.","5332":"If you don't want to download the JARs from Nexus / Artifactory in the way we do by default you can set your own implementation.","5333":"Below you can find an example of a Stub Downloader Provider that takes {2666/} files from the test resources from classpath, copies them to a temp file and then passes that temporary folder as a root for the stubs.","5334":"and just register it in your {2667/} file","5335":"that way you’ll be able to pick a folder with the source of your stubs.","5336":"Important","5337":"If you don't provide any implementation then the default one - Aether based that will download stubs from a remote repo will be picked.","5338":"If you provide more than one then the first one on the list will be picked.","5339":"Links","5340":"Here you can find interesting links related to {2/} Verifier:","5341":"{2/} Github Repository","5342":"{2/} Samples","5343":"{2/} Documentation","5344":"Accurest Legacy Documentation","5345":"{0/} Documentation","5346":"{0/} Messaging Documentation","5347":"{2/} Gitter","5348":"{2/} Maven Plugin","5349":"Appendix: Compendium of Configuration {31/}","5350":"Name","5351":"Default","5352":"Description","5353":"Flag to say that a process should fail if there is an encryption or decryption\n error.","5354":"A symmetric key.","5355":"As a stronger alternative consider using a keystore.","5356":"Alias for a key in the store.","5357":"Location of the key store file, e.g. classpath:/keystore.jks.","5358":"Password that locks the keystore.","5359":"Secret protecting the key (defaults to the same as the password).","5360":"The RSA algorithm to use (DEFAULT or OEAP).","5361":"Once it is set do not change it (or existing ciphers will not a decryptable).","5362":"Salt for the random secret used to encrypt cipher text.","5363":"Once it is set do not change it (or existing ciphers will not a decryptable).","5364":"Flag to indicate that \"strong\" AES encryption should be used internally.","5365":"If true then the GCM algorithm is applied to the AES encrypted bytes.","5366":"Default is false (in which case \"standard\" CBC is used instead).","5367":"Once it is set do not change it (or existing ciphers will not a decryptable).","5368":"Enable changing the Environment through a POST to /env.","5369":"Enable the /pause endpoint (to send Lifecycle.stop()).","5370":"Enable the /refresh endpoint to refresh configuration and re-initialize refresh scoped beans.","5371":"Enable the /restart endpoint to restart the application context.","5372":"Enable the /resume endpoint (to send Lifecycle.start()).","5373":"Enable the /zookeeper endpoint to inspect the state of zookeeper.","5374":"Indicates whether server can redirect a client request to a backup server/cluster.","5375":"If set to false, the server will handle the request directly, If set to true, it may send HTTP redirect to the client, with a new server location.","5376":"Gets the list of availability zones (used in AWS data centers) for the region in\n which this instance resides.\n","5377":" The changes are effective at runtime at the next registry fetch cycle as specified\n by registryFetchIntervalSeconds.","5378":"Gets the name of the implementation which implements BackupRegistry to fetch the\n registry information as a fall back option for only the first time when the eureka\n client starts.\n","5379":" This may be needed for applications which needs additional resiliency for registry\n information without which it cannot operate.","5380":"Cache refresh executor exponential back off related property.","5381":"It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred.","5382":"The thread pool size for the cacheRefreshExecutor to initialise with","5383":"EurekaAccept name for client data accept","5384":"This is a transient config and once the latest codecs are stable, can be removed\n (as there will only be one)","5385":"Indicates whether the eureka client should disable fetching of delta and should\n rather resort to getting the full registry information.\n","5386":" Note that the delta fetches can reduce the traffic tremendously, because the rate\n of change with the eureka server is normally much lower than the rate of fetches.\n","5387":" The changes are effective at runtime at the next registry fetch cycle as specified\n by registryFetchIntervalSeconds","5388":"Get a replacement string for Dollar sign <code>$</code> during\n serializing/deserializing information in eureka server.","5389":"Flag to indicate that the {62/} client is enabled.","5390":"This is a transient config and once the latest codecs are stable, can be removed\n (as there will only be one)","5391":"Get a replacement string for underscore sign <code>_</code> during\n serializing/deserializing information in eureka server.","5392":"Indicates how much time (in seconds) that the HTTP connections to eureka server can\n stay idle before it can be closed.\n","5393":" In the AWS environment, it is recommended that the values is 30 seconds or less,\n since the firewall cleans up the connection information after a few mins leaving\n the connection hanging in limbo","5394":"Indicates how long to wait (in seconds) before a connection to eureka server needs to timeout.","5395":"Note that the connections in the client are pooled by org.apache.http.client.HttpClient and this setting affects the actual connection creation and also the wait time to get the connection from the pool.","5396":"Gets the DNS name to be queried to get the list of eureka servers.This information\n is not required if the contract returns the service urls by implementing\n serviceUrls.\n","5397":" The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the\n eureka client expects the DNS to configured a certain way so that it can fetch\n changing eureka servers dynamically.\n","5398":" The changes are effective at runtime.","5399":"Gets the port to be used to construct the service url to contact eureka server when\n the list of eureka servers come from the DNS.This information is not required if\n the contract returns the service urls eurekaServerServiceUrls(String).\n","5400":" The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the\n eureka client expects the DNS to configured a certain way so that it can fetch\n changing eureka servers dynamically.\n","5401":" The changes are effective at runtime.","5402":"Indicates how long to wait (in seconds) before a read from eureka server needs to\n timeout.","5403":"Gets the total number of connections that is allowed from eureka client to all\n eureka servers.","5404":"Gets the total number of connections that is allowed from eureka client to a eureka\n server host.","5405":"Gets the URL context to be used to construct the service url to contact eureka server when the list of eureka servers come from the DNS.","5406":"This information is not required if the contract returns the service urls from eurekaServerServiceUrls.","5407":"The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically.","5408":"The changes are effective at runtime.","5409":"Indicates how often(in seconds) to poll for changes to eureka server information.","5410":"{62/} servers could be added or removed and this setting controls how soon the eureka clients should know about it.","5411":"Indicates whether this client should fetch eureka registry information from eureka\n server.","5412":"Comma separated list of regions for which the eureka registry information will be fetched.","5413":"It is mandatory to define the availability zones for each of these regions as returned by availabilityZones.","5414":"Failing to do so, will result in failure of discovery client startup.","5415":"Indicates whether to get the applications after filtering the applications for\n instances with only InstanceStatus UP states.","5416":"Indicates whether the content fetched from eureka server has to be compressed whenever it is supported by the server.","5417":"The registry information from the eureka server is compressed for optimum network traffic.","5418":"Heartbeat executor exponential back off related property.","5419":"It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred.","5420":"The thread pool size for the heartbeatExecutor to initialise with","5421":"Indicates how long initially (in seconds) to replicate instance info to the eureka\n server","5422":"Indicates how often(in seconds) to replicate instance changes to be replicated to\n the eureka server.","5423":"Indicates whether to log differences between the eureka server and the eureka\n client in terms of registry information.\n","5424":"{62/} client tries to retrieve only delta changes from eureka server to minimize network traffic.","5425":"After receiving the deltas, eureka client reconciles the information from the server to verify it has not missed out some information.","5426":"Reconciliation failures could happen when the client has had network issues communicating to server.If the reconciliation fails, eureka client gets the full registry information.","5427":" While getting the full registry information, the eureka client can log the\n differences between the client and the server and this setting controls that.\n","5428":" The changes are effective at runtime at the next registry fetch cycle as specified\n by registryFetchIntervalSecondsr","5429":"If set to true, local status updates via ApplicationInfoManager will trigger\n on-demand (but rate limited) register/updates to remote eureka servers","5430":"Indicates whether or not this instance should try to use the eureka server in the\n same zone for latency and/or other reason.\n","5431":" Ideally eureka clients are configured to talk to servers in the same zone\n","5432":" The changes are effective at runtime at the next registry fetch cycle as specified\n by registryFetchIntervalSeconds","5433":"Gets the proxy host to eureka server if any.","5434":"Gets the proxy password if any.","5435":"Gets the proxy port to eureka server if any.","5436":"Gets the proxy user name if any.","5437":"Gets the region (used in AWS datacenters) where this instance resides.","5438":"Indicates whether or not this instance should register its information with eureka\n server for discovery by others.\n","5439":" In some cases, you do not want your instances to be discovered whereas you just\n want do discover other instances.","5440":"Indicates how often(in seconds) to fetch the registry information from the eureka\n server.","5441":"Indicates whether the client is only interested in the registry information for a\n single VIP.","5442":"Map of availability zone to list of fully qualified URLs to communicate with eureka server.","5443":"Each value can be a single URL or a comma separated list of alternative locations.","5444":"Typically the eureka server URLs carry protocol,host,port,context and version information if any.","5445":"Example: http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/","5446":" The changes are effective at runtime at the next service url refresh cycle as\n specified by eurekaServiceUrlPollIntervalSeconds.","5447":"Indicates whether the eureka client should use the DNS mechanism to fetch a list of eureka servers to talk to.","5448":"When the DNS name is updated to have additional servers, that information is used immediately after the eureka client polls for that information as specified in eurekaServiceUrlPollIntervalSeconds.","5449":" Alternatively, the service urls can be returned serviceUrls, but the users should\n implement their own mechanism to return the updated list in case of changes.\n","5450":" The changes are effective at runtime.","5451":"Flag to enable the {62/} dashboard.","5452":"Default true.","5453":"The path to the {62/} dashboard (relative to the servlet path).","5454":"Defaults to \"/\".","5455":"Gets the AWS autoscaling group name associated with this instance.","5456":"This information is specifically used in an AWS environment to automatically put an instance out of service after the instance is launched and it has been disabled for traffic..","5457":"Get the name of the application group to be registered with eureka.","5458":"Get the name of the application to be registered with eureka.","5459":"Returns the data center this instance is deployed.","5460":"This information is used to get some AWS specific instance information if the instance is deployed in AWS.","5461":"Gets the absolute health check page URL for this instance.","5462":"The users can provide the healthCheckUrlPath if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL.","5463":"If the full URL is provided it takes precedence.","5464":"<p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage.","5465":"The full URL should follow the format http://${eureka.hostname}:7001/ where the value ${eureka.hostname} is replaced at runtime.","5466":"Gets the relative health check URL path for this instance.","5467":"The health check page URL is then constructed out of the hostname and the type of communication - secure or unsecure as specified in securePort and nonSecurePort.","5468":" It is normally used for making educated decisions based on the health of the\n instance - for example, it can be used to determine whether to proceed deployments\n to an entire farm or stop the deployments without causing further damage.","5469":"Gets the absolute home page URL for this instance.","5470":"The users can provide the homePageUrlPath if the home page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL.","5471":"If the full URL is provided it takes precedence.","5472":"It is normally used for informational purposes for other services to use it as a landing page.","5473":"The full URL should follow the format http://${eureka.hostname}:7001/ where the value ${eureka.hostname} is replaced at runtime.","5474":"Gets the relative home page URL Path for this instance.","5475":"The home page URL is then constructed out of the hostName and the type of communication - secure or unsecure.","5476":" It is normally used for informational purposes for other services to use it as a\n landing page.","5477":"The hostname if it can be determined at configuration time (otherwise it will be\n guessed from OS primitives).","5478":"Initial status to register with rmeote {62/} server.","5479":"Indicates whether the instance should be enabled for taking traffic as soon as it is registered with eureka.","5480":"Sometimes the application might need to do some pre-processing before it is ready to take traffic.","5481":"Get the unique Id (within the scope of the appName) of this instance to be\n registered with eureka.","5482":"Get the IPAdress of the instance.","5483":"This information is for academic purposes only as the communication from other instances primarily happen using the information supplied in {@link #getHostName(boolean)}.","5484":"Indicates the time in seconds that the eureka server waits since it received the\n last heartbeat before it can remove this instance from its view and there by\n disallowing traffic to this instance.\n","5485":"Setting this value too long could mean that the traffic could be routed to the instance even though the instance is not alive.","5486":"Setting this value too small could mean, the instance may be taken out of traffic because of temporary network glitches.This value to be set to atleast higher than the value specified in leaseRenewalIntervalInSeconds.","5487":"Indicates how often (in seconds) the eureka client needs to send heartbeats to eureka server to indicate that it is still alive.","5488":"If the heartbeats are not received for the period specified in leaseExpirationDurationInSeconds, eureka server will remove the instance from its view, there by disallowing traffic to this instance.","5489":" Note that the instance could still not take traffic if it implements\n HealthCheckCallback and then decides to make itself unavailable.","5490":"Gets the metadata name/value pairs associated with this instance.","5491":"This information is sent to eureka server and can be used by other instances.","5492":"Get the namespace used to find properties.","5493":"Ignored in {22/}.","5494":"Get the non-secure port on which the instance should receive traffic.","5495":"Indicates whether the non-secure port should be enabled for traffic or not.","5496":"Flag to say that, when guessing a hostname, the IP address of the server should be\n used in prference to the hostname reported by the OS.","5497":"Value used in determining when leases are cancelled, default to 1 for standalone.","5498":"Should be set to 0 for peer replicated eurekas","5499":"Gets the absolute secure health check page URL for this instance.","5500":"The users can provide the secureHealthCheckUrl if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL.","5501":"If the full URL is provided it takes precedence.","5502":"<p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage.","5503":"The full URL should follow the format http://${eureka.hostname}:7001/ where the value ${eureka.hostname} is replaced at runtime.","5504":"Get the Secure port on which the instance should receive traffic.","5505":"Indicates whether the secure port should be enabled for traffic or not.","5506":"Gets the secure virtual host name defined for this instance.\n","5507":" This is typically the way other instance would find this instance by using the\n secure virtual host name.Think of this as similar to the fully qualified domain\n name, that the users of your services will need to find this instance.","5508":"Gets the absolute status page URL path for this instance.","5509":"The users can provide the statusPageUrlPath if the status page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL.","5510":"If the full URL is provided it takes precedence.","5511":"It is normally used for informational purposes for other services to find about the status of this instance.","5512":"Users can provide a simple HTML indicating what is the current status of the instance.","5513":"Gets the relative status page URL path for this instance.","5514":"The status page URL is then constructed out of the hostName and the type of communication - secure or unsecure as specified in securePort and nonSecurePort.","5515":"It is normally used for informational purposes for other services to find about the status of this instance.","5516":"Users can provide a simple HTML indicating what is the current status of the instance.","5517":"Gets the virtual host name defined for this instance.\n","5518":" This is typically the way other instance would find this instance by using the\n virtual host name.Think of this as similar to the fully qualified domain name, that\n the users of your services will need to find this instance.","5519":"The list of supported mime types.","5520":"The minimum threshold content size.","5521":"Flag to indicate that the config server health indicator should be installed.","5522":"Time to live for cached result, in milliseconds.","5523":"Default 300000 (5 min).","5524":"Enable {47/} metrics polling.","5525":"Defaults to true.","5526":"Interval between subsequent polling of metrics.","5527":"Defaults to 2000 ms.","5528":"Enable the health endpoint for the refresh scope.","5529":"Enable the health endpoint for zookeeper.","5530":"When the {2668/} reaches this size, a warning is logged.","5531":"This will be useful if you are using string concatenation in RestTemplate urls.","5532":"Fully qualified class name for monitor registry used by {57/}.","5533":"Authentication strategy per route.","5534":"Service that wants to listen to acks.","5535":"By default null (meaning all services).","5536":"Flag to switch off acks (default on).","5537":"Name of {22/} Stream destination for messages.","5538":"Flag to indicate that the bus is enabled.","5539":"Flag to switch off environment change events (default on).","5540":"Flag to switch off refresh events (default on).","5541":"Flag to switch on tracing of acks (default off).","5542":"Flag to indicate that discovery is enabled.","5543":"Frequency in milliseconds of poll for heart beat.","5544":"The client will poll on this frequency and broadcast a list of service ids.","5545":"Organization name to authenticate with (default to user’s default).","5546":"Password for user to authenticate and obtain token.","5547":"Space name to authenticate with (default to user’s default).","5548":"URL of Cloud Foundry API (Cloud Controller).","5549":"Username to authenticate (usually an email address).","5550":"Flag to indicate that {@link #isSystemPropertiesOverride() systemPropertiesOverride} can be used.","5551":"Set to false to prevent users from changing the default accidentally.","5552":"Default true.","5553":"Authorization token used by the client to connect to the server.","5554":"Flag to indicate that config server discovery is enabled (config server URL will be\n looked up via discovery).","5555":"Service id to locate config server.","5556":"Flag to say that remote configuration is enabled.","5557":"Default true;","5558":"Flag to indicate that failure to connect to the server is fatal (default false).","5559":"The label name to use to pull remote configuration properties.","5560":"The default is set on the server (generally \"master\" for a git based server).","5561":"Name of application used to fetch remote properties.","5562":"Flag to indicate that when {@link #setAllowOverride(boolean) allowOverride} is true, external properties should take lowest priority, and not override any existing property sources (including local config files).","5563":"Default false.","5564":"Flag to indicate that the external properties should override system properties.","5565":"Default true.","5566":"The password to use (HTTP Basic) when contacting the remote server.","5567":"The default profile to use when fetching remote configuration (comma-separated).","5568":"Default is \"default\".","5569":"Initial retry interval in milliseconds.","5570":"Maximum number of attempts.","5571":"Maximum interval for backoff.","5572":"Multiplier for next interval.","5573":"Flag indicating that the config server should initialize its own Environment with properties from the remote repository.","5574":"Off by default because it delays startup but can be useful when embedding the server in another application.","5575":"Default application name when incoming requests do not have a specific one.","5576":"Default repository label when incoming requests do not have a specific label.","5577":"Default application profile when incoming requests do not have a specific one.","5578":"Enable decryption of environment properties before sending to client.","5579":"Base directory for local working copy of repository.","5580":"Flag to indicate that the repository should be cloned on startup (not on demand).","5581":"Generally leads to slower startup but faster first query.","5582":"Flag to indicate that the repository should force pull.","5583":"If true discard any local changes and take from remote repository.","5584":"Password for authentication with remote repository.","5585":"Map of repository identifier to location and other properties.","5586":"Search paths to use within local working copy.","5587":"By default searches only the root.","5588":"Timeout (in seconds) for obtaining HTTP or SSH connection (if applicable).","5589":"Default 5 seconds.","5590":"URI of remote repository.","5591":"Username for authentication with remote repository.","5592":"Flag to determine how to handle exceptions during decryption (default false).","5593":"Locations to search for configuration files.","5594":"Defaults to the same as a {19/} app so [classpath:/,classpath:/config/,file:./,file:./config/].","5595":"Version string to be reported for native repository","5596":"Extra map for a property source to be sent to all clients unconditionally.","5597":"Prefix for configuration resource paths (default is empty).","5598":"Useful when embedding in another application when you don't want to change the context path or servlet path.","5599":"Flag to indicate that YAML documents that are text or collections (not a map)\n should be returned in \"native\" form.","5600":"Base directory for local working copy of repository.","5601":"The default label for environment properties requests.","5602":"Password for authentication with remote repository.","5603":"Search paths to use within local working copy.","5604":"By default searches only the root.","5605":"URI of remote repository.","5606":"Username for authentication with remote repository.","5607":"Security Token passed thru to underlying environment repository.","5608":"The URI of the remote server (default http://localhost:8888).","5609":"The username to use (HTTP Basic) when contacting the remote server.","5610":"If format is Format.PROPERTIES or Format.YAML\n then the following field is used as key to look up consul for configuration.","5611":"Throw exceptions during config lookup if true, otherwise, log warnings.","5612":"The value of the fixed delay for the watch in millis.","5613":"Defaults to 1000.","5614":"If the watch is enabled.","5615":"Defaults to true.","5616":"The number of seconds to wait (or block) for watch query, defaults to 55. Needs to be less than default ConsulClient (defaults to 60).","5617":"To increase ConsulClient timeout create a ConsulClient bean with a custom ConsulRawClient with a custom HttpClient.","5618":"Tag to query for in service list if one is not listed in serverListQueryTags.","5619":"Service instance zone comes from metadata.","5620":"This allows changing the metadata tag name.","5621":"Is service discovery enabled?","5622":"Throw exceptions during service registration if true, otherwise, log\n warnings (defaults to true).","5623":"How often to perform the health check (e.g. 10s)","5624":"Alternate server path to invoke for health checking","5625":"Timeout for health check (e.g. 10s)","5626":"Custom health check url to override default","5627":"Hostname to use when accessing server","5628":"Unique service instance id","5629":"Service instance zone","5630":"IP address to use when accessing service (must also set preferIpAddress\n\t\t\tto use)","5631":"Port to register the management service under (defaults to management port)","5632":"Suffix to use when registering management service","5633":"Tags to use when registering management service","5634":"Port to register the service under (defaults to listening port)","5635":"Source of how we will determine the address to use","5636":"Use ip address rather than hostname during registration","5637":"Add the 'passing` parameter to /v1/health/service/serviceName.","5638":"This pushes health check passing to the server.","5639":"Register as a service in consul.","5640":"Register health check in consul.","5641":"Useful during development of a service.","5642":"Whether to register an http or https service","5643":"Map of serviceId's → tag to query for in server list.","5644":"This allows filtering services by a single tag.","5645":"Service name","5646":"Tags to use when registering service","5647":"Is {29/} enabled","5648":"{49/} agent hostname.","5649":"Defaults to 'localhost'.","5650":"{49/} agent port.","5651":"Defaults to '8500'.","5652":"Initial retry interval in milliseconds.","5653":"Maximum number of attempts.","5654":"Maximum interval for backoff.","5655":"Multiplier for next interval.","5656":"The default hostname.","5657":"Used in case of errors.","5658":"The default ipaddress.","5659":"Used in case of errors.","5660":"List of Java regex expressions for network interfaces that will be ignored.","5661":"List of Java regex expressions for network addresses that will be ignored.","5662":"Timeout in seconds for calculating hostname.","5663":"Use only interfaces with site local addresses.","5664":"See {@link InetAddress#isSiteLocalAddress()} for more details.","5665":"Initial amount of time to wait between retries","5666":"The unit of time related to blocking on connection to {37/}","5667":"Wait time to block on connection to {37/}","5668":"Connection string to the {37/} cluster","5669":"Default health endpoint that will be checked to verify that a dependency is alive","5670":"Mapping of alias to ZookeeperDependency.","5671":"From {43/} perspective the alias is actually serviceID since {43/} can't accept nested structures in serviceID","5672":"Predefined host with which a service can register itself in {37/}.","5673":"Corresponds to the {code address} from the URI spec.","5674":"Port to register the service under (defaults to listening port)","5675":"Gets the metadata name/value pairs associated with this instance.","5676":"This information is sent to zookeeper and can be used by other instances.","5677":"Register as a service in zookeeper.","5678":"Root {37/} folder in which all instances are registered","5679":"The URI specification to resolve during service registration in {37/}","5680":"Is {37/} enabled","5681":"Max number of times to retry","5682":"Max time in ms to sleep on each retry","5683":"Common prefix that will be applied to all {37/} dependencies' paths","5684":"Fixed delay for default poller.","5685":"Maximum messages per poll for the default poller.","5686":"Enable {20/} sleuth instrumentation.","5687":"An array of simple patterns against which channel names will be matched.","5688":"Default is * (all channels).","5689":"See org.springframework.util.PatternMatchUtils.simpleMatch(String, String).","5690":"Simple name of the class with a method annotated with {@code @Async}\n from which the asynchronous process started\n","5691":" @see org.springframework.scheduling.annotation.Async","5692":"Name of the method annotated with {@code @Async}\n","5693":" @see org.springframework.scheduling.annotation.Async","5694":"Prefix for header names if they are added as tags.","5695":"Name of the thread that executed the async method\n","5696":" @see org.springframework.scheduling.annotation.Async","5697":"Additional headers that should be added as tags if they exist.","5698":"If the header value is multi-valued, the tag value will be a comma-separated, single-quoted list.","5699":"The domain portion of the URL or host header.","5700":"Example: \"mybucket.s3.amazonaws.com\".","5701":"Used to filter by host as opposed to ip address.","5702":"The HTTP method, or verb, such as \"GET\" or \"POST\".","5703":"Used to filter against an http route.","5704":"The absolute http path, without any query parameters.","5705":"Example: \"/objects/abcd-ff\".","5706":"Used to filter against an http route, portably with zipkin v1.","5707":"In zipkin v1, only equals filters are supported.","5708":"Dropping query parameters makes the number of distinct URIs less.","5709":"For example, one can query for the same resource, regardless of signing parameters encoded in the query line.","5710":"This does not reduce cardinality to a HTTP single route.","5711":"For example, it is common to express a route as an http URI template like \"/resource/{resource_id}\".","5712":"In systems where only equals queries are available, searching for {@code http.uri=/resource} won't match if the actual request was \"/resource/abcd-ff\".","5713":"Historical note: This was commonly expressed as \"http.uri\" in zipkin, eventhough it was most often just a path.","5714":"Prefix for header names if they are added as tags.","5715":"The size of the non-empty HTTP request body, in bytes.","5716":"Ex.","5718":" <p>Large uploads can exceed limits or contribute directly to latency.","5719":"The size of the non-empty HTTP response body, in bytes.","5720":"Ex.","5722":" <p>Large downloads can exceed limits or contribute directly to latency.","5723":"The HTTP response code, when not in 2xx range.","5724":"Ex.","5725":"\"503\" Used to filter for error status.","5726":"2xx range are not logged as success codes are less interesting for latency troubleshooting.","5727":"Omitting saves at least 20 bytes per span.","5728":"The entire URL, including the scheme, host and query parameters if available.","5729":"Ex.","5730":"\"https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Algorithm=AWS4-HMAC-SHA256…\" Combined with {@link #method}, you can understand the fully-qualified request line.","5731":"This is optional as it may include private data or be of considerable length.","5732":"Name of the command group.","5733":"{47/} uses the command group key to group together commands such as for reporting, alerting, dashboards, or team/library ownership.","5734":" @see com.netflix.hystrix.HystrixCommandGroupKey","5735":"Name of the command key.","5736":"Describes the name for the given command.","5737":"A key to represent a {@link com.netflix.hystrix.HystrixCommand} for monitoring, circuit-breakers, metrics publishing, caching and other such uses.","5738":" @see com.netflix.hystrix.HystrixCommandKey","5739":"Prefix for header names if they are added as tags.","5740":"Name of the thread pool key.","5741":"The thread-pool key represents a {@link com.netflix.hystrix.HystrixThreadPool} for monitoring, metrics publishing, caching, and other such uses.","5742":"A {@link com.netflix.hystrix.HystrixCommand} is associated with a single {@link com.netflix.hystrix.HystrixThreadPool} as retrieved by the {@link com.netflix.hystrix.HystrixThreadPoolKey} injected into it, or it defaults to one created using the {@link com.netflix.hystrix.HystrixCommandGroupKey} it is created with.","5743":" @see com.netflix.hystrix.HystrixThreadPoolKey","5744":"Additional headers that should be added as tags if they exist.","5745":"If the header value is not a String it will be converted to a String using its toString() method.","5746":"An estimate of the size of the payload if available.","5747":"The type of the payload.","5748":"Prefix for header names if they are added as tags.","5749":"The lower case, hyphen delimited name of the class that processes the request.","5750":"Ex.","5751":"class named \"BookController\" will result in \"book-controller\" tag value.","5752":"The lower case, hyphen delimited name of the class that processes the request.","5753":"Ex.","5754":"method named \"listOfBooks\" will result in \"list-of-books\" tag value.","5755":"Percentage of requests that should be sampled.","5756":"Eg 1.0 - 100% requests should be sampled.","5757":"The precision is whole-numbers only (ie there's no support for 0.1% of the traces).","5758":"When true, generate 128-bit trace IDs instead of 64-bit ones.","5759":"Flag to determine whether the proxy forwards the Host header.","5760":"Flag to determine whether the proxy adds X-Forwarded-* headers.","5761":"The maximum number of connections that can be used by a single route.","5762":"The maximum number of total connections the proxy can hold open to backends.","5763":"Flag to say that SECURITY_HEADERS are added to ignored headers if {21/} is on the classpath.","5764":"By setting ignoreSecurityHeaders to false we can switch off this default behaviour.","5765":"This should be used together with disabling the default {21/} headers see https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers","5766":"Names of HTTP headers to ignore completely (i.e. leave them out of downstream\n requests and drop them from downstream responses).","5767":"Set of service names not to consider for proxying automatically.","5768":"By default all services in the discovery client will be proxied.","5769":"A common prefix for all routes.","5770":"Flag to say that path elements past the first semicolon can be dropped.","5771":"Flag for whether retry is supported by default (assuming the routes themselves\n support it).","5772":"Map of route names to properties.","5773":"Headers that are generally expected to be added by {41/} Security, and hence often duplicated if the proxy and the backend are secured with {41/}.","5774":"By default they are added to the ignored headers if {41/} Security is present and ignoreSecurityHeaders = true.","5775":"The maximum number of total semaphores for {47/}.","5776":"List of sensitive headers that are not passed to downstream requests.","5777":"Defaults to a \"safe\" set of headers that commonly contain user credentials.","5778":"It's OK to remove those from the list if the downstream service is part of the same system as the proxy, so they are sharing authentication data.","5779":"If using a physical URL outside your own domain, then generally it would be a bad idea to leak user credentials.","5780":"Path to install {60/} as a servlet (not part of {41/} MVC).","5781":"The servlet is more memory efficient for requests with large bodies, eg file uploads.","5782":"Flag to say whether the hostname for ssl connections should be verified or not.","5783":"Default is true.","5784":"This should only be used in test setups!","5785":"Flag saying whether to strip the prefix from the path before forwarding.","5786":"Flag to say that request bodies can be traced."},"errors":{},"nouns":{"0":"Spring Cloud Contract Stub Runner","1":"Spring Cloud Zookeeper","2":"Spring Cloud Contract","3":"Spring Cloud Security","4":"Spring Cloud Commons","5":"Spring Cloud Netflix","6":"Kafka Binder","7":"Dead-Letter","8":"Avro Schema","9":"Spring Cloud Bus","10":"Feign Hystrix","11":"Apache Avro","12":"Spring RestTemplate","13":"Stub Runner","14":"Consul Agent","15":"Turbine Stream","16":"Spring Cloud Config","18":"RabbitMQ Binder","19":"Spring Boot","20":"Spring Integration","21":"spring security","22":"Spring Cloud","23":"Contract DSL","28":"spring-cloud-stream","29":"spring cloud consul","30":"spring boot","31":"Properties","32":"Binder SPI","33":"Bus Events","35":"Binders","36":"Contracts","37":"Zookeeper","38":"Archaius","39":"Events","40":"Schema","41":"Spring","42":"Spectator","43":"Ribbon","44":"Polyglot","45":"RabbitMQ","46":"Zipkin","47":"Hystrix","48":"Binder","49":"Consul","50":"Turbine","51":"Sidecar","52":"Span Data","54":"Vault","55":"Feign","56":"Atlas","57":"Servo","58":"Kafka","59":"Span","60":"Zuul","61":"spans","62":"Eureka"},"name":"spring-cloud-dalston","timestamp":1494045635079});</script><div id="xyuu-gt-tt" class="skiptranslate" name="spring-cloud-dalston" style="left: 527px; top: 1473px;"><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">原文</h1></div><div class="middle" style="padding: 8px;"><div class="original-text">Spring Cloud Context: Application Context Services</div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"><div style="opacity: 1;"><div class="alt-translated-items"></div><div class="alt-translated-text"></div><div class="alt-helper-text"></div><textarea rows="1" style="overflow-y: hidden; overflow-x: auto; box-sizing: border-box; height: auto;display: none"></textarea><div class="activity-form-container"><div class="translate-form"><div class="form-message"></div><div class="form-buttons" style="text-align:left"><input class="activity-submit" type="button" value="提交建议"><input class="activity-cancel" type="button" value="取消"></div></div></div></div></div></div><div class="status-message" style="display: none;"></div></div></div></body></html>